-- Start of Il2cppApi.lua content
local __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)
	local loadingPlaceholder = {[{}] = true}

	local register
	local modules = {}

	local require
	local loaded = {}

	register = function(name, body)
		if not modules[name] then
			modules[name] = body
		end
	end

	require = function(name)
		local loadedModule = loaded[name]

		if loadedModule then
			if loadedModule == loadingPlaceholder then
				return nil -- Module is currently loading (circular dependency)
			end
		else
			if not modules[name] then
				if not superRequire then
					local identifier = type(name) == 'string' and '\"' .. name .. '\"' or tostring(name)
					error('Tried to require ' .. identifier .. ', but no such module has been registered')
				else
					return superRequire(name) -- Fallback to an external require if available
				end
			end

			loaded[name] = loadingPlaceholder
			loadedModule = modules[name](require, loaded, register, modules)
			loaded[name] = loadedModule
		end

		return loadedModule
	end

	return require, loaded, register, modules
end)(require) -- Pass the global require if available, otherwise it will be nil

__bundle_register("GGIl2cpp", function(require, _LOADED, __bundle_register, __bundle_modules)
require("utils.il2cppconst")
require("il2cpp")

---@class ClassInfoRaw
---@field ClassName string | nil
---@field ClassInfoAddress number
---@field ImageName string

---@class ClassInfo
---@field ClassName string
---@field ClassAddress string
---@field Methods MethodInfo[] | nil
---@field Fields FieldInfo[] | nil
---@field Parent ParentClassInfo | nil
---@field ClassNameSpace string
---@field StaticFieldData number | nil
---@field IsEnum boolean
---@field TypeMetadataHandle number
---@field InstanceSize number
---@field Token string
---@field ImageName string
---@field GetFieldWithName fun(self : ClassInfo, name : string) : FieldInfo | nil @Get FieldInfo by Field Name. If Fields weren't dumped, then this function return `nil`. Also, if Field isn't found by name, then function will return `nil`
---@field GetMethodsWithName fun(self : ClassInfo, name : string) : MethodInfo[] | nil @Get MethodInfo[] by MethodName. If Methods weren't dumped, then this function return `nil`. Also, if Method isn't found by name, then function will return `table with zero size`
---@field GetFieldWithOffset fun(self : ClassInfo, fieldOffset : number) : FieldInfo | nil

---@class ParentClassInfo
---@field ClassName string
---@field ClassAddress string

---@class FieldInfoRaw
---@field FieldInfoAddress number
---@field ClassName string | nil


---@class ClassMemory
---@field config ClassConfig
---@field result ClassInfo[] | ErrorSearch
---@field len number
---@field isNew boolean | nil

---@class MethodMemory
---@field len number
---@field result MethodInfo[] | ErrorSearch
---@field isNew boolean | nil

---@class FieldInfo
---@field ClassName string 
---@field ClassAddress string 
---@field FieldName string
---@field Offset string
---@field IsStatic boolean
---@field Type string
---@field IsConst boolean
---@field Access string
---@field GetConstValue fun(self : FieldInfo) : nil | string | number


---@class MethodInfoRaw
---@field MethodName string | nil
---@field Offset number | nil
---@field MethodInfoAddress number
---@field ClassName string | nil
---@field MethodAddress number


---@class ErrorSearch
---@field Error string


---@class MethodInfo
---@field MethodName string
---@field Offset string
---@field AddressInMemory string
---@field MethodInfoAddress number
---@field ClassName string
---@field ClassAddress string
---@field ParamCount number
---@field ReturnType string
---@field IsStatic boolean
---@field IsAbstract boolean
---@field Access string


---@class Il2cppApi
---@field FieldApiOffset number
---@field FieldApiType number
---@field FieldApiClassOffset number
---@field ClassApiNameOffset number
---@field ClassApiMethodsStep number
---@field ClassApiCountMethods number
---@field ClassApiMethodsLink number
---@field ClassApiFieldsLink number
---@field ClassApiFieldsStep number
---@field ClassApiCountFields number
---@field ClassApiParentOffset number
---@field ClassApiNameSpaceOffset number
---@field ClassApiStaticFieldDataOffset number
---@field ClassApiEnumType number
---@field ClassApiEnumRsh number
---@field ClassApiTypeMetadataHandle number
---@field ClassApiInstanceSize number
---@field ClassApiToken number
---@field MethodsApiClassOffset number
---@field MethodsApiNameOffset number
---@field MethodsApiParamCount number
---@field MethodsApiReturnType number
---@field MethodsApiFlags number
---@field typeDefinitionsSize number
---@field typeDefinitionsOffset number
---@field stringOffset number
---@field fieldDefaultValuesOffset number
---@field fieldDefaultValuesSize number
---@field fieldAndParameterDefaultValueDataOffset number
---@field TypeApiType number
---@field Il2CppTypeDefinitionApifieldStart number
---@field MetadataRegistrationApitypes number


---@class ClassConfig
---@field Class number | string @Class Name or Address Class
---@field FieldsDump boolean
---@field MethodsDump boolean


---@class Il2cppConfig
---@field libilcpp table | nil
---@field globalMetadata table | nil
---@field il2cppVersion number | nil
---@field globalMetadataHeader number | nil
---@field metadataRegistration number | nil


---@class Il2CppTypeDefinitionApi
---@field fieldStart number

---@class MethodFlags
---@field Access string[]
---@field METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK number
---@field METHOD_ATTRIBUTE_STATIC number
---@field METHOD_ATTRIBUTE_ABSTRACT number


---@class FieldFlags
---@field Access string[]
---@field FIELD_ATTRIBUTE_FIELD_ACCESS_MASK number
---@field FIELD_ATTRIBUTE_STATIC number
---@field FIELD_ATTRIBUTE_LITERAL number


return Il2cpp -- This was originally in the file, but typically not needed for bundled modules.
              -- The Il2cpp object is usually made global by the "il2cpp" module itself.
end)
__bundle_register("il2cpp", function(require, _LOADED, __bundle_register, __bundle_modules)
local Il2cppMemory = require("utils.il2cppmemory")
local VersionEngine = require("utils.version")
local AndroidInfo = require("utils.androidinfo")
local Searcher = require("utils.universalsearcher")
local PatchApi = require("utils.patchapi")



---@class Il2cpp
local Il2cppBase = {
    il2cppStart = 0,
    il2cppEnd = 0,
    globalMetadataStart = 0,
    globalMetadataEnd = 0,
    globalMetadataHeader = 0,
    MainType = AndroidInfo.platform and gg.TYPE_QWORD or gg.TYPE_DWORD,
    pointSize = AndroidInfo.platform and 8 or 4,
    ---@type Il2CppTypeDefinitionApi
    Il2CppTypeDefinitionApi = {},
    MetadataRegistrationApi = require("il2cppstruct.metadataRegistration"),
    TypeApi = require("il2cppstruct.type"),
    MethodsApi = require("il2cppstruct.method"),
    GlobalMetadataApi = require("il2cppstruct.globalmetadata"),
    FieldApi = require("il2cppstruct.field"),
    ClassApi = require("il2cppstruct.class"),
    ObjectApi = require("il2cppstruct.object"),
    ClassInfoApi = require("il2cppstruct.api.classinfo"),
    FieldInfoApi = require("il2cppstruct.api.fieldinfo"),
    ---@type MyString
    String = require("il2cppstruct.il2cppstring"),
    MemoryManager = require("utils.malloc"),
    --- Patch `Bytescodes` to `add`
    ---
    --- Example:
    --- arm64: 
    --- `mov w0,#0x1`
    --- `ret`
    ---
    --- `Il2cpp.PatchesAddress(0x100, "\x20\x00\x80\x52\xc0\x03\x5f\xd6")`
    ---@param add number
    ---@param Bytescodes string
    ---@return Patch
    PatchesAddress = function(add, Bytescodes)
        local patchCode = {}
        for code in string.gmatch(Bytescodes, '.') do
            patchCode[#patchCode + 1] = {
                address = add + #patchCode,
                value = string.byte(code),
                flags = gg.TYPE_BYTE
            }
        end
        ---@type Patch
        local patch = PatchApi:Create(patchCode)
        patch:Patch()
        return patch
    end,


    --- Searches for a method, or rather information on the method, by name or by offset, you can also send an address in memory to it.
    --- 
    --- Return table with information about methods.
    ---@generic TypeForSearch : number | string
    ---@param searchParams TypeForSearch[] @TypeForSearch = number | string
    ---@return table<number, MethodInfo[] | ErrorSearch>
    FindMethods = function(searchParams)
        Il2cppMemory:SaveResults()
        for i = 1, #searchParams do
            ---@type number | string
            searchParams[i] = Il2cpp.MethodsApi:Find(searchParams[i])
        end
        Il2cppMemory:ClearSavedResults()
        return searchParams
    end,


    --- Searches for a class, by name, or by address in memory.
    --- 
    --- Return table with information about class.
    ---@param searchParams ClassConfig[]
    ---@return table<number, ClassInfo[] | ErrorSearch>
    FindClass = function(searchParams)
        Il2cppMemory:SaveResults()
        for i = 1, #searchParams do
            searchParams[i] = Il2cpp.ClassApi:Find(searchParams[i])
        end
        Il2cppMemory:ClearSavedResults()
        return searchParams
    end,


    --- Searches for an object by name or by class address, in memory.
    --- 
    --- In some cases, the function may return an incorrect result for certain classes. For example, sometimes the garbage collector may not have time to remove an object from memory and then a `fake object` will appear or for a turnover, the object may still be `not implemented` or `not created`.
    ---
    --- Returns a table of objects.
    ---@param searchParams table
    ---@return table
    FindObject = function(searchParams)
        Il2cppMemory:SaveResults()
        for i = 1, #searchParams do
            searchParams[i] = Il2cpp.ObjectApi:Find(Il2cpp.ClassApi:Find({Class = searchParams[i]}))
        end
        Il2cppMemory:ClearSavedResults()
        return searchParams
    end,


    --- Searches for a field, or rather information about the field, by name or by address in memory.
    --- 
    --- Return table with information about fields.
    ---@generic TypeForSearch : number | string
    ---@param searchParams TypeForSearch[] @TypeForSearch = number | string
    ---@return table<number, FieldInfo[] | ErrorSearch>
    FindFields = function(searchParams)
        Il2cppMemory:SaveResults()
        for i = 1, #searchParams do
            ---@type number | string
            local searchParam = searchParams[i]
            local searchResult = Il2cppMemory:GetInformationOfField(searchParam)
            if not searchResult then
                searchResult = Il2cpp.FieldApi:Find(searchParam)
                Il2cppMemory:SetInformationOfField(searchParam, searchResult)
            end
            searchParams[i] = searchResult
        end
        Il2cppMemory:ClearSavedResults()
        return searchParams
    end,


    ---@param Address number
    ---@param length? number
    ---@return string
    Utf8ToString = function(Address, length)
        local chars, char = {}, {
            address = Address,
            flags = gg.TYPE_BYTE
        }
        if not length then
            repeat
                _char = string.char(gg.getValues({char})[1].value & 0xFF)
                chars[#chars + 1] = _char
                char.address = char.address + 0x1
            until string.find(_char, "[%z%s]")
            return table.concat(chars, "", 1, #chars - 1)
        else
            for i = 1, length do
                local _char = gg.getValues({char})[1].value
                chars[i] = string.char(_char & 0xFF)
                char.address = char.address + 0x1
            end
            return table.concat(chars)
        end
    end,


    ---@param bytes string
    ChangeBytesOrder = function(bytes)
        local newBytes, index, lenBytes = {}, 0, #bytes / 2
        for byte in string.gmatch(bytes, "..") do
            newBytes[lenBytes - index] = byte
            index = index + 1
        end
        return table.concat(newBytes)
    end,


    FixValue = function(val)
        return AndroidInfo.platform and val & 0x00FFFFFFFFFFFFFF or val & 0xFFFFFFFF
    end,


    GetValidAddress = function(Address)
        local lastByte = Address & 0x000000000000000F
        local delta = 0
        local checkTable = {[12] = true, [4] = true, [8] = true, [0] = true}
        while not checkTable[lastByte - delta] do
            delta = delta + 1
        end
        return Address - delta
    end,


    ---@param self Il2cpp
    ---@param address number | string
    SearchPointer = function(self, address)
        address = self.ChangeBytesOrder(type(address) == 'number' and string.format('%X', address) or address)
        gg.searchNumber('h ' .. address)
        gg.refineNumber('h ' .. address:sub(1, 6))
        gg.refineNumber('h ' .. address:sub(1, 2))
        local FindsResult = gg.getResults(gg.getResultsCount())
        gg.clearResults()
        return FindsResult
    end,
}

---@type Il2cpp
Il2cpp = setmetatable({}, {
    ---@param self Il2cpp
    ---@param config? Il2cppConfig
    __call = function(self, config)
        config = config or {}
        getmetatable(self).__index = Il2cppBase

        if config.libilcpp then
            self.il2cppStart, self.il2cppEnd = config.libilcpp.start, config.libilcpp['end']
        else
            self.il2cppStart, self.il2cppEnd = Searcher.FindIl2cpp()
        end

        if config.globalMetadata then
            self.globalMetadataStart, self.globalMetadataEnd = config.globalMetadata.start, config.globalMetadata['end']
        else
            self.globalMetadataStart, self.globalMetadataEnd = Searcher:FindGlobalMetaData()
        end

        if config.globalMetadataHeader then
            self.globalMetadataHeader = config.globalMetadataHeader
        else
            self.globalMetadataHeader = self.globalMetadataStart
        end
        
        self.MetadataRegistrationApi.metadataRegistration = config.metadataRegistration

        VersionEngine:ChooseVersion(config.il2cppVersion, self.globalMetadataHeader)

        Il2cppMemory:ClearMemorize()
    end,
    __index = function(self, key)
        assert(key == "PatchesAddress", "You didn't call 'Il2cpp'")
        return Il2cppBase[key]
    end
})

return Il2cpp -- This makes the Il2cpp object available if this module is required.
end)
__bundle_register("utils.malloc", function(require, _LOADED, __bundle_register, __bundle_modules)
local MemoryManager = {
    availableMemory = 0,
    lastAddress = 0,

    NewAlloc = function(self)
        self.lastAddress = gg.allocatePage(gg.PROT_READ | gg.PROT_WRITE)
        self.availableMemory = 4096
    end,
}

local M = {
    ---@param size number
    MAlloc = function(size)
        local manager = MemoryManager
        if size > manager.availableMemory then
            manager:NewAlloc()
        end
        local address = manager.lastAddress
        manager.availableMemory = manager.availableMemory - size
        manager.lastAddress = manager.lastAddress + size
        return address
    end,
}

return M
end)
__bundle_register("il2cppstruct.il2cppstring", function(require, _LOADED, __bundle_register, __bundle_modules)
---@class StringApi
---@field address number
---@field pointToStr number
---@field Fields table<string, number>
---@field ClassAddress number
local StringApi = {

    ---@param self StringApi
    ---@param newStr string
    EditString = function(self, newStr)
        local _stringLength = gg.getValues{{address = self.address + self.Fields._stringLength, flags = gg.TYPE_DWORD}}[1].value
        _stringLength = _stringLength * 2
        local bytes = gg.bytes(newStr, "UTF-16LE")
        if _stringLength == #bytes then
            local strStart = self.address + self.Fields._firstChar
            for i, v in ipairs(bytes) do
                bytes[i] = {
                    address = strStart + (i - 1),
                    flags = gg.TYPE_BYTE,
                    value = v
                }
            end

            gg.setValues(bytes)
        elseif _stringLength > #bytes then
            local strStart = self.address + self.Fields._firstChar
            local _bytes = {}
            for i = 1, _stringLength do
                _bytes[#_bytes + 1] = {
                    address = strStart + (i - 1),
                    flags = gg.TYPE_BYTE,
                    value = bytes[i] or 0
                }
            end

            gg.setValues(_bytes)
        elseif _stringLength < #bytes then
            self.address = Il2cpp.MemoryManager.MAlloc(self.Fields._firstChar + #bytes + 8)
            local length = #bytes % 2 == 1 and #bytes + 1 or #bytes
            local _bytes = {
                { -- Head
                    address = self.address,
                    flags = Il2cpp.MainType,
                    value = self.ClassAddress
                },
                { -- _stringLength
                    address = self.address + self.Fields._stringLength,
                    flags = gg.TYPE_DWORD,
                    value = length / 2
                }
            }
            local strStart = self.address + self.Fields._firstChar
            for i = 1, length do
                _bytes[#_bytes + 1] = {
                    address = strStart + (i - 1),
                    flags = gg.TYPE_BYTE,
                    value = bytes[i] or 0
                }                
            end
            _bytes[#_bytes + 1] = {
                address = self.pointToStr,
                flags = Il2cpp.MainType,
                value = self.address
            }
            gg.setValues(_bytes)
        end
    end,



    ---@param self StringApi
    ---@return string
    ReadString = function(self)
        local _stringLength = gg.getValues{{address = self.address + self.Fields._stringLength, flags = gg.TYPE_DWORD}}[1].value
        local bytes = {}
        if _stringLength > 0 and _stringLength < 200 then -- Limiting length for performance
            local strStart = self.address + self.Fields._firstChar
            for i = 0, _stringLength -1 do -- Iterate actual length
                bytes[#bytes + 1] = {
                    address = strStart + (i << 1), -- UTF-16 characters are 2 bytes
                    flags = gg.TYPE_WORD
                }
            end
            if #bytes == 0 then return "" end -- Handle empty string case
            
            bytes = gg.getValues(bytes)
            local code = {[[return "]]}
            for i, v in ipairs(bytes) do
                code[#code + 1] = string.format([[\u{%x}]], v.value & 0xFFFF)
            end
            code[#code + 1] = '"'
            local readFunc, err = load(table.concat(code))
            if readFunc then
                return readFunc()
            else
                -- Handle error, e.g., print(err) or return a default
                return "ErrorReadingString: " .. (err or "unknown")
            end
        end
        return ""
    end
}

---@class MyString
---@field From fun(address : number) : StringApi | nil
local String = {

    ---@param address number
    ---@return StringApi | nil
    From = function(address)
        local pointToStrValue = gg.getValues({{address = Il2cpp.FixValue(address), flags = Il2cpp.MainType}})[1]
        if not pointToStrValue then return nil end -- Guard against invalid address

        local str = setmetatable(
            {
                address = Il2cpp.FixValue(pointToStrValue.value), 
                Fields = {},
                pointToStr = Il2cpp.FixValue(address)
            }, {__index = StringApi})

        local pointClassAddressValue = gg.getValues({{address = str.address, flags = Il2cpp.MainType}})[1]
        if not pointClassAddressValue then return nil end -- Guard

        local stringInfoResults = Il2cpp.FindClass({{Class = Il2cpp.FixValue(pointClassAddressValue.value), FieldsDump = true}})
        if not stringInfoResults or not stringInfoResults[1] then return nil end

        local stringInfo = stringInfoResults[1]

        for i, v in ipairs(stringInfo) do
            if v.ClassNameSpace == "System" and v.ClassName == "String" then -- Be more specific
                str.ClassAddress = tonumber(v.ClassAddress, 16)
                if v.Fields then
                    for indexField, FieldInfo in ipairs(v.Fields) do
                        str.Fields[FieldInfo.FieldName] = tonumber(FieldInfo.Offset, 16)
                    end
                end
                -- Ensure essential fields are present
                if str.Fields._stringLength and str.Fields._firstChar then
                    return str
                else
                    -- String class found, but essential fields for manipulation are missing
                    -- This might indicate a different String structure or an issue with field dumping
                    return nil 
                end
            end
        end
        return nil -- System.String class not found or structure mismatch
    end,
    
}

return String
end)
__bundle_register("il2cppstruct.api.fieldinfo", function(require, _LOADED, __bundle_register, __bundle_modules)
local Il2cppMemory = require("utils.il2cppmemory")

---@type FieldInfo
local FieldInfoApi = {


    ---@param self FieldInfo
    ---@return nil | string | number
    GetConstValue = function(self)
        if self.IsConst then
            local fieldIndex = getmetatable(self).fieldIndex
            local defaultValue = Il2cppMemory:GetDefaultValue(fieldIndex)
            if not defaultValue then
                defaultValue = Il2cpp.GlobalMetadataApi:GetDefaultFieldValue(fieldIndex)
                Il2cppMemory:SetDefaultValue(fieldIndex, defaultValue)
            elseif defaultValue == "nil" then -- Check for the placeholder string
                return nil
            end
            return defaultValue
        end
        return nil
    end
}

return FieldInfoApi
end)
__bundle_register("utils.il2cppmemory", function(require, _LOADED, __bundle_register, __bundle_modules)
-- Memorizing Il2cpp Search Result
---@class Il2cppMemory
---@field Methods table<number | string, MethodMemory>
---@field Classes table<string | number, ClassMemory>
---@field Fields table<number | string, FieldInfo[] | ErrorSearch>
---@field Results table
---@field Types table<number, string>
---@field DefaultValues table<number, string | number>
---@field GetInformaionOfMethod fun(self : Il2cppMemory, searchParam : number | string) : MethodMemory | nil
---@field SetInformaionOfMethod fun(self : Il2cppMemory, searchParam : string | number, searchResult : MethodMemory) : void
---@field GetInformationOfClass fun(self : Il2cppMemory, searchParam : string | number) : ClassMemory | nil
---@field SetInformationOfClass fun(self : Il2cppMemory, searchParam : string | number, searchResult : ClassMemory) : void
---@field GetInformationOfField fun(self : Il2cppMemory, searchParam : number | string) : FieldInfo[] | nil | ErrorSearch
---@field SetInformationOfField fun(self : Il2cppMemory, searchParam : string | number, searchResult : FieldInfo[] | ErrorSearch) : void
---@field GetInformationOfType fun(self : Il2cppMemory, index : number) : string | nil
---@field SetInformationOfType fun(self : Il2cppMemory, index : number, typeName : string)
---@field SaveResults fun(self : Il2cppMemory) : void
---@field ClearSavedResults fun(self : Il2cppMemory) : void
local Il2cppMemory = {
    Methods = {},
    Classes = {},
    Fields = {},
    DefaultValues = {},
    Results = {},
    Types = {},


    ---@param self Il2cppMemory
    ---@return nil | string
    GetInformationOfType = function(self, index)
        return self.Types[index]
    end,


    ---@param self Il2cppMemory
    SetInformationOfType = function(self, index, typeName)
        self.Types[index] = typeName
    end,

    ---@param self Il2cppMemory
    SaveResults = function(self)
        if gg.getResultsCount() > 0 then
            self.Results = gg.getResults(gg.getResultsCount())
        end
    end,


    ---@param self Il2cppMemory
    ClearSavedResults = function(self)
        self.Results = {}
    end,


    ---@param self Il2cppMemory
    ---@param fieldIndex number
    ---@return string | number | nil
    GetDefaultValue = function(self, fieldIndex)
        return self.DefaultValues[fieldIndex]
    end,


    ---@param self Il2cppMemory
    ---@param fieldIndex number
    ---@param defaultValue number | string | nil
    SetDefaultValue = function(self, fieldIndex, defaultValue)
        self.DefaultValues[fieldIndex] = defaultValue or "nil" -- Store nil as a placeholder string
    end,


    ---@param self Il2cppMemory
    ---@param searchParam number | string
    ---@return FieldInfo[] | nil | ErrorSearch
    GetInformationOfField = function(self, searchParam)
        return self.Fields[searchParam]
    end,


    ---@param self Il2cppMemory
    ---@param searchParam number | string
    ---@param searchResult FieldInfo[] | ErrorSearch
    SetInformationOfField = function(self, searchParam, searchResult)
        if searchResult and not searchResult.Error then -- Check if searchResult is not nil
            self.Fields[searchParam] = searchResult
        end
    end,


    GetInformaionOfMethod = function(self, searchParam)
        return self.Methods[searchParam]
    end,


    SetInformaionOfMethod = function(self, searchParam, searchResult)
        if searchResult and not searchResult.Error then -- Check if searchResult is not nil
            self.Methods[searchParam] = searchResult
        end
    end,


    GetInformationOfClass = function(self, searchParam)
        return self.Classes[searchParam]
    end,


    SetInformationOfClass = function(self, searchParam, searchResult)
        if searchResult then -- Ensure searchResult is not nil
             self.Classes[searchParam] = searchResult
        end
    end,


    ---@param self Il2cppMemory
    ---@return void
    ClearMemorize = function(self)
        self.Methods = {}
        self.Classes = {}
        self.Fields = {}
        self.DefaultValues = {}
        self.Results = {}
        self.Types = {}
    end
}

return Il2cppMemory

end)
__bundle_register("il2cppstruct.api.classinfo", function(require, _LOADED, __bundle_register, __bundle_modules)
local ClassInfoApi = {

    
    ---Get FieldInfo by Field Name. If Field isn't found by name, then function will return `nil`
    ---@param self ClassInfo
    ---@param name string
    ---@return FieldInfo | nil
    GetFieldWithName = function(self, name)
        local FieldsInfo = self.Fields
        if FieldsInfo then
            for fieldIndex = 1, #FieldsInfo do
                if FieldsInfo[fieldIndex].FieldName == name then
                    return FieldsInfo[fieldIndex]
                end
            end
        else
            -- Fields were not dumped initially, attempt to dump them now.
            local ClassAddress = tonumber(self.ClassAddress, 16)
            if not ClassAddress then return nil end

            local classApiValues = gg.getValues({
                { -- Link as Fields
                    address = ClassAddress + Il2cpp.ClassApi.FieldsLink,
                    flags = Il2cpp.MainType
                },
                { -- Fields Count
                    address = ClassAddress + Il2cpp.ClassApi.CountFields,
                    flags = gg.TYPE_WORD -- Assuming WORD, adjust if DWORD or other
                }
            })
            if not classApiValues or not classApiValues[1] or not classApiValues[2] then return nil end

            local fieldsLink = Il2cpp.FixValue(classApiValues[1].value)
            local fieldsCount = classApiValues[2].value

            if fieldsCount > 0 and fieldsLink ~= 0 then
                 self.Fields = Il2cpp.ClassApi:GetClassFields(fieldsLink, fieldsCount, {
                    ClassName = self.ClassName,
                    IsEnum = self.IsEnum,
                    TypeMetadataHandle = self.TypeMetadataHandle
                })
                -- Retry after dumping
                if self.Fields then
                    return self:GetFieldWithName(name)
                end
            else
                self.Fields = {} -- No fields or link is null
            end
        end
        return nil
    end,


    ---Get MethodInfo[] by MethodName. If Method isn't found by name, then function will return `table with zero size`
    ---@param self ClassInfo
    ---@param name string
    ---@return MethodInfo[]
    GetMethodsWithName = function(self, name)
        local MethodsInfo, MethodsInfoResult = self.Methods, {}
        if MethodsInfo then
            for methodIndex = 1, #MethodsInfo do
                if MethodsInfo[methodIndex].MethodName == name then
                    MethodsInfoResult[#MethodsInfoResult + 1] = MethodsInfo[methodIndex]
                end
            end
            return MethodsInfoResult
        else
            -- Methods were not dumped initially, attempt to dump them now.
            local ClassAddress = tonumber(self.ClassAddress, 16)
            if not ClassAddress then return {} end

            local classApiValues = gg.getValues({
                { -- Link as Methods
                    address = ClassAddress + Il2cpp.ClassApi.MethodsLink,
                    flags = Il2cpp.MainType
                },
                { -- Methods Count
                    address = ClassAddress + Il2cpp.ClassApi.CountMethods,
                    flags = gg.TYPE_WORD -- Assuming WORD
                }
            })
            if not classApiValues or not classApiValues[1] or not classApiValues[2] then return {} end

            local methodsLink = Il2cpp.FixValue(classApiValues[1].value)
            local methodsCount = classApiValues[2].value
            
            if methodsCount > 0 and methodsLink ~= 0 then
                self.Methods = Il2cpp.ClassApi:GetClassMethods(methodsLink, methodsCount, self.ClassName)
                -- Retry after dumping
                if self.Methods then
                    return self:GetMethodsWithName(name)
                end
            else
                self.Methods = {} -- No methods or link is null
            end
            return {}
        end
    end,


    ---@param self ClassInfo
    ---@param fieldOffset number
    ---@return nil | FieldInfo
    GetFieldWithOffset = function(self, fieldOffset)
        if not self.Fields then
            local ClassAddress = tonumber(self.ClassAddress, 16)
            if not ClassAddress then return nil end

            local _ClassInfoValues = gg.getValues({
                { -- Link as Fields
                    address = ClassAddress + Il2cpp.ClassApi.FieldsLink,
                    flags = Il2cpp.MainType
                },
                { -- Fields Count
                    address = ClassAddress + Il2cpp.ClassApi.CountFields,
                    flags = gg.TYPE_WORD
                }
            })
            if not _ClassInfoValues or not _ClassInfoValues[1] or not _ClassInfoValues[2] then return nil end
            
            local fieldsLink = Il2cpp.FixValue(_ClassInfoValues[1].value)
            local fieldsCount = _ClassInfoValues[2].value

            if fieldsCount > 0 and fieldsLink ~= 0 then
                 self.Fields = Il2cpp.ClassApi:GetClassFields(fieldsLink, fieldsCount, {
                    ClassName = self.ClassName,
                    IsEnum = self.IsEnum,
                    TypeMetadataHandle = self.TypeMetadataHandle
                })
            else
                self.Fields = {}
            end
        end

        if self.Fields and #self.Fields > 0 then
            local klass = self
            while klass ~= nil do
                if klass.Fields and klass.InstanceSize >= fieldOffset then
                    local lastField = nil
                    for indexField, field in ipairs(klass.Fields) do
                        if not (field.IsStatic or field.IsConst) then
                            local offset = tonumber(field.Offset, 16)
                            if offset then -- Ensure offset is a valid number
                                if offset > 0 then 
                                    local maybeStruct = fieldOffset < offset

                                    if indexField == 1 and maybeStruct then
                                        break -- Offset is before the first field
                                    elseif offset == fieldOffset then
                                        return field
                                    elseif indexField == #klass.Fields and offset < fieldOffset then 
                                        -- Last field and offset is still smaller, could be this one if it spans
                                        return field 
                                    elseif maybeStruct then
                                        return lastField -- Previous field was the one
                                    end
                                    lastField = field
                                end
                            end
                        end
                    end
                     if lastField and tonumber(lastField.Offset, 16) <= fieldOffset and fieldOffset < klass.InstanceSize then
                        return lastField -- If loop finished, and lastField is valid for the offset
                    end
                end
                -- Traverse to parent
                if klass.Parent and klass.Parent.ClassAddress then
                    local parentClassResults = Il2cpp.FindClass({{Class = tonumber(klass.Parent.ClassAddress, 16), FieldsDump = true}})
                    if parentClassResults and parentClassResults[1] and #parentClassResults[1] > 0 then
                        klass = parentClassResults[1][1]
                    else
                        klass = nil -- Parent not found or error
                    end
                else
                    klass = nil -- No parent
                end
            end
        end
        return nil
    end
}

return ClassInfoApi
end)
__bundle_register("il2cppstruct.object", function(require, _LOADED, __bundle_register, __bundle_modules)
local AndroidInfo = require("utils.androidinfo")

---@class ObjectApi
local ObjectApi = {


    ---@param self ObjectApi
    ---@param Objects table
    FilterObjects = function(self, Objects)
        local FilterObjects = {}
        -- Ensure Objects is a table of tables with 'address' and 'flags'
        if type(Objects) ~= "table" then return {} end

        local valuesToGet = {}
        for k, v in ipairs(Objects) do
            if type(v) == "table" and v.address and v.flags then
                 table.insert(valuesToGet, {address = v.address, flags = v.flags})
            end
        end
        if #valuesToGet == 0 then return {} end

        local ranges = gg.getValuesRange(valuesToGet) -- Check ranges for these specific addresses
        
        for k, v_range in ipairs(ranges) do
            -- Assuming 'A' means the memory is accessible/valid. This might need adjustment.
            if v_range == 'A' then 
                FilterObjects[#FilterObjects + 1] = Objects[k]
            end
        end
        
        if #FilterObjects == 0 then return {} end

        gg.loadResults(FilterObjects)
        gg.searchPointer(0) -- Search for pointers TO these objects
        
        local resultsCount = gg.getResultsCount()
        if resultsCount <= 0 then
            if AndroidInfo.platform and AndroidInfo.sdk >= 30 then
                -- This part is specific and might need careful testing.
                -- It attempts to find tagged pointers.
                local FixRefToObjects = {}
                for k, v_obj in ipairs(FilterObjects) do
                    gg.searchNumber(tostring(v_obj.address | 0xB400000000000000), gg.TYPE_QWORD)
                    local RefToObject = gg.getResults(gg.getResultsCount())
                    table.move(RefToObject, 1, #RefToObject, #FixRefToObjects + 1, FixRefToObjects)
                    gg.clearResults()
                end
                if #FixRefToObjects == 0 then return {} end
                gg.loadResults(FixRefToObjects)
            else
                gg.clearResults()
                return {} -- No pointers found
            end
        end

        local RefToObjects = gg.getResults(gg.getResultsCount())
        gg.clearResults()
        local FinalFilteredObjects = {}

        -- Filter again based on the pointers found
        local valuesToGetForRefs = {}
        for k,v_ref in ipairs(RefToObjects) do
            table.insert(valuesToGetForRefs, {address = v_ref.address, flags = v_ref.flags})
        end
        if #valuesToGetForRefs == 0 then return {} end

        local ref_ranges = gg.getValuesRange(valuesToGetForRefs)

        for k, v_range in ipairs(ref_ranges) do
            if v_range == 'A' then -- Assuming 'A' means accessible
                -- The value at RefToObjects[k].address should be the object's address
                local objectAddress = gg.getValues({ {address = RefToObjects[k].address, flags = RefToObjects[k].flags} })[1].value
                FinalFilteredObjects[#FinalFilteredObjects + 1] = {
                    address = Il2cpp.FixValue(objectAddress), -- The actual object address
                    flags = Il2cpp.MainType -- Assuming the object itself is a pointer type
                }
            end
        end
        
        if #FinalFilteredObjects == 0 then return {} end
        
        gg.loadResults(FinalFilteredObjects)
        local _FilterObjects = gg.getResults(gg.getResultsCount()) -- Final check on these objects
        gg.clearResults()
        return _FilterObjects
    end,


    ---@param self ObjectApi
    ---@param ClassAddress string
    FindObjects = function(self, ClassAddress)
        gg.clearResults()
        gg.setRanges(gg.REGION_C_HEAP | gg.REGION_ANONYMOUS | gg.REGION_C_BSS | gg.REGION_C_DATA | gg.REGION_C_ALLOC)
        
        local classAddrNum = tonumber(ClassAddress, 16)
        if not classAddrNum then return {} end

        gg.searchNumber(string.format("%Xh", classAddrNum), Il2cpp.MainType) -- Search for the class pointer itself

        local resultsCount = gg.getResultsCount()
        if resultsCount <= 0 then
            if AndroidInfo.platform and AndroidInfo.sdk >= 30 then
                -- Search for tagged pointer to the class
                gg.searchNumber(tostring(classAddrNum | 0xB400000000000000), gg.TYPE_QWORD)
                if gg.getResultsCount() == 0 then 
                    gg.clearResults()
                    return {} 
                end
            else
                gg.clearResults()
                return {}
            end
        end
        
        local FindsResult = gg.getResults(gg.getResultsCount())
        gg.clearResults()
        -- FindsResult now contains addresses of memory locations that hold the class pointer (or tagged class pointer).
        -- These are the headers of the objects.
        return self:FilterObjects(FindsResult) -- Filter to ensure these are valid object headers
    end,

    
    ---@param self ObjectApi
    ---@param ClassesInfo ClassInfo[] | ErrorSearch
    Find = function(self, ClassesInfo)
        local Objects = {}
        if not ClassesInfo or ClassesInfo.Error or type(ClassesInfo) ~= "table" then 
            return Objects 
        end

        for j = 1, #ClassesInfo do
            if ClassesInfo[j] and ClassesInfo[j].ClassAddress then
                local FindResult = self:FindObjects(ClassesInfo[j].ClassAddress)
                if FindResult and #FindResult > 0 then
                    table.move(FindResult, 1, #FindResult, #Objects + 1, Objects)
                end
            end
        end
        return Objects
    end,


    FindHead = function(Address)
        local validAddress = Il2cpp.GetValidAddress(Address) -- Ensure address is aligned for reads
        local mayBeHeadCandidates = {}
        -- Search backwards from the given address to find a potential object header.
        -- Limit the search range to avoid excessive reads.
        for i = 1, 250 do -- Reduced from 1000 for performance, adjust as needed
            mayBeHeadCandidates[i] = {
                address = validAddress - (Il2cpp.pointSize * (i - 1)), -- Step back by pointer size
                flags = Il2cpp.MainType
            } 
        end
        
        local potentialHeads = gg.getValues(mayBeHeadCandidates)
        if not potentialHeads then return {value = 0, address = 0} end

        for i = 1, #potentialHeads do
            local potentialClassPtr = Il2cpp.FixValue(potentialHeads[i].value)
            if potentialClassPtr ~= 0 then
                -- IsClassInfo checks if the value points to a valid class structure
                if Il2cpp.ClassApi.IsClassInfo(potentialClassPtr) then
                    -- Found a likely object header. The address of this header is mayBeHeadCandidates[i].address
                    return {value = potentialClassPtr, address = mayBeHeadCandidates[i].address} 
                end
            end
        end
        return {value = 0, address = 0} -- No valid head found
    end,
}

return ObjectApi
end)
__bundle_register("utils.androidinfo", function(require, _LOADED, __bundle_register, __bundle_modules)
local targetInfo = gg.getTargetInfo()
local AndroidInfo = {
    platform = targetInfo and targetInfo.x64, -- true for 64-bit, false for 32-bit, nil if getTargetInfo fails
    sdk = targetInfo and targetInfo.targetSdkVersion
}

return AndroidInfo
end)
__bundle_register("il2cppstruct.class", function(require, _LOADED, __bundle_register, __bundle_modules)
local Protect = require("utils.protect")
local StringUtils = require("utils.stringutils")
local Il2cppMemory = require("utils.il2cppmemory")

---@class ClassApi
---@field NameOffset number
---@field MethodsStep number
---@field CountMethods number
---@field MethodsLink number
---@field FieldsLink number
---@field FieldsStep number
---@field CountFields number
---@field ParentOffset number
---@field NameSpaceOffset number
---@field StaticFieldDataOffset number
---@field EnumType number
---@field EnumRsh number
---@field TypeMetadataHandle number
---@field InstanceSize number
---@field Token number
---@field GetClassName fun(self : ClassApi, ClassAddress : number) : string
---@field GetClassMethods fun(self : ClassApi, MethodsLink : number, Count : number, ClassName : string | nil) : MethodInfo[]
local ClassApi = {
    
    
    ---@param self ClassApi
    ---@param ClassAddress number
    GetClassName = function(self, ClassAddress)
        local namePtrValue = gg.getValues({{
            address = Il2cpp.FixValue(ClassAddress) + self.NameOffset,
            flags = Il2cpp.MainType
        }})[1]
        if not namePtrValue then return "" end
        return Il2cpp.Utf8ToString(Il2cpp.FixValue(namePtrValue.value))
    end,
    
    
    ---@param self ClassApi
    ---@param MethodsLink number
    ---@param Count number
    ---@param ClassName string | nil
    GetClassMethods = function(self, MethodsLink, Count, ClassName)
        local MethodsInfoResult, MethodInfoAddresses = {}, {}
        if Count == 0 or MethodsLink == 0 then return {} end

        for i = 0, Count - 1 do
            MethodInfoAddresses[#MethodInfoAddresses + 1] = {
                address = MethodsLink + (i << self.MethodsStep), -- Step is power of 2 for bit shift
                flags = Il2cpp.MainType
            }
        end
        
        local methodPtrs = gg.getValues(MethodInfoAddresses)
        if not methodPtrs then return {} end

        local batchUnpackInfo = {} -- For batching gg.getValues calls later

        for i = 1, #methodPtrs do
            if methodPtrs[i] and methodPtrs[i].value ~= 0 then
                local MethodInfoAddress = Il2cpp.FixValue(methodPtrs[i].value)
                local unpackData, methodRawInfo = Il2cpp.MethodsApi:UnpackMethodInfo({
                    MethodInfoAddress = MethodInfoAddress,
                    ClassName = ClassName -- Pass ClassName for context if available
                })
                -- Accumulate data for batch gg.getValues
                for _, item in ipairs(unpackData) do
                    table.insert(batchUnpackInfo, item)
                end
                -- Store the raw info temporarily, will be populated by DecodeMethodsInfo
                MethodsInfoResult[#MethodsInfoResult + 1] = methodRawInfo 
            end
        end
        
        if #batchUnpackInfo == 0 then return {} end
        local decodedValues = gg.getValues(batchUnpackInfo)
        if not decodedValues then return {} end

        Il2cpp.MethodsApi:DecodeMethodsInfo(MethodsInfoResult, decodedValues) -- Pass the array of raw method infos and the batch decoded values
        return MethodsInfoResult
    end,


    GetClassFields = function(self, FieldsLink, Count, ClassCharacteristic)
        local FieldsInfoResult, FieldInfoAddresses = {}, {}
        if Count == 0 or FieldsLink == 0 then return {} end

        for i = 0, Count - 1 do
            FieldInfoAddresses[#FieldInfoAddresses + 1] = {
                address = FieldsLink + (i * self.FieldsStep), -- Step might not be power of 2
                flags = Il2cpp.MainType
            }
        end

        local fieldPtrs = gg.getValues(FieldInfoAddresses)
        if not fieldPtrs then return {} end
        
        local batchUnpackInfo = {}
        local tempFieldInfos = {} -- To hold intermediate structures before final decoding

        for i = 1, #fieldPtrs do
            if fieldPtrs[i] and fieldPtrs[i].value ~= 0 then
                local FieldInfoAddress = Il2cpp.FixValue(fieldPtrs[i].value)
                local unpackData = Il2cpp.FieldApi:UnpackFieldInfo(FieldInfoAddress)
                -- Accumulate data for batch gg.getValues
                for _, item in ipairs(unpackData) do
                    table.insert(batchUnpackInfo, item)
                end
                -- Store a reference or index for DecodeFieldsInfo to match later
                table.insert(tempFieldInfos, { originalAddress = FieldInfoAddress })
            end
        end

        if #batchUnpackInfo == 0 then return {} end
        local decodedValues = gg.getValues(batchUnpackInfo)
        if not decodedValues then return {} end

        FieldsInfoResult = Il2cpp.FieldApi:DecodeFieldsInfo(decodedValues, ClassCharacteristic, tempFieldInfos) -- Pass decoded values and class characteristics
        return FieldsInfoResult
    end,


    ---@param self ClassApi
    ---@param ClassInfoRaw ClassInfoRaw
    ---@param Config table
    ---@return ClassInfo
    UnpackClassInfo = function(self, ClassInfoRawItem, Config) -- Renamed ClassInfo to ClassInfoRawItem
        local _ClassInfoValues = gg.getValues({
            { -- Class Name [1]
                address = ClassInfoRawItem.ClassInfoAddress + self.NameOffset,
                flags = Il2cpp.MainType
            },
            { -- Methods Count [2]
                address = ClassInfoRawItem.ClassInfoAddress + self.CountMethods,
                flags = gg.TYPE_WORD
            },
            { -- Fields Count [3]
                address = ClassInfoRawItem.ClassInfoAddress + self.CountFields,
                flags = gg.TYPE_WORD
            },
            { -- Link as Methods [4]
                address = ClassInfoRawItem.ClassInfoAddress + self.MethodsLink,
                flags = Il2cpp.MainType
            },
            { -- Link as Fields [5]
                address = ClassInfoRawItem.ClassInfoAddress + self.FieldsLink,
                flags = Il2cpp.MainType
            },
            { -- Link as Parent Class [6]
                address = ClassInfoRawItem.ClassInfoAddress + self.ParentOffset,
                flags = Il2cpp.MainType
            },
            { -- Class NameSpace [7]
                address = ClassInfoRawItem.ClassInfoAddress + self.NameSpaceOffset,
                flags = Il2cpp.MainType
            },
            { -- Class Static Field Data [8]
                address = ClassInfoRawItem.ClassInfoAddress + self.StaticFieldDataOffset,
                flags = Il2cpp.MainType
            },
            { -- EnumType [9]
                address = ClassInfoRawItem.ClassInfoAddress + self.EnumType,
                flags = gg.TYPE_BYTE
            },
            { -- TypeMetadataHandle [10]
                address = ClassInfoRawItem.ClassInfoAddress + self.TypeMetadataHandle,
                flags = Il2cpp.MainType -- Was MainType, ensure it's correct for handle
            },
            { -- InstanceSize [11]
                address = ClassInfoRawItem.ClassInfoAddress + self.InstanceSize,
                flags = gg.TYPE_DWORD
            },
            { -- Token [12]
                address = ClassInfoRawItem.ClassInfoAddress + self.Token,
                flags = gg.TYPE_DWORD
            }
        })
        if not _ClassInfoValues or not _ClassInfoValues[1] then return nil end -- Basic check

        local ClassName = ClassInfoRawItem.ClassName or Il2cpp.Utf8ToString(Il2cpp.FixValue(_ClassInfoValues[1].value))
        local ClassCharacteristic = {
            ClassName = ClassName,
            IsEnum = ((_ClassInfoValues[9].value >> self.EnumRsh) & 1) == 1,
            TypeMetadataHandle = Il2cpp.FixValue(_ClassInfoValues[10].value)
        }
        
        local methods = nil
        if _ClassInfoValues[2].value > 0 and Config.MethodsDump and _ClassInfoValues[4].value ~= 0 then
            methods = self:GetClassMethods(Il2cpp.FixValue(_ClassInfoValues[4].value), _ClassInfoValues[2].value, ClassName)
        end

        local fields = nil
        if _ClassInfoValues[3].value > 0 and Config.FieldsDump and _ClassInfoValues[5].value ~= 0 then
            fields = self:GetClassFields(Il2cpp.FixValue(_ClassInfoValues[5].value), _ClassInfoValues[3].value, ClassCharacteristic)
        end
        
        local parent = nil
        if _ClassInfoValues[6].value ~= 0 then
            parent = {
                ClassAddress = string.format('%X', Il2cpp.FixValue(_ClassInfoValues[6].value)),
                ClassName = self:GetClassName(Il2cpp.FixValue(_ClassInfoValues[6].value)) -- FixValue for parent address
            }
        end

        return setmetatable({
            ClassName = ClassName,
            ClassAddress = string.format('%X', Il2cpp.FixValue(ClassInfoRawItem.ClassInfoAddress)),
            Methods = methods,
            Fields = fields,
            Parent = parent,
            ClassNameSpace = Il2cpp.Utf8ToString(Il2cpp.FixValue(_ClassInfoValues[7].value)),
            StaticFieldData = _ClassInfoValues[8].value ~= 0 and Il2cpp.FixValue(_ClassInfoValues[8].value) or nil,
            IsEnum = ClassCharacteristic.IsEnum,
            TypeMetadataHandle = ClassCharacteristic.TypeMetadataHandle,
            InstanceSize = _ClassInfoValues[11].value,
            Token = string.format("0x%X", _ClassInfoValues[12].value),
            ImageName = ClassInfoRawItem.ImageName
        }, {
            __index = Il2cpp.ClassInfoApi,
            __tostring = StringUtils.ClassInfoToDumpCS
        })
    end,

    --- Defines not quite accurately, especially in the 29th version of the backend
    ---@param Address number
    IsClassInfo = function(Address)
        if Address == 0 then return nil end
        local imagePtrValue = gg.getValues({{address = Il2cpp.FixValue(Address), flags = Il2cpp.MainType}})[1]
        if not imagePtrValue or imagePtrValue.value == 0 then return nil end
        
        local imageAddress = Il2cpp.FixValue(imagePtrValue.value)
        if imageAddress == 0 then return nil end

        local imageNamePtrValue = gg.getValues({{address = imageAddress, flags = Il2cpp.MainType}})[1]
        if not imageNamePtrValue or imageNamePtrValue.value == 0 then return nil end

        local imageStr = Il2cpp.Utf8ToString(Il2cpp.FixValue(imageNamePtrValue.value))
        
        -- Check if the string looks like a DLL name or a generated name
        local check = string.find(imageStr, "%.dll$") or string.find(imageStr, "__Generated") -- Added $ for .dll
        return check and imageStr or nil
    end,


    ---@param self ClassApi
    ---@param ClassName string
    ---@param searchResult ClassMemory
    FindClassWithName = function(self, ClassName, searchResult)
        local ClassNamePoint = Il2cpp.GlobalMetadataApi.GetPointersToString(ClassName) -- This returns pointers to the string in metadata
        local ResultTable = {}
        
        -- Only search if we haven't found enough or it's a new search for this ClassName
        if #ClassNamePoint > searchResult.len or searchResult.isNew then -- isNew should be set by caller
            for classPointIndex, namePointerInfo in ipairs(ClassNamePoint) do
                -- The namePointerInfo.address is the address of the string "ClassName" in metadata.
                -- We need to find Il2CppClass structures that have a pointer to this string at their NameOffset.
                -- This requires searching memory for pointers to namePointerInfo.address - self.NameOffset.
                -- This is a reverse lookup and can be slow.
                -- A more common approach is to iterate Il2CppClass instances and check their names.
                -- However, sticking to the original logic:
                
                -- The original logic implies classPoint.address IS the Il2CppClass->name pointer.
                -- So, Il2CppClass address would be classPoint.address - self.NameOffset
                local potentialClassAddress = namePointerInfo.address - self.NameOffset 
                                                -- This assumes namePointerInfo.address is the direct pointer from Il2CppClass->name
                                                -- This is unlikely; GetPointersToString finds the string literal.
                                                -- This part of the logic might be flawed if GetPointersToString returns string literals.

                -- Let's assume GetPointersToString finds pointers *within Il2CppClass structures* that point to the name string.
                -- If so, namePointerInfo.address is Il2CppClass->name field's address.
                -- Then potentialClassAddress = namePointerInfo.address - self.NameOffset.
                
                -- A more robust way if GetPointersToString gives string literals:
                -- 1. Get string literal address for ClassName.
                -- 2. Scan memory for Il2CppClass structures.
                -- 3. For each Il2CppClass, read its name pointer, dereference it, and compare with ClassName.
                -- This is too slow.

                -- Reinterpreting the original: it seems to assume GetPointersToString gives pointers *from* Il2CppClass.name *to* the string.
                -- So, `namePointerInfo.address` is `Il2CppClass + NameOffset`.
                local classAddress = potentialClassAddress -- This is `namePointerInfo.address - self.NameOffset`
                                       -- This should be the start of the Il2CppClass structure.

                local imageName = self.IsClassInfo(classAddress) -- Check if this is a valid class
                if (imageName) then
                    ResultTable[#ResultTable + 1] = {
                        ClassInfoAddress = Il2cpp.FixValue(classAddress),
                        ClassName = ClassName, -- We searched for this name
                        ImageName = imageName
                    }
                end
            end
            searchResult.len = #ClassNamePoint -- Update based on how many pointers to the string were found.
                                            -- This might not be the count of classes found.
        else
            searchResult.isNew = false
        end
        if #ResultTable == 0 then
             return { Error = string.format("The '%s' class is not initialized or found with current logic", ClassName) }
        end
        return ResultTable
    end,


    ---@param self ClassApi
    ---@param ClassAddress number
    ---@param searchResult ClassMemory
    ---@return ClassInfoRaw[] | ErrorSearch
    FindClassWithAddressInMemory = function(self, ClassAddress, searchResult)
        local ResultTable = {}
        if searchResult.len < 1 or searchResult.isNew then -- Check if new or not already processed
            local imageName = self.IsClassInfo(ClassAddress)
            if imageName then
                ResultTable[#ResultTable + 1] = {
                    ClassInfoAddress = ClassAddress, -- Already fixed by caller if needed
                    ImageName = imageName
                    -- ClassName will be resolved by UnpackClassInfo
                }
            end
            searchResult.len = #ResultTable -- Number of items found for this address
        else
            searchResult.isNew = false
        end
        if #ResultTable == 0 then
             return { Error = string.format("nothing was found or validated for this address 0x%X", ClassAddress) }
        end
        return ResultTable
    end,


    FindParamsCheck = {
        ---@param self ClassApi
        ---@param _class number @Class Address In Memory
        ---@param searchResult ClassMemory
        ['number'] = function(self, _class, searchResult)
            return Protect:Call(self.FindClassWithAddressInMemory, self, Il2cpp.FixValue(_class), searchResult) -- FixValue here
        end,
        ---@param self ClassApi
        ---@param _class string @Class Name
        ---@param searchResult ClassMemory
        ['string'] = function(self, _class, searchResult)
            return Protect:Call(self.FindClassWithName, self, _class, searchResult)
        end,
        ['default'] = function()
            return {
                Error = 'Invalid search criteria type'
            }
        end
    },


    ---@param self ClassApi
    ---@param classConfig ClassConfig -- Renamed from class to classConfig to avoid conflict
    ---@return ClassInfo[] | ErrorSearch
    Find = function(self, classConfig)
        local searchKey = classConfig.Class -- string or number
        local cachedResult = Il2cppMemory:GetInformationOfClass(searchKey)
        
        local performSearch = true
        if cachedResult then
            -- If cached, check if dump flags match. If not, re-search.
            if (classConfig.FieldsDump == cachedResult.config.FieldsDump) and 
               (classConfig.MethodsDump == cachedResult.config.MethodsDump) then
                performSearch = false
            end
        end

        if performSearch then
            local searchResultState = {len = 0, isNew = true} -- State for the search functions
            
            ---@type ClassInfoRaw[] | ErrorSearch
            local classInfoRawList =
                (self.FindParamsCheck[type(searchKey)] or self.FindParamsCheck['default'])(self, searchKey, searchResultState)

            if classInfoRawList.Error then
                return classInfoRawList -- Return error object
            end
            
            if not classInfoRawList or #classInfoRawList == 0 then
                 -- If FindClassWithName/Address returns an error table, it's handled above.
                 -- If it returns an empty table, it means nothing found.
                Il2cppMemory:SetInformationOfClass(searchKey, {
                    config = classConfig, 
                    result = { Error = "Class not found: " .. tostring(searchKey) }, 
                    len = 0, 
                    isNew = true 
                })
                return { Error = "Class not found: " .. tostring(searchKey) }
            end

            local unpackedClassInfos = {}
            for k = 1, #classInfoRawList do
                local unpacked = self:UnpackClassInfo(classInfoRawList[k], {
                    FieldsDump = classConfig.FieldsDump,
                    MethodsDump = classConfig.MethodsDump
                })
                if unpacked then table.insert(unpackedClassInfos, unpacked) end
            end
            
            local newCacheEntry = {
                config = classConfig,
                result = unpackedClassInfos,
                len = #unpackedClassInfos, -- Based on successfully unpacked items
                isNew = true -- Marking that this cache entry was newly created/updated
            }
            Il2cppMemory:SetInformationOfClass(searchKey, newCacheEntry)
            return unpackedClassInfos
        else
            -- Return from cache
            return cachedResult.result
        end
    end
}

return ClassApi
end)
__bundle_register("utils.stringutils", function(require, _LOADED, __bundle_register, __bundle_modules)
---@class StringUtils
local StringUtils = {

    ---@param classInfo ClassInfo
    ClassInfoToDumpCS = function(classInfo)
        if not classInfo or type(classInfo) ~= "table" then return "-- Invalid ClassInfo provided to ClassInfoToDumpCS" end

        local dumpClass = {}
        table.insert(dumpClass, "// ImageName: " .. (classInfo.ImageName or "Unknown Image") .. "\n")
        table.insert(dumpClass, "// Namespace: " .. (classInfo.ClassNameSpace or "") .. "\n")
        
        local parentString = ""
        if classInfo.Parent and classInfo.Parent.ClassName then
            parentString = " : " .. classInfo.Parent.ClassName
        end
        table.insert(dumpClass, "public class " .. (classInfo.ClassName or "UnknownClass") .. parentString .. "\n{\n")

        if classInfo.Fields and #classInfo.Fields > 0 then
            table.insert(dumpClass, "\n    // Fields\n")
            for i, v in ipairs(classInfo.Fields) do
                if v and type(v) == "table" then
                    local staticStr = v.IsStatic and "static " or ""
                    local constStr = v.IsConst and "const " or ""
                    local accessStr = v.Access or "public" -- Default to public if not specified
                    local typeStr = v.Type or "UnknownType"
                    local nameStr = v.FieldName or ("field_"..i)
                    local offsetStr = v.Offset or "0x0"
                    table.insert(dumpClass, string.format("    %s %s%s%s %s; // 0x%s\n", accessStr, staticStr, constStr, typeStr, nameStr, offsetStr))
                end
            end
        end

        if classInfo.Methods and #classInfo.Methods > 0 then
            table.insert(dumpClass, "\n    // Methods\n")
            for i, v in ipairs(classInfo.Methods) do
                 if v and type(v) == "table" then
                    if i > 1 then table.insert(dumpClass, "\n") end
                    local offsetHex = v.Offset or "0"
                    local vaHex = v.AddressInMemory or "0"
                    local paramCount = v.ParamCount or 0
                    table.insert(dumpClass, string.format("    // Offset: 0x%s VA: 0x%s ParamCount: %d\n", offsetHex, vaHex, paramCount))
                    
                    local accessStr = v.Access or "public"
                    local staticStr = v.IsStatic and "static " or ""
                    local abstractStr = v.IsAbstract and "abstract " or ""
                    local returnTypeStr = v.ReturnType or "void"
                    local methodNameStr = v.MethodName or ("method_"..i)
                    -- Basic parameter list - for a full dump, parameter types would be needed
                    local paramsStr = "()" -- Simplified
                    if v.ParamCount and v.ParamCount > 0 then
                        local p = {}
                        for pi=1, v.ParamCount do table.insert(p, "arg" .. pi) end
                        paramsStr = "(" .. table.concat(p, ", ") .. ")"
                    end

                    table.insert(dumpClass, string.format("    %s %s%s%s %s%s { /* Implementation not extracted */ } \n", accessStr, staticStr, abstractStr, returnTypeStr, methodNameStr, paramsStr))
                end
            end
        end
        
        table.insert(dumpClass, "\n}\n")
        return table.concat(dumpClass)
    end
}

return StringUtils
end)
__bundle_register("utils.protect", function(require, _LOADED, __bundle_register, __bundle_modules)
local Protect = {
    ErrorHandler = function(err)
        -- Instead of just returning {Error = err}, format it or log it
        local err_msg = "Error: "
        if type(err) == "string" then
            err_msg = err_msg .. err
        elseif type(err) == "table" and err.message then -- Lua 5.1 error object
            err_msg = err_msg .. err.message
        else
            err_msg = err_msg .. tostring(err)
        end
        -- Optionally, print the error here for debugging if gg.print is available
        -- gg.print(err_msg) 
        return {Error = err_msg} 
    end,
    Call = function(self, fun, ...) 
        -- Ensure 'self' is passed correctly if 'fun' is a method
        local status, result = xpcall(function() return fun(self, ...) end, self.ErrorHandler)
        if not status then
            -- ErrorHandler should have returned a table with an Error field.
            -- If xpcall itself failed or ErrorHandler didn't return the expected format:
            if type(result) ~= "table" or not result.Error then
                return {Error = "Unknown error in Protect:Call or ErrorHandler failed: " .. tostring(result)}
            end
        end
        return result -- This will be the return from 'fun' or the {Error=...} table from ErrorHandler
    end
}

return Protect
end)
__bundle_register("il2cppstruct.field", function(require, _LOADED, __bundle_register, __bundle_modules)
local Protect = require("utils.protect")

---@class FieldApi
---@field Offset number
---@field Type number
---@field ClassOffset number
---@field Find fun(self : FieldApi, fieldSearchCondition : string | number) : FieldInfo[] | ErrorSearch
local FieldApi = {


    ---@param self FieldApi
    ---@param FieldInfoAddress number
    UnpackFieldInfo = function(self, FieldInfoAddress)
        -- This function returns a table of tables, intended for gg.getValues
        return {
            { -- Field Name Pointer [0]
                address = FieldInfoAddress, -- This is Il2CppFieldDefinition->nameIndex, not a pointer directly
                flags = gg.TYPE_DWORD -- Assuming nameIndex is a DWORD index into string literal table
            }, 
            { -- Offset Field [1] (Il2CppFieldDefinition->offset)
                address = FieldInfoAddress + self.Offset, -- self.Offset is offset of 'offset' field in Il2CppFieldDefinition
                flags = gg.TYPE_DWORD -- Field offset is usually an int (DWORD)
            }, 
            { -- Field type index [2] (Il2CppFieldDefinition->typeIndex)
                address = FieldInfoAddress + self.Type, -- self.Type is offset of 'typeIndex' field
                flags = gg.TYPE_DWORD -- typeIndex is an index
            }, 
            { -- Token [3] (Il2CppFieldDefinition->token) - ClassOffset was likely a misnomer for token or similar
                address = FieldInfoAddress + self.ClassOffset, -- self.ClassOffset is offset of 'token'
                flags = gg.TYPE_DWORD 
            }
            -- Note: The actual class owning this field isn't directly part of Il2CppFieldDefinition usually.
            -- It's known by context (from Il2CppClass->fields which points to an array of these).
        }
    end,


    ---@param self FieldApi
    ---@param DecodedValuesBatch table -- Batch of values from gg.getValues, corresponding to multiple fields
    ---@param ClassCharacteristic table -- { ClassName, IsEnum, TypeMetadataHandle }
    ---@param TempFieldInfos table -- Optional: if needed to correlate back, e.g. { {originalAddress = ...}, ...}
    ---@return FieldInfo[]
    DecodeFieldsInfo = function(self, DecodedValuesBatch, ClassCharacteristic, TempFieldInfos)
        local _FieldsInfoResult = {}
        local fieldDefValueIndex = 0 -- To keep track of field's definition index for default values

        -- Assuming DecodedValuesBatch is flat array: [nameIdx1, offset1, typeIdx1, token1, nameIdx2, offset2, ...]
        for i = 1, #DecodedValuesBatch, 4 do -- Process 4 values per field
            local nameIndex = DecodedValuesBatch[i].value
            local fieldOffset = DecodedValuesBatch[i + 1].value
            local typeIndex = DecodedValuesBatch[i + 2].value
            local token = DecodedValuesBatch[i + 3].value -- This is field's token, not class address

            -- Get field name from metadata string literal table using nameIndex
            local fieldName = Il2cpp.GlobalMetadataApi:GetStringFromIndex(nameIndex)

            -- Get type information using typeIndex
            local il2cppTypePtr = Il2cpp.MetadataRegistrationApi:GetIl2CppTypeFromIndex(typeIndex)
            if not il2cppTypePtr or il2cppTypePtr == 0 then 
                -- gg.print("Warning: Could not get Il2CppType for typeIndex: " .. typeIndex)
                goto continue_loop -- Skip this field if type info is bad
            end

            local typeInfoValues = gg.getValues({
                { -- attrs (Il2CppType->attrs)
                    address = il2cppTypePtr + Il2cpp.TypeApi.Type, -- This is Il2CppType->attrs offset in Il2CppType struct
                                                                 -- Il2cpp.TypeApi.Type was likely misnamed, should be AttrsOffset or similar
                    flags = gg.TYPE_WORD
                }, 
                { -- type enum (Il2CppType->type)
                    address = il2cppTypePtr, -- This is Il2CppType->type (enum) offset in Il2CppType struct
                                             -- Assuming Il2CppType starts with the data pointer or type enum
                    flags = gg.TYPE_BYTE -- The type enum itself
                }, 
                { -- data (Il2CppType->data, which could be klassIndex or type for generics etc.)
                    -- This needs to be interpreted based on type enum.
                    -- For basic types, it's not directly used for name. For VALUETYPE/CLASS, it's klassIndex.
                    address = il2cppTypePtr + (Il2cpp.AndroidInfo.platform and 0x8 or 0x4), -- Offset of Il2CppType->data union
                    flags = Il2cpp.MainType 
                }
            })

            if not typeInfoValues or not typeInfoValues[1] then 
                -- gg.print("Warning: Could not get type attributes for typeIndex: " .. typeIndex)
                goto continue_loop 
            end
            
            local attrs = typeInfoValues[1].value
            local typeEnum = typeInfoValues[2].value
            local typeData = typeInfoValues[3].value -- klassIndex or other data based on typeEnum

            local typeName = Il2cpp.TypeApi:GetTypeName(typeEnum, typeData, il2cppTypePtr) -- Pass full type Ptr for complex cases

            local IsConst = (attrs & Il2CppFlags.Field.FIELD_ATTRIBUTE_LITERAL) ~= 0
            local IsStatic = (not IsConst) and ((attrs & Il2CppFlags.Field.FIELD_ATTRIBUTE_STATIC) ~= 0)
            
            -- Determine the field's definition index for default value lookup
            -- This requires knowing the starting field index for the class within the global list of field definitions.
            -- This information (fieldStartIndexInAllDefs) isn't directly available here.
            -- The original code used `fieldStart + index - 1`. `fieldStart` came from Il2CppTypeDefinition.
            -- We need TypeMetadataHandle from ClassCharacteristic to get Il2CppTypeDefinition.
            local fieldDefActualIndex = -1 -- Placeholder
            if ClassCharacteristic and ClassCharacteristic.TypeMetadataHandle and Il2cpp.Il2CppTypeDefinitionApi then
                 local typeDef = ClassCharacteristic.TypeMetadataHandle -- This is Il2CppTypeDefinition*
                 local fieldStartIndexForClass = gg.getValues({{
                     address = typeDef + Il2cpp.Il2CppTypeDefinitionApi.fieldStart,
                     flags = gg.TYPE_DWORD -- fieldStart is an index
                 }})[1].value
                 fieldDefActualIndex = fieldStartIndexForClass + fieldDefValueIndex
            end


            _FieldsInfoResult[#_FieldsInfoResult + 1] = setmetatable({
                ClassName = ClassCharacteristic.ClassName, -- From context
                ClassAddress = "N/A", -- Not directly available from Il2CppFieldDefinition easily
                FieldName = fieldName,
                Offset = string.format('%X', fieldOffset),
                IsStatic = IsStatic,
                Type = typeName,
                IsConst = IsConst,
                Access = Il2CppFlags.Field.Access[attrs & Il2CppFlags.Field.FIELD_ATTRIBUTE_FIELD_ACCESS_MASK] or "public",
                -- Token = string.format("0x%X", token) -- Store the field's token
            }, {
                __index = Il2cpp.FieldInfoApi,
                fieldIndex = fieldDefActualIndex -- Used by GetConstValue
            })
            fieldDefValueIndex = fieldDefValueIndex + 1
            ::continue_loop::
        end
        return _FieldsInfoResult
    end,


    ---@param self FieldApi
    ---@param fieldName string
    ---@return FieldInfo[] | ErrorSearch
    FindFieldWithName = function(self, fieldName)
        -- This function is complex because it requires iterating all classes, then their fields.
        -- The original approach of finding string pointers and working backwards is unreliable.
        -- A proper implementation would:
        -- 1. Iterate all Il2CppImage.
        -- 2. For each image, iterate all Il2CppClass.
        -- 3. For each class, get its fields.
        -- 4. Check if any field matches fieldName.
        -- This is very slow if not cached. Il2cppMemory should handle caching.

        -- Simulating a placeholder for the complex logic, as the original was also problematic.
        -- The user should ideally search within a specific class context if possible.
        -- If a global field search is needed, it implies a full dump and search.
        
        -- For now, let's assume the user will use FindClass then iterate fields.
        -- This global FindFieldWithName is hard to implement efficiently without a full metadata cache.
        
        -- Fallback: Try to use the cached classes if available.
        local foundFields = {}
        if Il2cppMemory and Il2cppMemory.Classes then
            for classKey, classMemoryEntry in pairs(Il2cppMemory.Classes) do
                if classMemoryEntry and classMemoryEntry.result and not classMemoryEntry.result.Error then
                    for _, classInfo in ipairs(classMemoryEntry.result) do
                        if classInfo.GetFieldWithName then -- Check if method exists
                            local field = classInfo:GetFieldWithName(fieldName)
                            if field then
                                table.insert(foundFields, field)
                            end
                        elseif classInfo.Fields then -- Fallback to manual iteration if GetFieldWithName not populated
                             for _, f_info in ipairs(classInfo.Fields) do
                                if f_info.FieldName == fieldName then
                                    table.insert(foundFields, f_info)
                                end
                            end
                        end
                    end
                end
            end
        end

        if #foundFields > 0 then
            return foundFields
        else
            return { Error = string.format("Global field search for '%s' yielded no results or not fully implemented.", fieldName) }
        end
    end,


    ---@param self FieldApi
    ---@param fieldAddress number
    ---@return FieldInfo[] | ErrorSearch
    FindFieldWithAddress = function(self, fieldAddress)
        -- This implies finding which object and field corresponds to a given memory address.
        -- 1. Find the object head.
        -- 2. Get the class of the object.
        -- 3. Calculate field offset from object head.
        -- 4. Get the field at that offset from the class.
        local ObjectHeadInfo = Il2cpp.ObjectApi.FindHead(fieldAddress)
        if not ObjectHeadInfo or ObjectHeadInfo.value == 0 or ObjectHeadInfo.address == 0 then
            return { Error = "Could not find object head for address 0x" .. string.format('%X', fieldAddress) }
        end

        local fieldOffsetInObject = fieldAddress - ObjectHeadInfo.address
        local classAddressOfObject = Il2cpp.FixValue(ObjectHeadInfo.value)

        local classSearchResults = Il2cpp.FindClass({{ Class = classAddressOfObject, FieldsDump = true }})
        if not classSearchResults or classSearchResults.Error or #classSearchResults == 0 then
             return { Error = "Could not find class for object at 0x" .. string.format('%X', ObjectHeadInfo.address) }
        end
        
        local classInfo = classSearchResults[1] -- Assuming first result is the one
        if not classInfo.GetFieldWithOffset then
             return { Error = "ClassInfo for 0x" .. string.format('%X', classAddressOfObject) .. " does not have GetFieldWithOffset." }
        end

        local field = classInfo:GetFieldWithOffset(fieldOffsetInObject)
        if field then
            return { field } -- Return as an array
        else
            return { Error = string.format("No field found at offset 0x%X in class %s (0x%X)", fieldOffsetInObject, classInfo.ClassName, classAddressOfObject) }
        end
    end,

    ---@param self FieldApi
    ---@param fieldSearchCondition string | number
    ---@param classAddress number -- Address of the Il2CppClass to search within
    ---@return FieldInfo[] | ErrorSearch
    FindFieldInClass = function(self, fieldSearchCondition, classAddress)
        local classConfig = { Class = classAddress, FieldsDump = true, MethodsDump = false }
        local classSearchResults = Il2cpp.FindClass({classConfig})

        if not classSearchResults or classSearchResults.Error or #classSearchResults == 0 then
            return { Error = "Could not find or process class at address 0x" .. string.format('%X', classAddress) }
        end
        
        local classInfo = classSearchResults[1] -- Assuming the first result is the target class
        local foundField = nil

        if type(fieldSearchCondition) == "number" then -- Search by offset
            if classInfo.GetFieldWithOffset then
                foundField = classInfo:GetFieldWithOffset(fieldSearchCondition)
            else
                return { Error = "GetFieldWithOffset not available on ClassInfo."}
            end
        elseif type(fieldSearchCondition) == "string" then -- Search by name
            if classInfo.GetFieldWithName then
                foundField = classInfo:GetFieldWithName(fieldSearchCondition)
            else
                 return { Error = "GetFieldWithName not available on ClassInfo."}
            end
        else
            return { Error = "Invalid field search condition type." }
        end

        if foundField then
            return { foundField } -- Return as an array
        else
            if type(fieldSearchCondition) == "number" then
                return { Error = string.format("Field not found at offset 0x%X in class %s", fieldSearchCondition, classInfo.ClassName or string.format("0x%X", classAddress)) }
            else
                return { Error = string.format("Field '%s' not found in class %s", fieldSearchCondition, classInfo.ClassName or string.format("0x%X", classAddress)) }
            end
        end
    end,


    FindTypeCheck = {
        ---@param self FieldApi
        ---@param fieldName string
        ['string'] = function(self, fieldName)
            -- Global search by name is problematic. This should ideally be scoped to a class.
            -- For now, it calls the global search which has limitations.
            return Protect:Call(self.FindFieldWithName, self, fieldName)
        end,
        ---@param self FieldApi
        ---@param fieldAddress number
        ['number'] = function(self, fieldAddress)
            -- This interprets a number as a direct memory address of a field.
            return Protect:Call(self.FindFieldWithAddress, self, fieldAddress)
        end,
        ['default'] = function()
            return {
                Error = 'Invalid search criteria for field'
            }
        end
    },


    ---@param self FieldApi
    ---@param fieldSearchCondition number | string
    ---@return FieldInfo[] | ErrorSearch
    Find = function(self, fieldSearchCondition)
        -- This top-level Find is for global searches or direct address lookups.
        -- If searching within a class, use ClassInfo:GetFieldWithName or ClassInfo:GetFieldWithOffset.
        local searchKey = fieldSearchCondition
        local cachedResult = Il2cppMemory:GetInformationOfField(searchKey)

        if cachedResult then
            return cachedResult -- Return cached result (could be FieldInfo[] or ErrorSearch)
        end

        local fieldsResult = (self.FindTypeCheck[type(searchKey)] or self.FindTypeCheck['default'])(self, searchKey)
        
        Il2cppMemory:SetInformationOfField(searchKey, fieldsResult) -- Cache the result
        return fieldsResult
    end
}

return FieldApi

end)
__bundle_register("il2cppstruct.globalmetadata", function(require, _LOADED, __bundle_register, __bundle_modules)
---@class GlobalMetadataApi
---@field typeDefinitionsSize number -- Size of one Il2CppTypeDefinition struct, for older versions
---@field typeDefinitionsOffset number -- Offset in global-metadata.dat to the start of Il2CppTypeDefinition array/pointers
---@field stringOffset number -- Offset to string literal data
---@field fieldDefaultValuesOffset number -- Offset to Il2CppFieldDefaultValue array
---@field fieldDefaultValuesSize number -- Total size of the Il2CppFieldDefaultValue array in bytes
---@field fieldAndParameterDefaultValueDataOffset number -- Offset to default value data blob
---@field version number -- Il2Cpp version number (e.g., 24, 27, 29)
local GlobalMetadataApi = {


    ---@type table<number, fun(self: GlobalMetadataApi, blobAddress : number, typePtr : number | nil) : string | number>
    behaviorForTypes = {
        [2] = function(self, blobAddress) -- IL2CPP_TYPE_BOOLEAN
            return self.ReadNumberConst(blobAddress, gg.TYPE_BYTE) ~= 0 -- Typically 0 or 1
        end,
        [3] = function(self, blobAddress) -- IL2CPP_TYPE_CHAR
            return self.ReadNumberConst(blobAddress, gg.TYPE_WORD) -- Chars are UTF-16, 2 bytes
        end,
        [4] = function(self, blobAddress) -- IL2CPP_TYPE_I1 (sbyte)
            return self.ReadNumberConst(blobAddress, gg.TYPE_BYTE) -- Read as byte, then cast to signed if needed
        end,
        [5] = function(self, blobAddress) -- IL2CPP_TYPE_U1 (byte)
            return self.ReadNumberConst(blobAddress, gg.TYPE_BYTE)
        end,
        [6] = function(self, blobAddress) -- IL2CPP_TYPE_I2 (short)
            return self.ReadNumberConst(blobAddress, gg.TYPE_WORD) -- Read as word, cast to signed
        end,
        [7] = function(self, blobAddress) -- IL2CPP_TYPE_U2 (ushort)
            return self.ReadNumberConst(blobAddress, gg.TYPE_WORD)
        end,
        [8] = function(self, blobAddress) -- IL2CPP_TYPE_I4 (int)
            return self.version < 29 and self.ReadNumberConst(blobAddress, gg.TYPE_DWORD) or self.ReadCompressedInt32(blobAddress)
        end,
        [9] = function(self, blobAddress) -- IL2CPP_TYPE_U4 (uint)
            return self.version < 29 and Il2cpp.FixValue(self.ReadNumberConst(blobAddress, gg.TYPE_DWORD)) or self.ReadCompressedUInt32(blobAddress)
        end,
        [10] = function(self, blobAddress) -- IL2CPP_TYPE_I8 (long)
            return self.ReadNumberConst(blobAddress, gg.TYPE_QWORD)
        end,
        [11] = function(self, blobAddress) -- IL2CPP_TYPE_U8 (ulong)
            return self.ReadNumberConst(blobAddress, gg.TYPE_QWORD)
        end,
        [12] = function(self, blobAddress) -- IL2CPP_TYPE_R4 (float)
            return self.ReadNumberConst(blobAddress, gg.TYPE_FLOAT)
        end,
        [13] = function(self, blobAddress) -- IL2CPP_TYPE_R8 (double)
            return self.ReadNumberConst(blobAddress, gg.TYPE_DOUBLE)
        end,
        [14] = function(self, blobAddress) -- IL2CPP_TYPE_STRING
            local length, offset = 0, 0
            if self.version >= 29 then
                length, offset = self.ReadCompressedInt32(blobAddress) -- Length of string
            else
                length = self.ReadNumberConst(blobAddress, gg.TYPE_DWORD) -- Length of string
                offset = 4 -- Size of DWORD for length
            end

            if length == -1 then return nil end -- Null string
            if length == 0 then return "" end   -- Empty string
            -- The blobAddress + offset should point to the UTF-8 string data
            return Il2cpp.Utf8ToString(blobAddress + offset, length)
        end,
        -- Other types like IL2CPP_TYPE_CLASS, IL2CPP_TYPE_VALUETYPE for enums might point to a data blob
        -- representing the enum's underlying type value.
        -- IL2CPP_TYPE_OBJECT for System.Object default value (null)
        [28] = function(self, blobAddress) -- IL2CPP_TYPE_OBJECT
            return nil -- Default for object is null
        end,
        -- For enums (which are VALUETYPE), the default value is more complex.
        -- It depends on the enum's underlying type. The typePtr might be needed here.
        [17] = function(self, blobAddress, typePtr) -- IL2CPP_TYPE_VALUETYPE (could be an enum)
            if typePtr then
                -- Get the Il2CppType for this enum
                local enumBaseTypePtr = Il2cpp.FixValue(gg.getValues({{address = typePtr + (Il2cpp.AndroidInfo.platform and 0x10 or 0x8), flags = Il2cpp.MainType}})[1].value) -- Il2CppType->data.type (points to underlying Il2CppType)
                                                                                                                                                                -- This offset needs to be precise for Il2CppType->data.type (pointer to base type for enums)
                if enumBaseTypePtr ~= 0 then
                    local baseTypeEnum = gg.getValues({{address = enumBaseTypePtr, flags = gg.TYPE_BYTE}})[1].value -- Il2CppTypeEnum of the base type
                    local behavior = self.behaviorForTypes[baseTypeEnum]
                    if type(behavior) == "function" then
                        return behavior(self, blobAddress, nil) -- Call with nil for typePtr to avoid recursion on base
                    end
                end
            end
            -- Fallback or if not an enum with known base: try reading as int
            return self.version < 29 and self.ReadNumberConst(blobAddress, gg.TYPE_DWORD) or self.ReadCompressedInt32(blobAddress)
        end,

    },


    ---@param self GlobalMetadataApi
    ---@param index number -- Index into the string literal table (offset from string literal base)
    ---@return string
    GetStringFromIndex = function(self, index)
        if index < 0 then return "" end -- Invalid index
        local stringLiteralBase = Il2cpp.globalMetadataStart + self.stringOffset
        return Il2cpp.Utf8ToString(stringLiteralBase + index)
    end,


    ---@param self GlobalMetadataApi
    ---@param typeDefinitionIndex number -- Index of the Il2CppTypeDefinition
    ---@return string -- Class name
    GetClassNameFromIndex = function(self, typeDefinitionIndex)
        -- This function retrieves the name of a class given its TypeDefinitionIndex.
        -- It needs to access the Il2CppTypeDefinition structure.
        local typeDefPtr = 0
        if (self.version < 27) then
            -- Older versions: typeDefinitionsOffset points to an array of Il2CppTypeDefinition structs
            local typeDefinitionsBase = Il2cpp.globalMetadataStart + self.typeDefinitionsOffset
            typeDefPtr = typeDefinitionsBase + (self.typeDefinitionsSize * typeDefinitionIndex)
        else
            -- Newer versions: typeDefinitionsOffset points to an array of *pointers* to Il2CppTypeDefinition
            local typeDefinitionPointersBase = Il2cpp.globalMetadataStart + self.typeDefinitionsOffset
            local ptrToTypeDef = gg.getValues({{
                address = typeDefinitionPointersBase + (typeDefinitionIndex * Il2cpp.pointSize),
                flags = Il2cpp.MainType
            }})[1].value
            typeDefPtr = Il2cpp.FixValue(ptrToTypeDef)
        end

        if typeDefPtr == 0 then return "UnknownType" end

        -- Now, from typeDefPtr (Il2CppTypeDefinition*), get the nameIndex
        -- The offset of nameIndex within Il2CppTypeDefinition is constant (0 for most versions)
        local nameIndex = gg.getValues({{
            address = typeDefPtr, -- Assuming nameIndex is at the start of Il2CppTypeDefinition
            flags = gg.TYPE_DWORD -- nameIndex is an int
        }})[1].value
        
        return self:GetStringFromIndex(nameIndex)
    end,


    ---@param self GlobalMetadataApi
    ---@param dataIndex number -- Index into the default value data blob
    ---@return number -- Address of the default value data
    GetFieldOrParameterDefalutValueDataPointer = function(self, dataIndex) -- Renamed for clarity
        return self.fieldAndParameterDefaultValueDataOffset + Il2cpp.globalMetadataStart + dataIndex
    end,


    ---@param self GlobalMetadataApi
    ---@param fieldDefIndex string -- Field Definition Index (as a string for searchNumber)
    ---@return table | nil -- Il2CppFieldDefaultValue result from gg.getResults, or nil
    GetIl2CppFieldDefaultValueEntry = function(self, fieldDefIndex) -- Renamed for clarity
        gg.clearResults()
        -- Set ranges to global-metadata only for this specific search
        local metadataRangeStart = Il2cpp.globalMetadataStart + self.fieldDefaultValuesOffset
        local metadataRangeEnd = metadataRangeStart + self.fieldDefaultValuesSize
        if metadataRangeStart >= metadataRangeEnd then return nil end -- Avoid invalid range

        gg.setRanges(gg.REGION_ANONYMOUS) -- Or whichever range global-metadata is in
        gg.searchNumber(fieldDefIndex, gg.TYPE_DWORD, false, gg.SIGN_EQUAL,
            metadataRangeStart,
            metadataRangeEnd
        )
        if gg.getResultsCount() > 0 then
            local entry = gg.getResults(1) -- Get the first match
            gg.clearResults()
            return entry -- This is a table like {{address=..., flags=..., value=...}}
        end
        gg.clearResults()
        return nil
    end,

    
    ---@param Address number
    ---@return number, number -- value, offset_read
    ReadCompressedUInt32 = function(Address)
        local val, offset = 0, 0
        local bytes = gg.getValues({
            { address = Address, flags = gg.TYPE_BYTE },
            { address = Address + 1, flags = gg.TYPE_BYTE },
            { address = Address + 2, flags = gg.TYPE_BYTE },
            { address = Address + 3, flags = gg.TYPE_BYTE },
            { address = Address + 4, flags = gg.TYPE_BYTE } -- Read one extra for 5-byte case
        })
        if not bytes or #bytes < 1 then return 0, 0 end -- Read failed

        local b0 = bytes[1].value & 0xFF
        offset = 1
        if (b0 & 0x80) == 0 then -- 1-byte
            val = b0
        elseif (b0 & 0xC0) == 0x80 then -- 2-bytes
            if #bytes < 2 then return 0, 0 end
            val = ((b0 & 0x3F) << 8) | (bytes[2].value & 0xFF)
            offset = 2
        elseif (b0 & 0xE0) == 0xC0 then -- 4-bytes
            if #bytes < 4 then return 0, 0 end
            val = ((b0 & 0x1F) << 24) | ((bytes[2].value & 0xFF) << 16) | ((bytes[3].value & 0xFF) << 8) | (bytes[4].value & 0xFF)
            offset = 4
        -- Unity's Il2Cpp uses a slightly different scheme than standard VarInt for >4 bytes.
        -- It seems to be:
        -- 0xF0: next 4 bytes are the uint32_t value (total 5 bytes)
        -- 0xFE: value is kUInt32Max - 1
        -- 0xFF: value is kUInt32Max
        elseif b0 == 0xF0 then -- 5-byte encoding in some Unity versions
             if #bytes < 5 then return 0,0 end
             val = ((bytes[2].value & 0xFF) << 24) | ((bytes[3].value & 0xFF) << 16) | ((bytes[4].value & 0xFF) << 8) | (bytes[5].value & 0xFF)
             offset = 5
        elseif b0 == 0xFE then
            val = 0xFFFFFFFF - 1
            offset = 1
        elseif b0 == 0xFF then
            val = 0xFFFFFFFF
            offset = 1
        else
            -- Should not happen with valid compressed data
            -- gg.print("Warning: Invalid start byte for ReadCompressedUInt32: " .. string.format("0x%X", b0))
            return 0,0 
        end
        return val, offset
    end,


    ---@param Address number
    ---@return number, number -- value, offset_read
    ReadCompressedInt32 = function(Address)
        local encoded, offset = Il2cpp.GlobalMetadataApi.ReadCompressedUInt32(Address)
        if offset == 0 then return 0, 0 end -- ReadCompressedUInt32 failed

        if encoded == 0xFFFFFFFF then -- Special case for kInt32Min often
            return -2147483648, offset -- Smallest 32-bit signed int
        end

        local isNegative = (encoded & 1) == 1
        local magnitude = encoded >> 1
        
        if isNegative then
            return -(magnitude + 1) -- ZigZag decoding
        else
            return magnitude
        end
    end,


    ---@param Address number
    ---@param ggType number @gg.TYPE_
    ReadNumberConst = function(Address, ggType)
        local val = gg.getValues({{
            address = Address,
            flags = ggType
        }})[1]
        return val and val.value
    end,

    
    ---@param self GlobalMetadataApi
    ---@param fieldDefIndex number -- The global definition index of the field
    ---@return number | string | boolean | nil -- The default value
    GetDefaultFieldValue = function(self, fieldDefIndex)
        if fieldDefIndex < 0 then return nil end -- Invalid index from DecodeFieldsInfo

        local fieldDefaultValueEntry = self:GetIl2CppFieldDefaultValueEntry(tostring(fieldDefIndex))
        
        if fieldDefaultValueEntry and #fieldDefaultValueEntry > 0 then
            -- fieldDefaultValueEntry[1].address is the start of the Il2CppFieldDefaultValue struct
            -- whose first field is fieldIndex (which we searched for).
            -- We need typeIndex and dataIndex from this struct.
            -- Assuming Il2CppFieldDefaultValue structure: { int fieldIndex; int typeIndex; int dataIndex; } (all TYPE_DWORD)
            local structBaseAddress = fieldDefaultValueEntry[1].address
            
            local defaultValInfo = gg.getValues({
                { -- TypeIndex [1] (offset +4 from fieldIndex)
                    address = structBaseAddress + 4, -- Offset of typeIndex in Il2CppFieldDefaultValue
                    flags = gg.TYPE_DWORD,
                },
                { -- dataIndex [2] (offset +8 from fieldIndex)
                    address = structBaseAddress + 8, -- Offset of dataIndex in Il2CppFieldDefaultValue
                    flags = gg.TYPE_DWORD 
                }
            })
            if not defaultValInfo or not defaultValInfo[1] then return nil end

            local valueTypeIndex = defaultValInfo[1].value -- This is an index into Il2CppType table
            local valueDataIndex = defaultValInfo[2].value -- This is an index into the default value data blob

            local dataBlobPointer = self:GetFieldOrParameterDefalutValueDataPointer(valueDataIndex)
            
            local il2cppTypePtr = Il2cpp.MetadataRegistrationApi:GetIl2CppTypeFromIndex(valueTypeIndex)
            if not il2cppTypePtr or il2cppTypePtr == 0 then return nil end -- Could not get type

            local typeEnum = Il2cpp.TypeApi:GetTypeEnum(il2cppTypePtr) -- Get the Il2CppTypeEnum
            
            local behavior = self.behaviorForTypes[typeEnum]
            if type(behavior) == "function" then
                return behavior(self, dataBlobPointer, il2cppTypePtr) -- Pass self and typePtr
            elseif type(behavior) == "string" then
                return behavior -- "Not support type"
            else
                -- gg.print("Warning: No behavior defined for type enum: " .. typeEnum)
                return nil -- Or some other default for unsupported types
            end
        end
        return nil -- No default value entry found for this field index
    end,


    ---@param name string
    ---@return table -- Array of {address, flags, value} where value is the pointer to the string
    GetPointersToString = function(name)
        local pointers = {}
        gg.clearResults()
        gg.setRanges(gg.REGION_ANONYMOUS) -- Assuming global-metadata is in anonymous regions or similar known regions
                                        -- This should be set more specifically if possible.
        
        -- Search for the UTF-8 bytes of the string, null-terminated.
        local searchPattern = ""
        local bytes = gg.bytes(name, "UTF-8")
        for i=1, #bytes do
            searchPattern = searchPattern .. string.format("%02X", bytes[i]) .. "h;"
        end
        searchPattern = searchPattern .. "00h" -- Null terminator

        -- This searches for the string literal itself in global-metadata.
        gg.searchNumber(searchPattern, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, 
            Il2cpp.globalMetadataStart + Il2cpp.GlobalMetadataApi.stringOffset, -- Search within string literal section
            Il2cpp.globalMetadataEnd) -- Limit search to metadata region
        
        local stringLiteralAddresses = gg.getResults(gg.getResultsCount())
        gg.clearResults()

        if #stringLiteralAddresses == 0 then
            -- gg.print(string.format("String literal '%s' not found in global-metadata.", name))
            return {}
        end

        -- Now, search for pointers TO these string literals.
        -- This search needs to span regions where Il2CppClass, Il2CppMethodDefinition etc. might reside.
        -- Typically, these are also in mapped regions of libil2cpp.so (for definitions) or global-metadata.
        gg.setRanges(gg.REGION_ANONYMOUS | gg.REGION_C_DATA | gg.REGION_C_BSS) -- Broaden search for pointers
        
        for _, strAddrInfo in ipairs(stringLiteralAddresses) do
            gg.searchNumber(string.format("%Xh", strAddrInfo.address), Il2cpp.MainType) -- Search for pointers to the string
        end

        pointers = gg.getResults(gg.getResultsCount())
        if #pointers == 0 then
            -- gg.print(string.format("No pointers found to string literal '%s'.", name))
        end
        gg.clearResults()
        return pointers
    end
}

return GlobalMetadataApi
end)
__bundle_register("il2cppstruct.method", function(require, _LOADED, __bundle_register, __bundle_modules)
local AndroidInfo = require("utils.androidinfo")
local Protect = require("utils.protect")
local Il2cppMemory = require("utils.il2cppmemory")

---@class MethodsApi
---@field ClassOffset number -- Offset of Il2CppClass* declaringType in Il2CppMethodDefinition
---@field NameOffset number -- Offset of const char* name in Il2CppMethodDefinition (or nameIndex)
---@field ParamCount number -- Offset of uint16_t parameterCount in Il2CppMethodDefinition
---@field ReturnType number -- Offset of const Il2CppType* returnType in Il2CppMethodDefinition
---@field Flags number -- Offset of uint16_t flags in Il2CppMethodDefinition
local MethodsApi = {


    ---@param self MethodsApi
    ---@param MethodName string
    ---@param searchResult MethodMemory -- State for caching/tracking
    ---@return MethodInfoRaw[] | ErrorSearch
    FindMethodWithName = function(self, MethodName, searchResult)
        local FinalMethodsRaw = {}
        -- GetPointersToString now returns pointers TO the string literal.
        -- We need to find Il2CppMethodDefinition structures whose 'name' field (or 'nameIndex' resolved) matches.
        -- This is a complex reverse lookup. The original logic was likely simplified.
        
        -- A more direct (but slow without full dump) way:
        -- Iterate all classes, then all their methods, then check method name.
        
        -- Sticking to a modified version of the original's spirit:
        -- Assume GetPointersToString finds where MethodName is stored (e.g., in metadata string table).
        -- Then, it searches for Il2CppMethodDefinition structures that point to this name.
        local nameLiteralPointers = Il2cpp.GlobalMetadataApi.GetPointersToString(MethodName)
        if #nameLiteralPointers == 0 then
            return { Error = string.format("Method name literal '%s' not found in metadata.", MethodName) }
        end

        -- This assumes NameOffset is for a direct char* name. If it's an index, logic changes.
        -- Let's assume NameOffset points to a `const char* name` in Il2CppMethodDefinition.
        -- We need to search for Il2CppMethodDefinition structs where `struct_addr + NameOffset` points to one of `nameLiteralPointers[j].address`.
        
        -- This is still a broad search. The original code had:
        -- `methodPoint.address = methodPoint.address - self.NameOffset`
        -- This implied `methodPoint.address` was ALREADY `Il2CppMethodDefinition + self.NameOffset`.
        -- This means `GetPointersToString` would need to return addresses of the `name` field within `Il2CppMethodDefinition` structs.
        -- This is not what `GetPointersToString` (as revised for string literals) does.

        -- Let's assume the user will use FindClass -> GetMethodsWithName for specific searches.
        -- This global search is hard to make efficient and correct without a full pre-parsed metadata model.
        
        -- Fallback: if Il2cppMemory has cached methods, search there.
        if Il2cppMemory and Il2cppMemory.Methods then
            for key, methodMemoryEntry in pairs(Il2cppMemory.Methods) do
                if methodMemoryEntry and methodMemoryEntry.result and not methodMemoryEntry.result.Error then
                    for _, methodInfo in ipairs(methodMemoryEntry.result) do
                        if methodInfo.MethodName == MethodName then
                            -- Need to construct MethodInfoRaw from MethodInfo
                            table.insert(FinalMethodsRaw, {
                                MethodName = methodInfo.MethodName,
                                MethodAddress = tonumber(methodInfo.AddressInMemory, 16), -- Convert hex string to number
                                MethodInfoAddress = methodInfo.MethodInfoAddress, -- This is Il2CppMethodDefinition*
                                ClassName = methodInfo.ClassName -- For context
                            })
                        end
                    end
                end
            end
        end
        
        if #FinalMethodsRaw > 0 then
             searchResult.len = #FinalMethodsRaw -- Update length based on found methods
             return FinalMethodsRaw
        else
             searchResult.isNew = false -- No new methods found this way
             return { Error = string.format("Global method search for '%s' yielded no results or not fully implemented.", MethodName) }
        end
    end,


    ---@param self MethodsApi
    ---@param MethodOffset number -- Offset from libil2cpp.so base
    ---@param searchResult MethodMemory | nil
    ---@return MethodInfoRaw[] | ErrorSearch
    FindMethodWithOffset = function(self, MethodOffset, searchResult)
        local methodAddressInMemory = Il2cpp.il2cppStart + MethodOffset
        return self:FindMethodWithAddressInMemory(methodAddressInMemory, searchResult, MethodOffset)
    end,


    ---@param self MethodsApi
    ---@param MethodAddress number -- Absolute address in memory
    ---@param searchResult MethodMemory
    ---@param MethodOffset number | nil -- Relative offset if known
    ---@return MethodInfoRaw[] | ErrorSearch
    FindMethodWithAddressInMemory = function(self, MethodAddress, searchResult, MethodOffset)
        local RawMethodsInfo = {} 
        gg.clearResults()
        -- Search for pointers to this MethodAddress. These pointers would be inside Il2CppMethodDefinition.
        -- The field in Il2CppMethodDefinition that holds the method's code address is typically 'methodPointer' or similar.
        -- Let's assume it's at the very start of Il2CppMethodDefinition for simplicity (offset 0).
        -- This means we are looking for Il2CppMethodDefinition structs.
        
        gg.setRanges(gg.REGION_C_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_C_BSS | gg.REGION_C_DATA | gg.REGION_OTHER)
        
        -- Search for the MethodAddress value itself.
        -- If Il2CppMethodDefinition->methodPointer is at offset 0 of the struct:
        gg.searchNumber(string.format("%Xh", MethodAddress), Il2cpp.MainType)
        
        local r_count = gg.getResultsCount()
        if r_count > searchResult.len or searchResult.isNew then -- searchResult.len tracks previously found for this key
            local results = gg.getResults(r_count)
            for j = 1, #results do
                -- results[j].address is the address of Il2CppMethodDefinition struct
                -- (assuming methodPointer is at offset 0 of the struct)
                RawMethodsInfo[#RawMethodsInfo + 1] = {
                    MethodAddress = MethodAddress, -- The code address
                    MethodInfoAddress = results[j].address, -- The Il2CppMethodDefinition*
                    Offset = MethodOffset -- Relative offset if provided
                    -- ClassName and MethodName will be filled by Unpack/Decode
                }
            end
            searchResult.len = r_count -- Update based on current findings
        else
            searchResult.isNew = false
        end 
        gg.clearResults()

        if #RawMethodsInfo == 0 then
            return { Error = string.format("No Il2CppMethodDefinition found pointing to address 0x%X", MethodAddress)}
        end
        return RawMethodsInfo
    end,


    ---@param self MethodsApi
    ---@param _MethodsInfoRaw MethodInfoRaw[] -- Array of raw info (MethodInfoAddress, context)
    ---@param DecodedValuesBatch table -- Flat array of values from gg.getValues for all methods
    DecodeMethodsInfo = function(self, _MethodsInfoRaw, DecodedValuesBatch)
        local batchValueIndex = 1
        for i = 1, #_MethodsInfoRaw do
            local rawEntry = _MethodsInfoRaw[i]
            if not rawEntry.MethodInfoAddress or rawEntry.MethodInfoAddress == 0 then goto next_method_decode end

            -- Each method unpacks 6 values (methodPtr, namePtr, classPtr, paramCount, returnTypePtr, flags)
            if batchValueIndex + 5 > #DecodedValuesBatch then 
                -- gg.print("Warning: Not enough decoded values for method " .. i)
                goto next_method_decode 
            end

            local methodActualAddress = Il2cpp.FixValue(DecodedValuesBatch[batchValueIndex + 0].value) -- methodPointer
            local namePtrOrIndex    = DecodedValuesBatch[batchValueIndex + 1].value -- name or nameIndex
            local classPtr          = Il2cpp.FixValue(DecodedValuesBatch[batchValueIndex + 2].value) -- declaringType
            local paramCountVal     = DecodedValuesBatch[batchValueIndex + 3].value -- parameterCount
            local returnTypePtr     = Il2cpp.FixValue(DecodedValuesBatch[batchValueIndex + 4].value) -- returnType
            local methodFlagsVal    = DecodedValuesBatch[batchValueIndex + 5].value -- flags
            
            batchValueIndex = batchValueIndex + 6

            local methodName
            if rawEntry.MethodName then -- If name already known (e.g. from FindMethodWithName)
                methodName = rawEntry.MethodName
            else
                -- Determine if namePtrOrIndex is a direct pointer or an index
                -- This depends on Il2Cpp version and how NameOffset is defined for MethodsApi.
                -- Assuming NameOffset implies it's an index into metadata string table for newer versions,
                -- or direct pointer for older. For simplicity, let's assume it's a direct pointer for now if not an index.
                -- A robust solution needs version-specific logic for Il2CppMethodDefinition.name field.
                -- If NameOffset points to a nameIndex (int):
                -- methodName = Il2cpp.GlobalMetadataApi:GetStringFromIndex(namePtrOrIndex)
                -- If NameOffset points to a const char*:
                methodName = Il2cpp.Utf8ToString(Il2cpp.FixValue(namePtrOrIndex))
            end

            local className
            if rawEntry.ClassName then
                className = rawEntry.ClassName
            elseif classPtr ~= 0 then
                className = Il2cpp.ClassApi:GetClassName(classPtr)
            else
                className = "UnknownClass"
            end
            
            local returnTypeName = "UnknownReturn"
            if returnTypePtr ~= 0 then
                 local rt_typeEnum = Il2cpp.TypeApi:GetTypeEnum(returnTypePtr)
                 local rt_typeData = gg.getValues({{address = returnTypePtr + (Il2cpp.AndroidInfo.platform and 0x8 or 0x4), flags = Il2cpp.MainType}})[1].value -- Il2CppType->data
                 returnTypeName = Il2cpp.TypeApi:GetTypeName(rt_typeEnum, rt_typeData, returnTypePtr)
            end

            local offsetStr
            if rawEntry.Offset then
                offsetStr = string.format("%X", rawEntry.Offset)
            elseif methodActualAddress ~= 0 and Il2cpp.il2cppStart ~= 0 then
                offsetStr = string.format("%X", methodActualAddress - Il2cpp.il2cppStart)
            else
                offsetStr = "0"
            end

            _MethodsInfoRaw[i] = { -- Overwrite the raw entry with decoded MethodInfo
                MethodName = methodName,
                Offset = offsetStr,
                AddressInMemory = string.format("%X", methodActualAddress),
                MethodInfoAddress = rawEntry.MethodInfoAddress, -- Preserve Il2CppMethodDefinition*
                ClassName = className,
                ClassAddress = string.format('%X', classPtr),
                ParamCount = paramCountVal,
                ReturnType = returnTypeName,
                IsStatic = (methodFlagsVal & Il2CppFlags.Method.METHOD_ATTRIBUTE_STATIC) ~= 0,
                Access = Il2CppFlags.Method.Access[methodFlagsVal & Il2CppFlags.Method.METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK] or "public",
                IsAbstract = (methodFlagsVal & Il2CppFlags.Method.METHOD_ATTRIBUTE_ABSTRACT) ~= 0,
            }
            ::next_method_decode::
        end
    end,


    ---@param self MethodsApi
    ---@param MethodInfoRawItem MethodInfoRaw -- Contains MethodInfoAddress, and optional context like ClassName, MethodName
    ---@return table, MethodInfoRaw -- {values_to_read_for_gg}, {updated_raw_info_for_decode}
    UnpackMethodInfo = function(self, MethodInfoRawItem)
        -- Returns a table of items for gg.getValues, and the original MethodInfoRawItem
        -- The MethodInfoAddress is the pointer to Il2CppMethodDefinition
        local defAddr = MethodInfoRawItem.MethodInfoAddress
        return {
            { -- [0] Actual Method Pointer (methodPointer)
                address = defAddr, -- Assuming methodPointer is at offset 0 of Il2CppMethodDefinition
                flags = Il2cpp.MainType
            },
            { -- [1] Name Pointer or Index (name)
                address = defAddr + self.NameOffset,
                flags = Il2cpp.MainType -- Could be char* or int index based on version
            },
            { -- [2] Class pointer (declaringType)
                address = defAddr + self.ClassOffset,
                flags = Il2cpp.MainType -- Il2CppClass*
            },
            { -- [3] Param Count (parameterCount)
                address = defAddr + self.ParamCount,
                flags = gg.TYPE_WORD -- Usually uint16_t
            },
            { -- [4] Return Type (returnType)
                address = defAddr + self.ReturnType,
                flags = Il2cpp.MainType -- const Il2CppType*
            },
            { -- [5] Flags (flags)
                address = defAddr + self.Flags,
                flags = gg.TYPE_WORD -- Usually uint16_t
            }
        }, MethodInfoRawItem -- Pass back the raw item for context in DecodeMethodsInfo
    end,


    FindParamsCheck = {
        ---@param self MethodsApi
        ---@param method number -- Can be offset or absolute address
        ---@param searchResult MethodMemory
        ['number'] = function(self, method, searchResult)
            if (method >= Il2cpp.il2cppStart and method < Il2cpp.il2cppEnd) then -- Heuristic for absolute address
                return Protect:Call(self.FindMethodWithAddressInMemory, self, method, searchResult, nil)
            else -- Assumed to be an offset from il2cppStart
                return Protect:Call(self.FindMethodWithOffset, self, method, searchResult)
            end
        end,
        ---@param self MethodsApi
        ---@param method string -- Method name
        ---@param searchResult MethodMemory
        ['string'] = function(self, method, searchResult)
            return Protect:Call(self.FindMethodWithName, self, method, searchResult)
        end,
        ['default'] = function()
            return {
                Error = 'Invalid search criteria type for method'
            }
        end
    },


    ---@param self MethodsApi
    ---@param method number | string
    ---@return MethodInfo[] | ErrorSearch
    Find = function(self, method)
        local searchKey = method
        local cachedResult = Il2cppMemory:GetInformaionOfMethod(searchKey)
        
        if cachedResult then
            return cachedResult.result -- Assuming result field holds MethodInfo[] or ErrorSearch
        end

        local searchState = {len = 0, isNew = true} -- State for the search functions
        
        ---@type MethodInfoRaw[] | ErrorSearch
        local methodsRawList = (self.FindParamsCheck[type(searchKey)] or self.FindParamsCheck['default'])(self, searchKey, searchState)

        if methodsRawList.Error then
            Il2cppMemory:SetInformaionOfMethod(searchKey, { result = methodsRawList, len = 0, isNew = true})
            return methodsRawList
        end
        
        if not methodsRawList or #methodsRawList == 0 then
            local err = { Error = "Method not found: " .. tostring(searchKey) }
            Il2cppMemory:SetInformaionOfMethod(searchKey, { result = err, len = 0, isNew = true})
            return err
        end

        local batchUnpackData = {}
        local rawEntriesForDecode = {} -- Keep the original raw entries with context

        for i = 1, #methodsRawList do
            local unpackData, rawEntryWithContext = self:UnpackMethodInfo(methodsRawList[i])
            for _, item in ipairs(unpackData) do
                table.insert(batchUnpackData, item)
            end
            table.insert(rawEntriesForDecode, rawEntryWithContext)
        end
        
        local decodedValues = {}
        if #batchUnpackData > 0 then
            decodedValues = gg.getValues(batchUnpackData)
        end
        
        if not decodedValues and #batchUnpackData > 0 then
             local err = { Error = "Failed to get values for method details: " .. tostring(searchKey) }
             Il2cppMemory:SetInformaionOfMethod(searchKey, { result = err, len = 0, isNew = true})
             return err
        end

        -- DecodeMethodsInfo will modify rawEntriesForDecode in place to become MethodInfo[]
        self:DecodeMethodsInfo(rawEntriesForDecode, decodedValues) 
        
        local finalResult = rawEntriesForDecode -- Now it's an array of MethodInfo
        Il2cppMemory:SetInformaionOfMethod(searchKey, { result = finalResult, len = #finalResult, isNew = true })
        return finalResult
    end
}

return MethodsApi
end)
__bundle_register("il2cppstruct.type", function(require, _LOADED, __bundle_register, __bundle_modules)
local Il2cppMemory = require("utils.il2cppmemory")

---@class TypeApi
---@field Type number -- Offset of 'attrs' or 'type' enum within Il2CppType struct. This needs clarification.
                     -- Let's assume Il2CppType struct: {void* data; unsigned int bits; union { Il2CppClass* klass; Il2CppType* type; Il2CppArrayType* array; Il2CppGenericClass* generic_class; Il2CppGenericParameter* generic_parameter;}}
                     -- 'bits' contains attrs and type enum.
                     -- For simplicity, let's assume self.Type is offset to 'bits' or the type enum part of 'bits'.
local TypeApi = {

    
    tableTypes = {
        [0] = "End", -- IL2CPP_TYPE_END
        [1] = "void", -- IL2CPP_TYPE_VOID
        [2] = "bool", -- IL2CPP_TYPE_BOOLEAN
        [3] = "char", -- IL2CPP_TYPE_CHAR
        [4] = "sbyte", -- IL2CPP_TYPE_I1
        [5] = "byte", -- IL2CPP_TYPE_U1
        [6] = "short", -- IL2CPP_TYPE_I2
        [7] = "ushort", -- IL2CPP_TYPE_U2
        [8] = "int", -- IL2CPP_TYPE_I4
        [9] = "uint", -- IL2CPP_TYPE_U4
        [10] = "long", -- IL2CPP_TYPE_I8
        [11] = "ulong", -- IL2CPP_TYPE_U8
        [12] = "float", -- IL2CPP_TYPE_R4
        [13] = "double", -- IL2CPP_TYPE_R8
        [14] = "string", -- IL2CPP_TYPE_STRING
        [15] = "Ptr", -- IL2CPP_TYPE_PTR (generic pointer)
        [16] = "ByRef", -- IL2CPP_TYPE_BYREF
        [17] = function(self, klassIndexOrPtr, il2cppTypePtr) -- IL2CPP_TYPE_VALUETYPE
            -- klassIndexOrPtr is Il2CppType->data.klassIndex for VALUETYPE
            -- It's an index into the Il2CppClass array (via Il2CppTypeDefinition table)
            local className = Il2cpp.GlobalMetadataApi:GetClassNameFromIndex(klassIndexOrPtr)
            return className or "UnknownValueType"
        end,
        [18] = function(self, klassIndexOrPtr, il2cppTypePtr) -- IL2CPP_TYPE_CLASS
            -- klassIndexOrPtr is Il2CppType->data.klassIndex
            local className = Il2cpp.GlobalMetadataApi:GetClassNameFromIndex(klassIndexOrPtr)
            return className or "UnknownClass"
        end,
        [19] = "Var", -- IL2CPP_TYPE_VAR (Generic parameter in a generic type definition)
        [20] = function(self, arrayTypePtr, il2cppTypePtr) -- IL2CPP_TYPE_ARRAY
            -- arrayTypePtr is Il2CppType->data.array, which is Il2CppArrayType*
            -- Il2CppArrayType has 'etype' (element type, an Il2CppType*) and 'rank'.
            if arrayTypePtr == 0 then return "UnknownArray[]" end
            local elementTypePtr = gg.getValues({{address = arrayTypePtr, flags = Il2cpp.MainType}})[1].value -- Il2CppArrayType->etype
            if elementTypePtr == 0 then return "UnknownType[]" end
            
            local etype_enum = self:GetTypeEnum(elementTypePtr)
            local etype_data = gg.getValues({{address = elementTypePtr + (Il2cpp.AndroidInfo.platform and 0x8 or 0x4), flags = Il2cpp.MainType}})[1].value
            local elementTypeName = self:GetTypeName(etype_enum, etype_data, elementTypePtr)
            -- Rank is usually at arrayTypePtr + pointSize, but let's simplify to "[]"
            return elementTypeName .. "[]"
        end,
        [21] = "GenericInst", -- IL2CPP_TYPE_GENERICINST (A generic type instantiation)
        [22] = "TypedByRef", -- IL2CPP_TYPE_TYPEDBYREF
        [24] = "IntPtr", -- IL2CPP_TYPE_I
        [25] = "UIntPtr", -- IL2CPP_TYPE_U
        [26] = "FnPtr", -- IL2CPP_TYPE_FNPTR
        [27] = "System.Object", -- IL2CPP_TYPE_OBJECT (distinct from IL2CPP_TYPE_CLASS)
        [28] = "SzArray", -- IL2CPP_TYPE_SZARRAY (single-dim, zero lower bound array) - often handled like ARRAY
                         -- For SZARRAY, data also points to an Il2CppType for the element.
        [29] = function(self, elementTypePtrData, il2cppTypePtr) -- IL2CPP_TYPE_SZARRAY (alternative handling if data directly points to element type)
            -- In some Il2CppType layouts for SZARRAY, data might directly be the element Il2CppType*
            if elementTypePtrData == 0 then return "UnknownType[]" end
            local etype_enum = self:GetTypeEnum(elementTypePtrData)
            local etype_data_val = gg.getValues({{address = elementTypePtrData + (Il2cpp.AndroidInfo.platform and 0x8 or 0x4), flags = Il2cpp.MainType}})[1].value
            local elementTypeName = self:GetTypeName(etype_enum, etype_data_val, elementTypePtrData)
            return elementTypeName .. "[]"
        end,

        [0xf7] = "Sentinel", -- IL2CPP_TYPE_SENTINEL
        [0xfb] = "Pinned", -- IL2CPP_TYPE_PINNED modifier
        [0xfd] = "ModOpt", -- IL2CPP_TYPE_MOD_OPT modifier
        [0xfe] = "ModReq", -- IL2CPP_TYPE_MOD_REQ modifier
    },


    ---@param self TypeApi
    ---@param typeEnumVal number @The Il2CppTypeEnum value
    ---@param typeDataVal number @The Il2CppType->data union value (e.g., klassIndex, pointer to Il2CppArrayType)
    ---@param il2cppTypePtr number @Pointer to the Il2CppType struct itself, for complex types
    ---@return string
    GetTypeName = function(self, typeEnumVal, typeDataVal, il2cppTypePtr)
        local typeNameOrFunc = self.tableTypes[typeEnumVal]
        
        if type(typeNameOrFunc) == 'function' then
            local cachedKey = il2cppTypePtr -- Cache based on the Il2CppType pointer for complex types
            if typeDataVal and typeEnumVal ~= 20 and typeEnumVal ~= 29 then -- For CLASS/VALUETYPE, data is an index
                cachedKey = typeEnumVal .. "_" .. typeDataVal 
            end

            local resultType = Il2cppMemory:GetInformationOfType(cachedKey)
            if not resultType then
                resultType = typeNameOrFunc(self, typeDataVal, il2cppTypePtr) -- Pass self
                Il2cppMemory:SetInformationOfType(cachedKey, resultType)
            end
            return resultType or ("TypeEnumFnError:"..typeEnumVal)
        elseif type(typeNameOrFunc) == 'string' then
            return typeNameOrFunc
        else
            return string.format('(UnsupportedTypeEnum:0x%X)', typeEnumVal)
        end
    end,


    ---@param self TypeApi
    ---@param Il2CppType_ptr number -- Pointer to an Il2CppType struct
    ---@return number -- The Il2CppTypeEnum value
    GetTypeEnum = function(self, Il2CppType_ptr)
        if Il2CppType_ptr == 0 then return 0 end -- IL2CPP_TYPE_END or error
        -- The Il2CppTypeEnum is part of the 'bits' field in Il2CppType.
        -- 'bits' typically contains: attrs (16 bits), type (8 bits), num_mods (6 bits), byref (1 bit), pinned (1 bit)
        -- The exact layout and offset of 'type' within 'bits' or the struct can vary.
        -- Assuming self.Type is the offset to where the type enum byte can be read directly,
        -- or it's an offset to the 'bits' field from which the type enum needs to be extracted.

        -- Let's assume Il2CppType structure: { void* dataOrKlassIndex; unsigned int bits; ... }
        -- And 'bits' is at Il2cpp.pointSize offset.
        -- And TypeApi.Type is the offset to the byte holding the enum within 'bits' or the struct.
        -- A common layout for 'bits' (32-bit field):
        --   attrs:16 | type:8 | num_mods:6 | byref:1 | pinned:1
        -- So, type enum would be (bits >> 16) & 0xFF if bits is at offset X and type is the highest byte of the lower word.
        -- Or, if TypeApi.Type directly points to the byte:
        local typeEnumVal = gg.getValues({{address = Il2CppType_ptr + self.Type, flags = gg.TYPE_BYTE}})[1].value
        return typeEnumVal & 0xFF -- Ensure it's just the byte value
    end
}

return TypeApi
end)
__bundle_register("il2cppstruct.metadataRegistration", function(require, _LOADED, __bundle_register, __bundle_modules)
local Searcher = require("utils.universalsearcher")

---@class MetadataRegistrationApi
---@field metadataRegistration number -- Pointer to Il2CppMetadataRegistration struct
---@field types number -- Offset of Il2CppType** types within Il2CppMetadataRegistration
local MetadataRegistrationApi = {


    ---@param self MetadataRegistrationApi
    ---@param typeIndex number -- Index into the types array
    ---@return number -- Pointer to an Il2CppType struct (Il2CppType*)
    GetIl2CppTypeFromIndex = function(self, typeIndex)
        if not self.metadataRegistration or self.metadataRegistration == 0 then
            self:FindMetadataRegistration()
            if not self.metadataRegistration or self.metadataRegistration == 0 then
                -- gg.print("Error: Il2CppMetadataRegistration not found.")
                return 0 -- Return 0 if still not found
            end
        end
        
        -- self.types is the offset of Il2CppType** types within Il2CppMetadataRegistration struct
        local typesArrayPointer = gg.getValues({{
            address = self.metadataRegistration + self.types, 
            flags = Il2cpp.MainType -- This reads the Il2CppType** itself
        }})[1].value
        
        if typesArrayPointer == 0 then 
            -- gg.print("Error: typesArrayPointer in Il2CppMetadataRegistration is null.")
            return 0 
        end
        typesArrayPointer = Il2cpp.FixValue(typesArrayPointer)

        -- Now, typesArrayPointer is Il2CppType**. We need to get the Il2CppType* at the given index.
        local il2cppTypePtr = gg.getValues({{
            address = typesArrayPointer + (Il2cpp.pointSize * typeIndex), 
            flags = Il2cpp.MainType -- Reads the Il2CppType* from the array
        }})[1].value
        
        return Il2cpp.FixValue(il2cppTypePtr)
    end,


    ---@param self MetadataRegistrationApi
    ---@return void
    FindMetadataRegistration = function(self)
        -- This function should find the address of the global Il2CppMetadataRegistration instance.
        -- The Searcher.Il2CppMetadataRegistration() is supposed to do this.
        self.metadataRegistration = Searcher.Il2CppMetadataRegistration()
        if self.metadataRegistration == 0 then
            -- gg.print("Warning: Searcher.Il2CppMetadataRegistration() returned 0.")
        end
    end
}

return MetadataRegistrationApi
end)
__bundle_register("utils.universalsearcher", function(require, _LOADED, __bundle_register, __bundle_modules)
local AndroidInfo = require("utils.androidinfo")

---@class Searcher
local Searcher = {
    searchWord = ":EnsureCapacity", -- A common string in global-metadata.dat

    ---@param self Searcher
    ---@return number, number -- startAddress, endAddress of global-metadata.dat
    FindGlobalMetaData = function(self)
        gg.clearResults()
        gg.setRanges(gg.REGION_C_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_C_BSS | gg.REGION_C_DATA | gg.REGION_OTHER)
        
        local metadataRanges = gg.getRangesList('global-metadata.dat')
        if self:IsValidData(metadataRanges) then
            -- If multiple ranges, we might need to find the one containing the searchWord
            -- For simplicity, assume the first one is relevant or they are contiguous.
            -- A more robust way would be to find the range containing a known signature.
            if #metadataRanges > 0 then
                return metadataRanges[1].start, metadataRanges[#metadataRanges]['end'] -- Use start of first and end of last
            end
        end
        
        -- Fallback if not found by name or IsValidData fails
        -- gg.print("global-metadata.dat not found by name or invalid. Falling back to searchWord scan.")
        gg.clearResults()
        gg.searchNumber(self.searchWord, gg.TYPE_BYTE) -- Search for the string bytes
        gg.refineNumber(self.searchWord:sub(1, 2), gg.TYPE_BYTE) -- Refine with first few bytes

        local ensureCapacityAddresses = gg.getResults(gg.getResultsCount())
        gg.clearResults()

        if #ensureCapacityAddresses > 0 then
            -- Find the memory range containing this string.
            local foundAddress = ensureCapacityAddresses[1].address -- Take the first found address
            for _, range in ipairs(gg.getRangesList()) do
                if (range.state == 'Ca' or range.state == 'A' or range.state == 'Cd' or range.state == 'Cb' or range.state == 'Ch' or range.state == 'O') then
                    if (Il2cpp.FixValue(range.start) <= Il2cpp.FixValue(foundAddress) and Il2cpp.FixValue(foundAddress) < Il2cpp.FixValue(range['end'])) then
                        -- gg.print("Found global-metadata.dat fallback range: " .. range.name)
                        return Il2cpp.FixValue(range.start), Il2cpp.FixValue(range['end'])
                    end
                end
            end
        end
        
        -- gg.print("Error: Could not find global-metadata.dat")
        return 0, 0 -- Indicate failure
    end,

    ---@param self Searcher
    ---@param metadataRanges table -- Table of range objects from gg.getRangesList
    ---@return boolean
    IsValidData = function(self, metadataRanges)
        if not metadataRanges or #metadataRanges == 0 then
            return false
        end
        -- Check if searchWord exists within any of these ranges
        for _, range in ipairs(metadataRanges) do
            if range.start and range['end'] then
                 gg.searchNumber(self.searchWord, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, range.start, range['end'])
                 if gg.getResultsCount() > 0 then
                     gg.clearResults()
                     return true
                 end
                 gg.clearResults()
            end
        end
        return false
    end,

    ---@return number, number -- startAddress, endAddress of executable libil2cpp.so range
    FindIl2cpp = function()
        local il2cppRanges = gg.getRangesList('libil2cpp.so')
        local executableRanges = {}

        if #il2cppRanges == 0 then
            -- gg.print("libil2cpp.so not found by name. Trying split_config search...")
            il2cppRanges = gg.getRangesList('split_config.') -- For split APKs
            gg.setRanges(gg.REGION_CODE_APP) -- Search in app code regions
            for _, range in ipairs(il2cppRanges) do
                if range.state == 'Xa' then -- Executable and Anonymous (typical for loaded libs)
                    -- Further check if this range actually contains il2cpp code, e.g., by a signature
                    gg.searchNumber(':il2cpp', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, range.start, range['end'])
                    if (gg.getResultsCount() > 0) then
                        table.insert(executableRanges, range)
                        gg.clearResults()
                    end
                end
            end
        else
            for _, range in ipairs(il2cppRanges) do
                -- Check for executable flags (e.g., 'x' in type string like 'r-xp') or state 'Xa'
                if (range.type and string.find(range.type, "x")) or range.state == "Xa" then
                    table.insert(executableRanges, range)
                end
            end
        end       
        
        if #executableRanges > 0 then
            -- Typically, the first executable range is the .text section.
            -- If multiple, could be .text, .plt, etc. We need the main code segment.
            -- Sorting by start address and taking the first one is a common heuristic.
            table.sort(executableRanges, function(a,b) return a.start < b.start end)
            -- It's also common for libil2cpp to be one large executable segment.
            -- Using start of first and end of last if they seem contiguous or part of the same library.
            return executableRanges[1].start, executableRanges[#executableRanges]['end']
        end

        -- gg.print("Error: Could not find executable range for libil2cpp.so")
        return 0, 0 -- Indicate failure
    end,

    ---@return number -- Pointer to Il2CppMetadataRegistration struct, or 0 if not found
    Il2CppMetadataRegistration = function()
        gg.clearResults()
        -- Il2CppMetadataRegistration is a global struct, usually in .data or .bss of libil2cpp.so,
        -- or in a data segment related to global-metadata.
        gg.setRanges(gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_ANONYMOUS) -- Focus on data regions

        if Il2cpp.globalMetadataStart == 0 then 
            -- gg.print("Warning: Il2cpp.globalMetadataStart is 0, cannot reliably find Il2CppMetadataRegistration via globalMetadataStart pointer.")
            -- Potentially try another method if this happens, e.g. signature scanning if desperate.
            return 0
        end

        -- Search for pointers to Il2cpp.globalMetadataStart.
        -- Il2CppMetadataRegistration contains a field 'metadataBytes' which points to global-metadata.dat start.
        -- The offset of 'metadataBytes' in Il2CppMetadataRegistration can vary by version (e.g., 24, 28, 32 bytes).
        -- Let's assume a few common offsets for `metadataBytes` from the start of Il2CppMetadataRegistration.
        local possibleOffsetsOfMetadataBytesField = {
            (AndroidInfo.platform and 0x18 or 0xC), -- Example for v21/v22 (guess)
            (AndroidInfo.platform and 0x20 or 0x10), -- Example for v24+ (guess)
            (AndroidInfo.platform and 0x28 or 0x14)  -- Another guess
        } 

        gg.searchNumber(string.format("%Xh", Il2cpp.globalMetadataStart), Il2cpp.MainType)
        if gg.getResultsCount() == 0 and AndroidInfo.platform and AndroidInfo.sdk >= 30 then
            -- Search for tagged pointer if on newer Android
            gg.searchNumber(tostring(Il2cpp.globalMetadataStart | 0xB400000000000000), Il2cpp.MainType)
        end
        
        local pointersToGlobalMetadata = gg.getResults(gg.getResultsCount())
        gg.clearResults()

        if #pointersToGlobalMetadata > 0 then
            for _, ptrInfo in ipairs(pointersToGlobalMetadata) do
                for _, offset in ipairs(possibleOffsetsOfMetadataBytesField) do
                    local potentialRegAddress = ptrInfo.address - offset
                    -- Validate if potentialRegAddress is plausible for Il2CppMetadataRegistration
                    -- e.g., check other fields like 'types' pointer.
                    -- For now, we take the first plausible one.
                    -- A more robust check would be to read multiple fields from potentialRegAddress
                    -- and see if they look like valid pointers/counts.
                    
                    -- Example validation: Read typesCount (often at offset 0 or 4)
                    -- local typesCount = gg.getValues({{address = potentialRegAddress, flags = gg.TYPE_DWORD}})[1].value
                    -- if typesCount > 0 and typesCount < 100000 then -- Plausible range for types count
                         return Il2cpp.FixValue(potentialRegAddress)
                    -- end
                end
            end
        end
        
        -- Fallback from original logic (less reliable if offsets are wrong):
        -- This part of original logic was trying to find s_GlobalMetadata by differences in pointers.
        -- It's very specific and might not be universally applicable.
        -- For now, returning 0 if the direct search with assumed offsets fails.
        -- gg.print("Warning: Could not find Il2CppMetadataRegistration via known field offsets.")
        return 0
    end
}

return Searcher

end)
__bundle_register("utils.patchapi", function(require, _LOADED, __bundle_register, __bundle_modules)
---@class Patch
---@field oldBytes table -- Stores original byte values { {address=..., value=..., flags=...}, ... }
---@field newBytes table -- Stores new byte values     { {address=..., value=..., flags=...}, ... }
---@field Create fun(self : Patch, patchCode : table) : Patch
---@field Patch fun(self : Patch) : void
---@field Undo fun(self : Patch) : void
local PatchApi = {

    ---@param self Patch
    ---@param patchCode table -- Table of {address, value, flags} for the new bytes
    ---@return Patch
    Create = function(self, patchCode)
        if not patchCode or type(patchCode) ~= "table" or #patchCode == 0 then
            -- gg.print("Error: Invalid patchCode provided to PatchApi:Create.")
            return setmetatable({newBytes = {}, oldBytes = {}}, {__index = self}) -- Return an empty patch
        end

        -- Read the original bytes before creating the patch object
        local originalBytes = {}
        local addressesToRead = {}
        for _, item in ipairs(patchCode) do
            if item.address and item.flags then
                table.insert(addressesToRead, {address = item.address, flags = item.flags})
            else
                -- gg.print("Warning: Invalid item in patchCode for PatchApi:Create - missing address or flags.")
            end
        end
        
        if #addressesToRead > 0 then
            originalBytes = gg.getValues(addressesToRead)
            if not originalBytes then originalBytes = {} end -- Ensure it's a table
        end

        return setmetatable({
            newBytes = patchCode,
            oldBytes = originalBytes
        },
        {
            __index = self,
        })
    end,
    
    ---@param self Patch
    Patch = function(self)
        if self.newBytes and #self.newBytes > 0 then
            local success = gg.setValues(self.newBytes)
            if not success then
                -- gg.print("Error: Failed to apply patch with gg.setValues.")
                -- Optionally, try to revert if some bytes were set? Complex.
            end
        else
            -- gg.print("Warning: No new bytes to patch in PatchApi:Patch.")
        end 
    end,

    ---@param self Patch
    Undo = function(self)
        if self.oldBytes and #self.oldBytes > 0 then
            local success = gg.setValues(self.oldBytes)
            if not success then
                -- gg.print("Error: Failed to undo patch with gg.setValues.")
            end
        else
            -- gg.print("Warning: No old bytes to restore in PatchApi:Undo (patch might not have been created properly or already undone).")
        end
    end,
}

return PatchApi
end)
__bundle_register("utils.version", function(require, _LOADED, __bundle_register, __bundle_modules)
local semver = require("semver.semver")

---@class VersionEngine
local VersionEngine = {
    ConstSemVer = {
        ['2018_3'] = semver(2018, 3, 0), -- Added patch version for proper semver
        ['2019_4_21'] = semver(2019, 4, 21),
        ['2019_4_15'] = semver(2019, 4, 15),
        ['2019_3_7'] = semver(2019, 3, 7),
        ['2020_2_4'] = semver(2020, 2, 4),
        ['2020_2'] = semver(2020, 2, 0),
        ['2020_1_11'] = semver(2020, 1, 11),
        ['2021_2'] = semver(2021, 2, 0)   
    },
    Year = {
        [2017] = function(self, unityVersion)
            return 24 -- Default for 2017
        end,
        ---@param self VersionEngine
        [2018] = function(self, unityVersion)
            return (not (unityVersion < self.ConstSemVer['2018_3'])) and 24.1 or 24
        end,
        ---@param self VersionEngine
        [2019] = function(self, unityVersion)
            local version = 24.2 -- Default for 2019
            if not (unityVersion < self.ConstSemVer['2019_4_21']) then
                version = 24.5
            elseif not (unityVersion < self.ConstSemVer['2019_4_15']) then
                version = 24.4
            elseif not (unityVersion < self.ConstSemVer['2019_3_7']) then
                version = 24.3
            end
            return version
        end,
        ---@param self VersionEngine
        [2020] = function(self, unityVersion)
            local version = 24.3 -- Default for early 2020
            if not (unityVersion < self.ConstSemVer['2020_2_4']) then
                version = 27.1
            elseif not (unityVersion < self.ConstSemVer['2020_2']) then
                version = 27
            elseif not (unityVersion < self.ConstSemVer['2020_1_11']) then
                version = 24.4
            end
            return version
        end,
        ---@param self VersionEngine
        [2021] = function(self, unityVersion)
            return (not (unityVersion < self.ConstSemVer['2021_2'])) and 29 or 27.2 
        end,
        [2022] = function(self, unityVersion)
            return 29 -- Default for 2022+
        end,
        [2023] = function(self, unityVersion) -- Added for future
            return 29 
        end,
    },
    ---@return number -- Address of Unity version string, or 0 if not found
    GetUnityVersionStringAddress = function() -- Renamed for clarity
        gg.setRanges(gg.REGION_ANONYMOUS) -- Unity version string is often in anonymous read-only memory
        gg.clearResults()
        -- Search for a pattern like "YYYY.M.XfX" or "YYYY.M.XpX"
        -- Example: "2020.3.15f1"
        -- Hex for "202": 32h;30h;32h
        -- Hex for ".": 2Eh
        -- This is a simplified search pattern for "202X.Y.Z"
        gg.searchNumber("32h;30h;32h;??h;2Eh;??h;2Eh", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, nil, nil, 1)
        local results = gg.getResults(10) -- Get a few results
        gg.clearResults()

        for _, res in ipairs(results) do
            local potentialVersionString = Il2cpp.Utf8ToString(res.address, 30) -- Read a decent length
            if potentialVersionString and string.match(potentialVersionString, "^%d%d%d%d%.%d+%.%d+[fpb%d]*") then
                return res.address -- Found a plausible version string
            end
        end
        return 0 -- Not found
    end,

    ---@param versionAddress number -- Address of the Unity version string
    ---@return number, number, number -- major, minor, patch components
    ReadUnityVersionComponents = function(versionAddress) -- Renamed for clarity
        if versionAddress == 0 then return 0,0,0 end
        local versionName = Il2cpp.Utf8ToString(versionAddress, 30) -- Read up to 30 chars
        if not versionName then return 0,0,0 end
        
        local major, minor, patch = string.match(versionName, "(%d+)%.(%d+)%.(%d+)")
        if major and minor and patch then
            return tonumber(major), tonumber(minor), tonumber(patch)
        end
        return 0,0,0 -- Failed to parse
    end,

    ---@param self VersionEngine
    ---@param version? number -- Predefined Il2Cpp version (e.g., 24, 27, 29)
    ---@param globalMetadataHeader number -- Address of global-metadata.dat header
    ChooseVersion = function(self, version, globalMetadataHeader)
        if not version then
            local unityVersionStrAddr = self.GetUnityVersionStringAddress()
            if unityVersionStrAddr == 0 then
                -- Fallback to reading version from global-metadata header if string not found
                -- This version in metadata header is often the Il2Cpp version, not Unity editor version.
                local val = gg.getValues({{address = globalMetadataHeader + 0x4, flags = gg.TYPE_DWORD}})[1]
                version = val and val.value
                if not version then 
                    -- gg.print("Error: Could not determine Il2Cpp version automatically. Defaulting to 29.")
                    version = 29 -- Default to a recent version if all else fails
                end
            else
                local major, minor, patch = self.ReadUnityVersionComponents(unityVersionStrAddr)
                if major == 0 then -- Parsing failed
                    -- gg.print("Warning: Failed to parse Unity version string. Reading from metadata header.")
                    local val = gg.getValues({{address = globalMetadataHeader + 0x4, flags = gg.TYPE_DWORD}})[1]
                    version = val and val.value or 29
                else
                    local unityVersion = semver(major, minor, patch)
                    local yearHandler = self.Year[unityVersion.major]
                    if type(yearHandler) == 'function' then
                        version = yearHandler(self, unityVersion)
                    else
                        -- gg.print("Warning: No specific version logic for Unity major version " .. unityVersion.major .. ". Defaulting to 29.")
                        version = 29 -- Default for unhandled years
                    end
                end
            end
        end
        
        ---@type Il2cppApi
        local api = Il2CppConst[version]
        if not api then
            -- gg.print("Error: Il2Cpp API constants not found for determined version " .. tostring(version) .. ". Defaulting to version 29.")
            api = Il2CppConst[29] -- Fallback to a known recent version
            version = 29 -- Ensure version variable matches the fallback
            if not api then error("Critical Error: Default Il2Cpp API constants (version 29) are missing.") end
        end

        -- Apply API offsets from the selected version
        Il2cpp.FieldApi.Offset = api.FieldApiOffset
        Il2cpp.FieldApi.Type = api.FieldApiType
        Il2cpp.FieldApi.ClassOffset = api.FieldApiClassOffset

        Il2cpp.ClassApi.NameOffset = api.ClassApiNameOffset
        Il2cpp.ClassApi.MethodsStep = api.ClassApiMethodsStep
        Il2cpp.ClassApi.CountMethods = api.ClassApiCountMethods
        Il2cpp.ClassApi.MethodsLink = api.ClassApiMethodsLink
        Il2cpp.ClassApi.FieldsLink = api.ClassApiFieldsLink
        Il2cpp.ClassApi.FieldsStep = api.ClassApiFieldsStep
        Il2cpp.ClassApi.CountFields = api.ClassApiCountFields
        Il2cpp.ClassApi.ParentOffset = api.ClassApiParentOffset
        Il2cpp.ClassApi.NameSpaceOffset = api.ClassApiNameSpaceOffset
        Il2cpp.ClassApi.StaticFieldDataOffset = api.ClassApiStaticFieldDataOffset
        Il2cpp.ClassApi.EnumType = api.ClassApiEnumType
        Il2cpp.ClassApi.EnumRsh = api.ClassApiEnumRsh
        Il2cpp.ClassApi.TypeMetadataHandle = api.ClassApiTypeMetadataHandle
        Il2cpp.ClassApi.InstanceSize = api.ClassApiInstanceSize
        Il2cpp.ClassApi.Token = api.ClassApiToken

        Il2cpp.MethodsApi.ClassOffset = api.MethodsApiClassOffset
        Il2cpp.MethodsApi.NameOffset = api.MethodsApiNameOffset
        Il2cpp.MethodsApi.ParamCount = api.MethodsApiParamCount
        Il2cpp.MethodsApi.ReturnType = api.MethodsApiReturnType
        Il2cpp.MethodsApi.Flags = api.MethodsApiFlags

        Il2cpp.GlobalMetadataApi.typeDefinitionsSize = api.typeDefinitionsSize
        Il2cpp.GlobalMetadataApi.version = version -- Store the determined Il2Cpp version

        -- Read offsets from globalMetadataHeader
        if globalMetadataHeader ~= 0 then
            local consts = gg.getValues({
                {address = globalMetadataHeader + api.typeDefinitionsOffset, flags = gg.TYPE_DWORD},
                {address = globalMetadataHeader + api.stringOffset, flags = gg.TYPE_DWORD},
                {address = globalMetadataHeader + api.fieldDefaultValuesOffset, flags = gg.TYPE_DWORD},
                {address = globalMetadataHeader + api.fieldDefaultValuesSize, flags = gg.TYPE_DWORD},
                {address = globalMetadataHeader + api.fieldAndParameterDefaultValueDataOffset, flags = gg.TYPE_DWORD}
            })
            if consts and consts[1] then -- Check if read was successful
                Il2cpp.GlobalMetadataApi.typeDefinitionsOffset = consts[1].value
                Il2cpp.GlobalMetadataApi.stringOffset = consts[2].value
                Il2cpp.GlobalMetadataApi.fieldDefaultValuesOffset = consts[3].value
                Il2cpp.GlobalMetadataApi.fieldDefaultValuesSize = consts[4].value
                Il2cpp.GlobalMetadataApi.fieldAndParameterDefaultValueDataOffset = consts[5].value
            else
                -- gg.print("Warning: Failed to read offsets from globalMetadataHeader. Using defaults or zeros.")
                -- Set to 0 or default if read fails, to prevent errors with nil values.
                Il2cpp.GlobalMetadataApi.typeDefinitionsOffset = 0
                Il2cpp.GlobalMetadataApi.stringOffset = 0
                Il2cpp.GlobalMetadataApi.fieldDefaultValuesOffset = 0
                Il2cpp.GlobalMetadataApi.fieldDefaultValuesSize = 0
                Il2cpp.GlobalMetadataApi.fieldAndParameterDefaultValueDataOffset = 0
            end
        else
             -- gg.print("Warning: globalMetadataHeader is 0. Metadata offsets will be 0.")
             Il2cpp.GlobalMetadataApi.typeDefinitionsOffset = 0
             Il2cpp.GlobalMetadataApi.stringOffset = 0
             Il2cpp.GlobalMetadataApi.fieldDefaultValuesOffset = 0
             Il2cpp.GlobalMetadataApi.fieldDefaultValuesSize = 0
             Il2cpp.GlobalMetadataApi.fieldAndParameterDefaultValueDataOffset = 0
        end


        Il2cpp.TypeApi.Type = api.TypeApiType -- This is likely an offset within Il2CppType struct

        Il2cpp.Il2CppTypeDefinitionApi.fieldStart = api.Il2CppTypeDefinitionApifieldStart

        Il2cpp.MetadataRegistrationApi.types = api.MetadataRegistrationApitypes
    end,
}

return VersionEngine
end)
__bundle_register("semver.semver", function(require, _LOADED, __bundle_register, __bundle_modules)
-- SemVer.lua (Semantic Versioning for Lua)
-- Copyright (c) 2015 Enrique Garca Cota
-- MIT License
-- https://github.com/kikito/semver.lua
-- Version 1.2.1 (Bundled)

local semver = {
  _VERSION     = '1.2.1',
  _DESCRIPTION = 'semver for Lua',
  _URL         = 'https://github.com/kikito/semver.lua',
  _LICENSE     = [[
    MIT LICENSE
    Copyright (c) 2015 Enrique Garca Cota
    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
}

local function checkPositiveInteger(number, name)
  assert(type(number) == 'number' and number >= 0, name .. ' must be a valid positive number')
  assert(math.floor(number) == number, name .. ' must be an integer')
end

local function present(value)
  return value and value ~= ''
end

-- splitByDot("a.bbc.d") == {"a", "bbc", "d"}
local function splitByDot(str)
  str = str or ""
  local t, count = {}, 0
  for part in str:gmatch("([^%.]+)") do -- Changed gsub to gmatch for clarity
    count = count + 1
    t[count] = part
  end
  return t
end

local function parsePrereleaseAndBuildWithSign(str)
  local prereleaseWithSign, buildWithSign = str:match("^(-[^+]+)(%+.+)$") -- Corrected pattern
  if not (prereleaseWithSign and buildWithSign) then
    prereleaseWithSign = str:match("^(-.+)$")
    buildWithSign      = str:match("^(%+.+)$") -- Corrected pattern
  end
  -- Allow only one or the other, or both in specific order
  if not (prereleaseWithSign or buildWithSign) and #str > 0 then
      assert(false, ("The parameter %q must begin with + or - to denote a prerelease or a build, or be empty."):format(str))
  end
  return prereleaseWithSign, buildWithSign
end

local function parsePrerelease(prereleaseWithSign)
  if prereleaseWithSign then
    local prerelease = prereleaseWithSign:match("^-(%w[%.%w-]*)$")
    assert(prerelease, ("The prerelease %q is not a hyphen followed by alphanumerics, dots and hyphens"):format(prereleaseWithSign))
    return prerelease
  end
end

local function parseBuild(buildWithSign)
  if buildWithSign then
    local build = buildWithSign:match("^%+(%w[%.%w-]*)$")
    assert(build, ("The build %q is not a + sign followed by alphanumerics, dots and hyphens"):format(buildWithSign))
    return build
  end
end

local function parsePrereleaseAndBuild(str)
  if not present(str) then return nil, nil end

  local prereleaseWithSign, buildWithSign = parsePrereleaseAndBuildWithSign(str)

  local prerelease = parsePrerelease(prereleaseWithSign)
  local build = parseBuild(buildWithSign)

  return prerelease, build
end

local function parseVersion(str)
  local sMajor, sMinor, sPatch, sPrereleaseAndBuild = str:match("^(%d+)%.?(%d*)%.?(%d*)(.*)$") -- Made sPrereleaseAndBuild capture rest
  assert(type(sMajor) == 'string', ("Could not extract version number(s) from %q"):format(str))
  
  local major = tonumber(sMajor)
  local minor = tonumber(sMinor)
  local patch = tonumber(sPatch)
  
  local prerelease, build = parsePrereleaseAndBuild(sPrereleaseAndBuild)
  return major, minor, patch, prerelease, build
end


-- return 0 if a == b, -1 if a < b, and 1 if a > b
local function compare(a,b)
  return a == b and 0 or (a < b and -1 or 1) -- Simplified
end

local function compareIds(myId, otherId)
  if myId == otherId then return  0
  elseif not myId    then return -1 -- No identifier is smaller than an existing one (for prerelease)
  elseif not otherId then return  1
  end

  local selfNumber, otherNumber = tonumber(myId), tonumber(otherId)

  if selfNumber and otherNumber then -- numerical comparison
    return compare(selfNumber, otherNumber)
  -- numericals are always smaller than alphanums
  elseif selfNumber then
    return -1
  elseif otherNumber then
    return 1
  else
    return compare(myId, otherId) -- alphanumerical comparison
  end
end

local function smallerIdList(myIds, otherIds)
  local maxLen = math.max(#myIds, #otherIds)
  local comparison

  for i=1, maxLen do
    comparison = compareIds(myIds[i], otherIds[i])
    if comparison ~= 0 then
      return comparison == -1
    end
    -- if comparison == 0, continue loop
  end
  -- If all common identifiers are equal, the one with fewer identifiers is smaller
  -- This rule is for prerelease: 1.0.0-alpha < 1.0.0-alpha.1
  return #myIds < #otherIds 
end

local function smallerPrerelease(mine, other)
  if mine == other then return false end -- Equal prereleases are not smaller
  if not mine then return false end -- A version with no prerelease is > a version with prerelease
  if not other then return true end -- A version with prerelease is < a version with no prerelease

  return smallerIdList(splitByDot(mine), splitByDot(other))
end

local methods = {}

function methods:nextMajor()
  return semver(self.major + 1, 0, 0)
end
function methods:nextMinor()
  return semver(self.major, self.minor + 1, 0)
end
function methods:nextPatch()
  return semver(self.major, self.minor, self.patch + 1, nil, self.build) -- Keep build if nextPatch
end

local mt = { __index = methods }
function mt:__eq(other)
  if type(other) ~= "table" or getmetatable(other) ~= mt then return false end
  return self.major == other.major and
         self.minor == other.minor and
         self.patch == other.patch and
         self.prerelease == other.prerelease
         -- notice that build is ignored for precedence in semver 2.0.0
end
function mt:__lt(other)
  if type(other) ~= "table" or getmetatable(other) ~= mt then 
      error("Cannot compare semver with " .. type(other))
  end
  if self.major ~= other.major then return self.major < other.major end
  if self.minor ~= other.minor then return self.minor < other.minor end
  if self.patch ~= other.patch then return self.patch < other.patch end
  -- At this point, major, minor, patch are equal. Compare prereleases.
  -- A version with a prerelease is lower than one without.
  if self.prerelease and not other.prerelease then return true end
  if not self.prerelease and other.prerelease then return false end
  if self.prerelease and other.prerelease then
      return smallerPrerelease(self.prerelease, other.prerelease)
  end
  return false -- They are equal in terms of precedence (ignoring build)
end

-- This works like the "pessimisstic operator" in Rubygems.
-- if a and b are versions, a ^ b means "b is backwards-compatible with a"
-- in other words, "it's safe to upgrade from a to b"
function mt:__pow(other)
  if type(other) ~= "table" or getmetatable(other) ~= mt then 
      error("Cannot compare semver with " .. type(other))
  end
  if self.major == 0 then -- For 0.y.z, only 0.y.z is compatible with 0.y.z (patch can differ if minor is same)
    return self.major == other.major and self.minor == other.minor and self.patch <= other.patch
  end
  return self.major == other.major and
         self.minor <= other.minor -- and self.patch is implicitly ok if minor increases
end
function mt:__tostring()
  local buffer = { ("%d.%d.%d"):format(self.major, self.minor, self.patch) }
  if self.prerelease then table.insert(buffer, "-" .. self.prerelease) end
  if self.build      then table.insert(buffer, "+" .. self.build) end
  return table.concat(buffer)
end

local function new(major, minor, patch, prerelease, build)
  assert(major, "At least one parameter (string or major version number) is needed")

  if type(major) == 'string' then
    major,minor,patch,prerelease,build = parseVersion(major)
  end
  patch = patch or 0
  minor = minor or 0

  checkPositiveInteger(major, "major")
  checkPositiveInteger(minor, "minor")
  checkPositiveInteger(patch, "patch")

  local result = {major=major, minor=minor, patch=patch, prerelease=prerelease, build=build}
  return setmetatable(result, mt)
end

setmetatable(semver, { __call = function(_, ...) return new(...) end })
semver._VERSION = semver(semver._VERSION) -- Create a semver object for its own version

return semver

end)
__bundle_register("utils.il2cppconst", function(require, _LOADED, __bundle_register, __bundle_modules)
local AndroidInfo = require("utils.androidinfo")

---@type table<number, Il2cppApi>
Il2CppConst = {
    [20] = { -- Unity 5.3 - 5.5
        FieldApiOffset = 0xC, FieldApiType = 0x4, FieldApiClassOffset = 0x8, -- Il2CppFieldDefinition offsets
        ClassApiNameOffset = 0x8, ClassApiMethodsStep = 2, ClassApiCountMethods = 0x9C, ClassApiMethodsLink = 0x3C,
        ClassApiFieldsLink = 0x30, ClassApiFieldsStep = 0x18, ClassApiCountFields = 0xA0, ClassApiParentOffset = 0x24,
        ClassApiNameSpaceOffset = 0xC, ClassApiStaticFieldDataOffset = 0x50, ClassApiEnumType = 0xB0, ClassApiEnumRsh = 2,
        ClassApiTypeMetadataHandle = 0x2C, ClassApiInstanceSize = 0x78, ClassApiToken = 0x98, -- Il2CppClass offsets
        MethodsApiClassOffset = 0xC, MethodsApiNameOffset = 0x8, MethodsApiParamCount = 0x2E, MethodsApiReturnType = 0x10, MethodsApiFlags = 0x28, -- Il2CppMethodDefinition offsets
        typeDefinitionsSize = 0x70, typeDefinitionsOffset = 0xA0, stringOffset = 0x18, -- Il2CppGlobalMetadataHeader offsets
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48, -- Il2CppGlobalMetadataHeader offsets
        TypeApiType = 0x6, -- Offset of type enum in Il2CppType->bits or direct
        Il2CppTypeDefinitionApifieldStart = 0x38, -- Offset of fieldStart in Il2CppTypeDefinition
        MetadataRegistrationApitypes = 0x1C, -- Offset of types in Il2CppMetadataRegistration
    },
    [21] = { -- Unity 5.6
        FieldApiOffset = 0xC, FieldApiType = 0x4, FieldApiClassOffset = 0x8,
        ClassApiNameOffset = 0x8, ClassApiMethodsStep = 2, ClassApiCountMethods = 0x9C, ClassApiMethodsLink = 0x3C,
        ClassApiFieldsLink = 0x30, ClassApiFieldsStep = 0x18, ClassApiCountFields = 0xA0, ClassApiParentOffset = 0x24,
        ClassApiNameSpaceOffset = 0xC, ClassApiStaticFieldDataOffset = 0x50, ClassApiEnumType = 0xB0, ClassApiEnumRsh = 2,
        ClassApiTypeMetadataHandle = 0x2C, ClassApiInstanceSize = 0x78, ClassApiToken = 0x98,
        MethodsApiClassOffset = 0xC, MethodsApiNameOffset = 0x8, MethodsApiParamCount = 0x2E, MethodsApiReturnType = 0x10, MethodsApiFlags = 0x28,
        typeDefinitionsSize = 0x78, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = 0x6, Il2CppTypeDefinitionApifieldStart = 0x40, MetadataRegistrationApitypes = 0x1C,
    },
    [22] = { -- Unity 2017.1, 2017.2
        FieldApiOffset = 0xC, FieldApiType = 0x4, FieldApiClassOffset = 0x8,
        ClassApiNameOffset = 0x8, ClassApiMethodsStep = 2, ClassApiCountMethods = 0x94, ClassApiMethodsLink = 0x3C,
        ClassApiFieldsLink = 0x30, ClassApiFieldsStep = 0x18, ClassApiCountFields = 0x98, ClassApiParentOffset = 0x24,
        ClassApiNameSpaceOffset = 0xC, ClassApiStaticFieldDataOffset = 0x4C, ClassApiEnumType = 0xA9, ClassApiEnumRsh = 2,
        ClassApiTypeMetadataHandle = 0x2C, ClassApiInstanceSize = 0x70, ClassApiToken = 0x90,
        MethodsApiClassOffset = 0xC, MethodsApiNameOffset = 0x8, MethodsApiParamCount = 0x2E, MethodsApiReturnType = 0x10, MethodsApiFlags = 0x28,
        typeDefinitionsSize = 0x78, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = 0x6, Il2CppTypeDefinitionApifieldStart = 0x40, MetadataRegistrationApitypes = 0x1C,
    },
    [23] = { -- Unity 2017.3, 2017.4
        FieldApiOffset = 0xC, FieldApiType = 0x4, FieldApiClassOffset = 0x8,
        ClassApiNameOffset = 0x8, ClassApiMethodsStep = 2, ClassApiCountMethods = 0x9C, ClassApiMethodsLink = 0x40,
        ClassApiFieldsLink = 0x34, ClassApiFieldsStep = 0x18, ClassApiCountFields = 0xA0, ClassApiParentOffset = 0x24,
        ClassApiNameSpaceOffset = 0xC, ClassApiStaticFieldDataOffset = 0x50, ClassApiEnumType = 0xB1, ClassApiEnumRsh = 2,
        ClassApiTypeMetadataHandle = 0x2C, ClassApiInstanceSize = 0x78, ClassApiToken = 0x98,
        MethodsApiClassOffset = 0xC, MethodsApiNameOffset = 0x8, MethodsApiParamCount = 0x2E, MethodsApiReturnType = 0x10, MethodsApiFlags = 0x28,
        typeDefinitionsSize = 104, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = 0x6, Il2CppTypeDefinitionApifieldStart = 0x30, MetadataRegistrationApitypes = 0x1C,
    },
    [24] = { -- Unity 2018.1, 2018.2 (Base for 24.x)
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x114 or 0xAC, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x28 or 0x18, ClassApiCountFields = AndroidInfo.platform and 0x118 or 0xB0, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x129 or 0xC1, ClassApiEnumRsh = 2,
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xF0 or 0x88, ClassApiToken = AndroidInfo.platform and 0x110 or 0xa8,
        MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, MethodsApiParamCount = AndroidInfo.platform and 0x4E or 0x2E, MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10, MethodsApiFlags = AndroidInfo.platform and 0x48 or 0x28,
        typeDefinitionsSize = 104, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x30, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    },
    [24.1] = { -- Unity 2018.3, 2018.4
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x110 or 0xA8, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14, ClassApiCountFields = AndroidInfo.platform and 0x114 or 0xAC, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x126 or 0xBE, ClassApiEnumRsh = 3,
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xEC or 0x84, ClassApiToken = AndroidInfo.platform and 0x10c or 0xa4,
        MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A, MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10, MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
        typeDefinitionsSize = 100, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x2C, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    },
    [24.2] = { -- Unity 2019.1, 2019.2
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x118 or 0xA4, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14, ClassApiCountFields = AndroidInfo.platform and 0x11c or 0xA8, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x12e or 0xBA, ClassApiEnumRsh = 3,
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xF4 or 0x80, ClassApiToken = AndroidInfo.platform and 0x114 or 0xa0,
        MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A, MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10, MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
        typeDefinitionsSize = 92, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x24, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    },
    [24.3] = { -- Unity 2019.3
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x118 or 0xA4, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14, ClassApiCountFields = AndroidInfo.platform and 0x11c or 0xA8, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x12e or 0xBA, ClassApiEnumRsh = 3,
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xF4 or 0x80, ClassApiToken = AndroidInfo.platform and 0x114 or 0xa0,
        MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A, MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10, MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
        typeDefinitionsSize = 92, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x24, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    },
    [24.4] = { -- Unity 2019.4 (LTS) up to 2019.4.14
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x118 or 0xA4, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14, ClassApiCountFields = AndroidInfo.platform and 0x11c or 0xA8, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x12e or 0xBA, ClassApiEnumRsh = 3,
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xF4 or 0x80, ClassApiToken = AndroidInfo.platform and 0x114 or 0xa0,
        MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A, MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10, MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
        typeDefinitionsSize = 92, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x24, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    },
    [24.5] = { -- Unity 2019.4.15+ to 2019.4.20 (approx)
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x118 or 0xA4, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14, ClassApiCountFields = AndroidInfo.platform and 0x11c or 0xA8, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x12e or 0xBA, ClassApiEnumRsh = 3,
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xF4 or 0x80, ClassApiToken = AndroidInfo.platform and 0x114 or 0xa0,
        MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A, MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10, MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
        typeDefinitionsSize = 92, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x24, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    },
    [27] = { -- Unity 2020.1, 2020.2 (before 2020.2.4)
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x11C or 0xA4, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14, ClassApiCountFields = AndroidInfo.platform and 0x120 or 0xA8, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x132 or 0xBA, ClassApiEnumRsh = 3,
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xF8 or 0x80, ClassApiToken = AndroidInfo.platform and 0x118 or 0xa0,
        MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A, MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10, MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
        typeDefinitionsSize = 88, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x20, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    },
    [27.1] = { -- Unity 2020.2.4+ (LTS)
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x11C or 0xA4, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14, ClassApiCountFields = AndroidInfo.platform and 0x120 or 0xA8, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x132 or 0xBA, ClassApiEnumRsh = 3,
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xF8 or 0x80, ClassApiToken = AndroidInfo.platform and 0x118 or 0xa0,
        MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A, MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10, MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
        typeDefinitionsSize = 88, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x20, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    },
    [27.2] = { -- Unity 2021.1
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x11C or 0xA4, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14, ClassApiCountFields = AndroidInfo.platform and 0x120 or 0xA8, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x132 or 0xBA, ClassApiEnumRsh = 2, -- EnumRsh changed for some 2021+
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xF8 or 0x80, ClassApiToken = AndroidInfo.platform and 0x118 or 0xa0,
        MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A, MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10, MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
        typeDefinitionsSize = 88, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x20, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    },
    [29] = { -- Unity 2021.2+, 2022.x, 2023.x (Compressed int default values)
        FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC, FieldApiType = AndroidInfo.platform and 0x8 or 0x4, FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
        ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8, ClassApiMethodsStep = AndroidInfo.platform and 3 or 2, ClassApiCountMethods = AndroidInfo.platform and 0x11C or 0xA4, ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
        ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40, ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14, ClassApiCountFields = AndroidInfo.platform and 0x120 or 0xA8, ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
        ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC, ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C, ClassApiEnumType = AndroidInfo.platform and 0x132 or 0xBA, ClassApiEnumRsh = 2,
        ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34, ClassApiInstanceSize = AndroidInfo.platform and 0xF8 or 0x80, ClassApiToken = AndroidInfo.platform and 0x118 or 0xa0,
        MethodsApiClassOffset = AndroidInfo.platform and 0x20 or 0x10, MethodsApiNameOffset = AndroidInfo.platform and 0x18 or 0xC, MethodsApiParamCount = AndroidInfo.platform and 0x52 or 0x2E, MethodsApiReturnType = AndroidInfo.platform and 0x28 or 0x14, MethodsApiFlags = AndroidInfo.platform and 0x4C or 0x28,
        typeDefinitionsSize = 88, typeDefinitionsOffset = 0xA0, stringOffset = 0x18,
        fieldDefaultValuesOffset = 0x40, fieldDefaultValuesSize = 0x44, fieldAndParameterDefaultValueDataOffset = 0x48,
        TypeApiType = AndroidInfo.platform and 0xA or 0x6, Il2CppTypeDefinitionApifieldStart = 0x20, MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
    }
}


---@class Il2CppFlags
---@field Method MethodFlags
---@field Field FieldFlags
Il2CppFlags = {
    Method = {
        METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK = 0x0007,
        Access = {
            [0] = "private", -- METHOD_ATTRIBUTE_PRIVATE_SCOPE (CompilerControlled in C#)
            [1] = "private", -- METHOD_ATTRIBUTE_PRIVATE
            [2] = "internal", -- METHOD_ATTRIBUTE_FAM_AND_ASSEM (Family and Assembly)
            [3] = "internal", -- METHOD_ATTRIBUTE_ASSEM (Assembly)
            [4] = "protected", -- METHOD_ATTRIBUTE_FAMILY
            [5] = "protected internal", -- METHOD_ATTRIBUTE_FAM_OR_ASSEM (Family or Assembly)
            [6] = "public", -- METHOD_ATTRIBUTE_PUBLIC
        },
        METHOD_ATTRIBUTE_STATIC = 0x0010,
        METHOD_ATTRIBUTE_ABSTRACT = 0x0400,
        -- Add other flags as needed: FINAL, VIRTUAL, HIDE_BY_SIG, NEW_SLOT, STRICT, SPECIAL_NAME, RT_SPECIAL_NAME
    },
    Field = {
        FIELD_ATTRIBUTE_FIELD_ACCESS_MASK = 0x0007,
        Access = {
            [0] = "private", -- FIELD_ATTRIBUTE_PRIVATE_SCOPE (CompilerControlled in C#)
            [1] = "private", -- FIELD_ATTRIBUTE_PRIVATE
            [2] = "internal", -- FIELD_ATTRIBUTE_FAM_AND_ASSEM
            [3] = "internal", -- FIELD_ATTRIBUTE_ASSEMBLY
            [4] = "protected", -- FIELD_ATTRIBUTE_FAMILY
            [5] = "protected internal", -- FIELD_ATTRIBUTE_FAM_OR_ASSEM
            [6] = "public", -- FIELD_ATTRIBUTE_PUBLIC
        },
        FIELD_ATTRIBUTE_STATIC = 0x0010,
        FIELD_ATTRIBUTE_LITERAL = 0x0040, -- const field
        -- Add other flags: INIT_ONLY, SPECIAL_NAME, RT_SPECIAL_NAME, NOT_SERIALIZED
    }
}
end)

-- The following line ensures that the "GGIl2cpp" module (and thus "il2cpp" which defines the global Il2cpp table)
-- is loaded and initialized. The return value is not strictly needed if the script is run via dofile()
-- and Il2cpp is made global.
__bundle_require("GGIl2cpp")

-- End of Il2cppApi.lua content
-- ###########################################################################
-- Start of Il2CppExplorer (1)g1.lua content
-- https://github.com/HTCheater/Il2CppExplorer
if (explorer == nil or type(explorer) ~= 'table') then
	explorer = {}
end
-- Output debug messages
if explorer.debug == nil then
	explorer.debug = false -- Default to false
end
-- Let people know you are using my framework :D
if (explorer.printAdvert == nil) then
	explorer.printAdvert = true
end
-- Exit if selected process isn't Unity game
if (explorer.exitOnNotUnityGame == nil) then
	explorer.exitOnNotUnityGame = true
end
-- Contains start address of libil2cpp.so once either explorer.getLib or explorer.patchLib or explorer.editFunction was called
local libStart = 0x0 -- Local to this script block
explorer.maxStringLength = 1000
local alphabet = {} -- Local to this script block, for explorer.readString

if explorer.printAdvert then
	print(' Made with Il2CppExplorer by HTCheater (and merged with Il2cppApi)')
end

if gg.getTargetInfo == nil then -- Check if gg environment is available
    print(" GameGuardian environment not detected. Il2CppExplorer might not function.")
    if explorer.exitOnNotUnityGame then os.exit() end
else
    if (explorer.exitOnNotUnityGame and #gg.getRangesList('global-metadata.dat') < 1) then
	    print(' Please, select Unity game')
	    os.exit()
    end
end


-- String utils, feel free to use in your own script.
if not string.startsWith then
    string.startsWith = function(self, str_to_find) -- Renamed str to str_to_find
	    return self:find('^' .. str_to_find, 1, true) ~= nil -- Use plain find
    end
end

if not string.endsWith then
    string.endsWith = function(str, ending)
	    return ending == '' or str:sub(-(#ending)) == ending
    end
end

if not string.toUpper then -- Actually, string.upper is standard. This seems to be for first char.
    string.toUpperFirst = function(str) -- Renamed for clarity
	    return (str:gsub("^(%l)", string.upper))
    end
end

if not string.removeEnd then
    string.removeEnd = function(str, rem)
	    if str:endsWith(rem) then
            return str:sub(1, #str - #rem)
        end
        return str
    end
end

if not string.removeStart then
    string.removeStart = function(str, rem)
	    if str:startsWith(rem) then
            return str:sub(#rem + 1)
        end
        return str
    end
end

local isx64 = gg.getTargetInfo and gg.getTargetInfo().x64
local metadata_ranges = gg.getRangesList and gg.getRangesList('global-metadata.dat') or {}
local TYPE_PTR = isx64 and gg.TYPE_QWORD or gg.TYPE_DWORD

local metadata_file_range -- Single range for metadata file
if #metadata_ranges > 0 then
	metadata_file_range = metadata_ranges[1] -- Use the first range found for global-metadata.dat
end

function explorer.setAllRanges()
    if gg.setRanges then
	    gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_HEAP | gg.REGION_C_ALLOC | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_PPSSPP |
					                 gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_VIDEO | gg.REGION_OTHER |
					                 gg.REGION_BAD | gg.REGION_CODE_APP | gg.REGION_CODE_SYS)
    end
end

-- Check wether the metadata class name pointer is suitable to find instances. Returns boolean.
-- Use it if you know what you are doing
function explorer.isClassPointer(address)
    if not gg.getResults then return false end
	local t = {}
	t[1] = {}
	t[1].address = address - (isx64 and 0x10 or 0x8) -- Potential Il2CppObject->klass pointer
	t[1].flags = TYPE_PTR
	gg.clearResults()
	gg.loadResults(t)
    -- Check if this points to something writable (klass field in Il2CppClass is usually not directly writable by game, but its content might be in writable region)
    -- This check is heuristic. A valid klass pointer points to an Il2CppClass structure.
	local results_klass_ptr = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_WRITABLE) -- Original was POINTER_WRITABLE
	if results_klass_ptr[1] == nil then
		return false
	end

	t[1].address = address - (isx64 and 0x8 or 0x4) -- Potential Il2CppObject->monitor pointer or other field
	t[1].flags = TYPE_PTR
	gg.clearResults()
	gg.loadResults(t)
	local results_monitor_ptr = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_NO) -- Original was POINTER_NO
	if results_monitor_ptr[1] == nil then
		return false
	end

    -- The original logic for the third check:
	-- t[1].address = address + (isx64 and 0x8 or 0x4)
    -- This points into the Il2CppClass structure itself if 'address' is Il2CppClass->image
    -- Il2CppClass->name is often at (isx64 and 0x10 or 0x8)
    -- Il2CppClass->namespaze is often at (isx64 and 0x18 or 0xC)
    -- These point to strings in read-only metadata.
    local namePtrAddr = address + (isx64 and 0x10 or 0x8) -- Assuming 'address' is start of Il2CppClass, this is 'name' field
	t[1].address = namePtrAddr
	t[1].flags = TYPE_PTR
	gg.clearResults()
	gg.loadResults(t)
	local results_name_ptr = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_READ_ONLY)
	if results_name_ptr[1] == nil then
		return false
	end
	return true
end


function explorer.getClassMetadataPtr(classname)
	if type(classname) ~= 'string' then
		explorer.print(' explorer.getClassMetadataPtr: expected string for parameter classname, got ' .. type(classname))
		return 0 -- Return 0 for error, consistent with original
	end
    if not metadata_file_range or not metadata_file_range.start or not metadata_file_range['end'] then
        explorer.print(' explorer.getClassMetadataPtr: global-metadata.dat range not found.')
        return 0
    end

	explorer.setAllRanges() -- May not be needed if metadata_file_range is specific enough
	gg.clearResults()
	local stringBytes = gg.bytes(classname, 'UTF-8')
	if #stringBytes == 0 then return 0 end

	local searchStr = ""
	for k, v in ipairs(stringBytes) do
		searchStr = searchStr .. v .. ";"
	end
	searchStr = searchStr .. "0::" .. (#stringBytes + 1) -- Search for null-terminated string

	gg.searchNumber(searchStr, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, metadata_file_range.start, metadata_file_range['end'], 20) -- Limit results

	if gg.getResultsCount() == 0 then -- Changed from < 2 to == 0
		if explorer.debug then
			print(' explorer.getClassMetadataPtr: can\'t find literal string "' .. classname .. '" in metadata')
		end
		return 0
	end
    -- This found the string literal. We need the Il2CppClass that uses this string for its name.
    -- This is a reverse lookup. The original script's logic for this was complex and potentially flawed.
    -- A proper way is to use the Il2cpp API (if available and initialized from the first file)
    -- Il2cpp.FindClass({{Class = classname}}) would be the way if Il2cpp is set up.
    -- For now, returning the address of the string literal as per original intent for `mPtr`.
	return gg.getResults(1)[1].address -- Return address of the found string literal
end

function explorer.getAllocatedClassPtr(metadataNamePtr)
    if metadataNamePtr == 0 then return 0 end
    -- This function tries to find an Il2CppClass structure in memory whose 'name' field points to metadataNamePtr.
    -- This is a reverse lookup.
	local addr = 0x0
    local classRanges = gg.getRangesList('libc_malloc') -- Il2CppClass structs are often in malloc regions
    if #classRanges == 0 then classRanges = gg.getRangesList('anon') end -- Fallback

	for k, v_range in pairs(classRanges) do
        if v_range.start and v_range['end'] then
		    gg.clearResults()
            -- Search for pointers to metadataNamePtr within this range.
            -- The pointer would be at Il2CppClass_instance + (isx64 and 0x10 or 0x8) (offset of 'name' field)
		    gg.searchNumber(string.format('%Xh', metadataNamePtr), TYPE_PTR, false, gg.SIGN_EQUAL, v_range.start, v_range['end'], 0)

		    local results = gg.getResults(100) -- Limit results for performance
		    gg.clearResults()

		    for i, res in ipairs(results) do
                -- res.address is where the pointer to metadataNamePtr was found.
                -- So, res.address is &Il2CppClass->name.
                -- The start of Il2CppClass is res.address - offset_of_name.
                local potential_Il2CppClass_addr = res.address - (isx64 and 0x10 or 0x8)
			    if explorer.isClassPointer(potential_Il2CppClass_addr) then -- Validate if it looks like an Il2CppClass
				    addr = potential_Il2CppClass_addr
				    break
			    end
		    end
		    if addr > 0 then
			    break
		    end
        end
	end
	if (explorer.debug and (addr == 0)) then
		explorer.print(' explorer.getAllocatedClassPtr: there is no valid Il2CppClass pointer for name at ' .. string.format('%X', metadataNamePtr))
	end
	return addr
end

-- Get instances of class. Returns table with search results or empty table.
function explorer.getInstances(className)
	local mPtr_name_literal = explorer.getClassMetadataPtr(className) -- This gets the address of the string literal "className"
	if ((mPtr_name_literal == 0) or (mPtr_name_literal == nil)) then
		return {}
	end
	local allocPtr_Il2CppClass = explorer.getAllocatedClassPtr(mPtr_name_literal) -- This finds the Il2CppClass struct
	if (allocPtr_Il2CppClass == 0) then
		return {}
	end

    -- Now allocPtr_Il2CppClass is the address of the Il2CppClass structure.
    -- We need to find Il2CppObject instances whose 'klass' field points to allocPtr_Il2CppClass.
	gg.setRanges(gg.REGION_ANONYMOUS | gg.REGION_C_HEAP) -- Instances are usually in heap or anonymous regions
	gg.clearResults()
	
    -- Search for pointers to allocPtr_Il2CppClass. These are the Il2CppObject->klass fields.
	gg.searchNumber(string.format('%Xh', allocPtr_Il2CppClass), TYPE_PTR, false, gg.SIGN_EQUAL, nil, nil, 0)
	
	local results_klass_fields = gg.getResults(100000)
    gg.clearResults()
    local instances = {}

    for _, res_klass_field in ipairs(results_klass_fields) do
        -- res_klass_field.address is &Il2CppObject->klass.
        -- The start of Il2CppObject is res_klass_field.address - offset_of_klass.
        -- Assuming klass is at offset 0 of Il2CppObject (after potential vtable).
        -- For Il2Cpp objects, klass is typically the first field.
        table.insert(instances, { address = res_klass_field.address, flags = TYPE_PTR }) -- This is the address of the object itself
    end

	if ((#instances == 0) and explorer.debug) then
		explorer.print(' explorer.getInstances: there are no instances for the ' .. className .. ', try to load the class first')
	end
	return instances
end


-- Patch libil2cpp.so;
-- patchedBytes is a table which contains patches that can be either a dword number or a string containing opcode
-- or a string containig hex (must start with "h" and contain only 4 bytes each).
function explorer.patchLib(offset, offsetX32, patchedBytes, patchedBytesX32)
	gg.clearResults()
	if libStart == 0 then
		explorer.getLib()
        if libStart == 0 then
            explorer.print(' explorer.patchLib: libil2cpp.so not found. Cannot patch.')
            return
        end
	end
	local patch = {}
	local actualOffset = offset
	local actualPatchedBytes = patchedBytes

	if not isx64 then
		actualPatchedBytes = patchedBytesX32
		actualOffset = offsetX32
	end

	if (actualPatchedBytes == nil or actualOffset == nil) then
		explorer.print(' explorer.patchLib: there is no valid patch for current architecture')
		return
	end

	local currAddress = libStart + actualOffset
	local patchItems = {}
	for k, v in ipairs(actualPatchedBytes) do
		local item = { address = currAddress }
		if type(v) == 'number' then
			item.flags = gg.TYPE_DWORD -- Assuming numbers are DWORDs
			item.value = v
		elseif type(v) == 'string' then
			if v:startsWith('h') then -- Hex string
				item.flags = gg.TYPE_DWORD -- Assuming hex strings represent DWORDs
				item.value = v
			else -- Assembly instruction
                item.flags = gg.TYPE_BYTE_LOCK -- Special flag for assembly
				item.value = (isx64 and '~A8 ' or '~A ') .. v -- Prefix for GG assembly
			end
		else
            explorer.print(' explorer.patchLib: invalid patch byte type: ' .. type(v))
            goto continue_patch_loop
        end
		table.insert(patchItems, item)
		currAddress = currAddress + (item.flags == gg.TYPE_BYTE_LOCK and 4 or item.flags) -- Approx increment, assembly size varies
        ::continue_patch_loop::
	end
    if #patchItems > 0 then
        gg.setValues(patchItems)
    end
end

function explorer.getLibStart()
	return libStart
end

-- Call explorer.getLib in case you need access to libStart
function explorer.getLib()
    if libStart ~= 0 then return end -- Already found

	explorer.setAllRanges()
	local libil2cpp_ranges = gg.getRangesList('libil2cpp.so')
	if libil2cpp_ranges[1] ~= nil then
        for _, r in ipairs(libil2cpp_ranges) do
            if r.isExecutable then -- Prefer executable range
                libStart = r.start
                return
            end
        end
		libStart = libil2cpp_ranges[1].start -- Fallback to first if no executable found by flag
		return
	end

    -- Fallback search if not found by name (more complex and less reliable)
	local ranges = gg.getRangesList('bionic_alloc_small_objects') -- Original search location
    if #ranges == 0 then ranges = gg.getRangesList('linker_alloc') end -- Another common place for ELF headers / path strings
    if #ranges == 0 then ranges = gg.getRangesList(gg.REGION_ANONYMOUS) end -- Broad fallback

	for i, range in pairs(ranges) do
        if range.start and range['end'] then
		    gg.searchNumber('libil2cpp.so', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, range['start'], range['end'], 1) -- Search for string "libil2cpp.so"
		    if gg.getResultsCount() ~= 0 then
			    local str_addr_info = gg.getResults(1)[1]
			    gg.clearResults()
                -- Found path string. Now need to find where this path is used by linker to get base address.
                -- This part is highly OS/linker dependent and complex.
                -- The original script's logic for this was very specific and might not work generally.
                -- A common way is to find ELF header of libil2cpp.so in memory.
                -- For simplicity, if Il2cpp object from first file is available, it might have libStart.
                if Il2cpp and Il2cpp.il2cppStart and Il2cpp.il2cppStart ~= 0 then
                    libStart = Il2cpp.il2cppStart
                    explorer.print(" explorer.getLib: Used Il2cpp.il2cppStart: " .. string.format('%X', libStart))
                    return
                end
                -- If not, this fallback is too unreliable to implement robustly here.
			    break
		    end
        end
	end
	if libStart == 0x0 then
		explorer.print(' explorer.getLib: failed to get libil2cpp.so address automatically.')
        explorer.print(' Consider initializing Il2cppApi first if available, it might find it.')
	end
end

-- Get field value in instance
function explorer.getField(instance, offset, offsetX32, valueType)
	if type(instance) ~= 'table' then
		explorer.print(' explorer.getField: expected table for parameter instance, got ' .. type(instance))
		return nil
	end
	if type(instance.address) ~= 'number' then
		explorer.print(' explorer.getField: expected number for instance.address, got ' .. type(instance.address))
		return nil
	end
	if type(valueType) ~= 'number' then
		explorer.print(' explorer.getField: expected number for valueType, got ' .. type(valueType))
		return nil
	end
	local actualOffset = offset
	if not isx64 then
		actualOffset = offsetX32
	end
	if actualOffset == nil then
		explorer.print(' explorer.getField: offset for this architecture is not specified')
		return nil
	end
	return explorer.readValue(instance.address + actualOffset, valueType)
end

-- Edit field value in instance
function explorer.editField(instance, offset, offsetX32, valueType, value)
	if type(instance) ~= 'table' then
		explorer.print(' explorer.editField: expected table for parameter instance, got ' .. type(instance))
		return
	end
	if type(instance.address) ~= 'number' then
		explorer.print(' explorer.editField: expected number for instance.address, got ' .. type(instance.address))
		return
	end
	if type(valueType) ~= 'number' then
		explorer.print(' explorer.editField: expected number for parameter valueType, got ' .. type(valueType))
		return
	end
	-- Value can be number or string (for hex/assembly in some contexts, but here usually number)
	if type(value) ~= 'number' and type(value) ~= 'string' then 
		explorer.print(' explorer.editField: expected number or string for parameter value, got ' .. type(value))
		return
	end
	local actualOffset = offset
	if not isx64 then
		actualOffset = offsetX32
	end
	if actualOffset == nil then
		explorer.print(' explorer.editField: offset for this architecture is not specified')
		return
	end

	local t = {}
	t[1] = {}
	t[1].address = instance.address + actualOffset
	t[1].flags = valueType
	t[1].value = value
	gg.setValues(t)
end

function explorer.getFunction(className, functionName)
	if type(functionName) ~= 'string' then
		explorer.print(' explorer.getFunction: expected string for parameter functionName, got ' .. type(functionName))
		return nil
	end
	if ((type(className) ~= 'nil') and (type(className) ~= 'string')) then
		explorer.print(' explorer.getFunction: expected string or nil for parameter className, got ' .. type(className))
		return nil
	end

    -- Try using the Il2cppApi if available and initialized
    if Il2cpp and Il2cpp.FindClass and Il2cpp.FindMethods then
        explorer.print(" explorer.getFunction: Attempting to use Il2cppApi...")
        local classInfoResults
        if className then
            classInfoResults = Il2cpp.FindClass({{Class = className, MethodsDump = true}})
            if not classInfoResults or classInfoResults.Error or #classInfoResults == 0 then
                explorer.print(" explorer.getFunction (Il2cppApi): Class '" .. className .. "' not found.")
                return nil
            end
            local classInfo = classInfoResults[1] -- Assuming first result
            local methods = classInfo:GetMethodsWithName(functionName)
            if methods and #methods > 0 then
                local methodInfo = methods[1] -- Take the first match
                local addr = tonumber(methodInfo.AddressInMemory, 16)
                if libStart == 0 then explorer.getLib() end
                if libStart ~= 0 and addr ~= 0 then
                    local offset = addr - libStart
                    explorer.print(' explorer.getFunction (Il2cppApi): offset for ' .. functionName .. ': ' .. string.format('%X', offset))
                    return offset
                else
                    explorer.print(' explorer.getFunction (Il2cppApi): Could not calculate offset for ' .. functionName)
                    return nil
                end
            else
                explorer.print(" explorer.getFunction (Il2cppApi): Method '" .. functionName .. "' not found in class '" .. className .. "'.")
                return nil
            end
        else -- Global function search (less reliable with Il2cppApi without class context)
            local methodResults = Il2cpp.FindMethods({functionName})
            if methodResults and methodResults[1] and not methodResults[1].Error and #methodResults[1] > 0 then
                local methodInfo = methodResults[1][1] -- Take first class, first method
                local addr = tonumber(methodInfo.AddressInMemory, 16)
                if libStart == 0 then explorer.getLib() end
                if libStart ~= 0 and addr ~= 0 then
                    local offset = addr - libStart
                    explorer.print(' explorer.getFunction (Il2cppApi Global): offset for ' .. functionName .. ': ' .. string.format('%X', offset))
                    return offset
                end
            end
            explorer.print(" explorer.getFunction (Il2cppApi Global): Method '" .. functionName .. "' not found globally or error.")
            -- Fall through to original explorer logic if Il2cppApi fails
        end
    end
    explorer.print(" explorer.getFunction: Il2cppApi not used or failed, falling back to original explorer logic...")


	explorer.setAllRanges()
	gg.clearResults()
    if not metadata_file_range then 
        explorer.print(' explorer.getFunction: metadata_file_range not set.')
        return nil 
    end

	local stringBytes = gg.bytes(functionName, 'UTF-8')
	local searchStr = ""
	for k, v in ipairs(stringBytes) do searchStr = searchStr .. v .. ";" end
	searchStr = searchStr .. "0::" .. (#stringBytes + 1)

	gg.searchNumber(searchStr, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, metadata_file_range.start, metadata_file_range['end'], (className == nil) and 50 or nil) -- Limit results
	-- Refine based on actual bytes rather than string search if possible
    -- gg.refineNumber('0; ' .. stringBytes[1], gg.TYPE_BYTE) -- This refine might be too strict or incorrect
	-- gg.refineNumber(stringBytes[1], gg.TYPE_BYTE)

	if gg.getResultsCount() == 0 then
		explorer.print(' Can\'t find function name literal "' .. functionName .. '" in metadata')
		return nil
	end

	local addr_MethodInfo = 0x0 -- This should be Il2CppMethodDefinition*

	for index, result_name_literal in pairs(gg.getResults(gg.getResultsCount())) do -- Iterate all found name literals
        -- result_name_literal.address is the address of the string "functionName" in metadata.
        -- We need to find Il2CppMethodDefinition whose 'name' field points here (or whose nameIndex resolves here).
        local searchRangesForPtrs = gg.getRangesList('libc_malloc') 
        if #searchRangesForPtrs == 0 then searchRangesForPtrs = gg.getRangesList('anon') end

		for k, v_range in pairs(searchRangesForPtrs) do
            if v_range.start and v_range['end'] then
			    gg.clearResults()
                -- Search for pointers to result_name_literal.address.
                -- These pointers would be at Il2CppMethodDefinition_instance + offset_of_name_field.
			    gg.searchNumber(string.format('%Xh', result_name_literal.address), TYPE_PTR, false, gg.SIGN_EQUAL, v_range.start, v_range['end'], 0)

			    local results_name_field_ptr = gg.getResults(50) -- Limit results
			    gg.clearResults()

			    for i, res_name_field in ipairs(results_name_field_ptr) do
                    -- res_name_field.address is &Il2CppMethodDefinition->name.
                    -- The start of Il2CppMethodDefinition is res_name_field.address - offset_of_name_field.
                    -- This offset_of_name_field is MethodsApi.NameOffset from Il2cppApi.
                    local name_offset_in_def = (Il2cpp and Il2cpp.MethodsApi and Il2cpp.MethodsApi.NameOffset) or (isx64 and 0x18 or 0xC) -- Fallback guess
                    local potential_MethodInfo_addr = res_name_field.address - name_offset_in_def
				    
                    if explorer.isFunctionPointer(potential_MethodInfo_addr, className) then -- Validate it
                        -- isFunctionPointer expects potential_MethodInfo_addr to be the start of MethodDefinition.
                        -- And it checks className if provided.
					    addr_MethodInfo = potential_MethodInfo_addr
					    break
				    end
			    end
			    if addr_MethodInfo > 0 then break end
            end
		end
        if addr_MethodInfo > 0 then break end
	end

	if addr_MethodInfo == 0 then
		explorer.print(' explorer.getFunction: there is no valid Il2CppMethodDefinition pointer for ' .. functionName ..
						               ((className == nil) and '' or (' in ' .. className)))
		return nil
	end

    -- Now addr_MethodInfo is Il2CppMethodDefinition*. Get the actual function pointer (methodPointer).
    -- methodPointer is usually at offset 0 of Il2CppMethodDefinition.
    local func_ptr
