--[[
Merged and Improved Il2Cpp API
Combines functionalities from Il2CppExplorer and Il2cppApi.
Removes redundant introductions and aims for a cohesive structure.
]]

-- Global string utility functions from Il2CppExplorer
-- These are defined globally as in the original Il2CppExplorer.lua
if string.startsWith == nil then
	string.startsWith = function(self, str)
		return self:find('^' .. str) ~= nil
	end
end

if string.endsWith == nil then
	string.endsWith = function(str, ending)
		return ending == '' or str:sub(-(#ending)) == ending
	end
end

if string.toUpper == nil then
	string.toUpper = function(str)
		local res = str:gsub('^%l', string.upper)
		return res
	end
end

if string.removeEnd == nil then
	string.removeEnd = function(str, rem)
		return (str:gsub('^(.-)' .. rem .. '$', '%1'))
	end
end

if string.removeStart == nil then
	string.removeStart = function(str, rem)
		return (str:gsub('^' .. rem .. '(.-)$', '%1'))
	end
end

-- Bundler system from Il2cppApi.lua
local __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)
	local loadingPlaceholder = {[{}] = true}
	local register
	local modules = {}
	local require
	local loaded = {}

	register = function(name, body)
		if not modules[name] then
			modules[name] = body
		end
	end

	require = function(name)
		local loadedModule = loaded[name]
		if loadedModule then
			if loadedModule == loadingPlaceholder then
				-- Circular dependency
				-- error('Circular dependency loading "' .. name .. '"')
				return nil -- Or handle error as preferred
			end
		else
			if not modules[name] then
				if not superRequire then
					local identifier = type(name) == 'string' and '\"' .. name .. '\"' or tostring(name)
					error('Tried to require ' .. identifier .. ', but no such module has been registered')
				else
					return superRequire(name)
				end
			end

			loaded[name] = loadingPlaceholder
			loadedModule = modules[name](require, loaded, register, modules)
			loaded[name] = loadedModule
		end
		return loadedModule
	end
	return require, loaded, register, modules
end)(require)


-- Register Il2CppConst (from Il2cppApi.lua)
__bundle_register("utils.il2cppconst", function(require, _LOADED, __bundle_register, __bundle_modules)
	local AndroidInfo = require("utils.androidinfo")

	---@type table<number, Il2cppApi>
	Il2CppConst = {
		[20] = {
			FieldApiOffset = 0xC,
			FieldApiType = 0x4,
			FieldApiClassOffset = 0x8,
			ClassApiNameOffset = 0x8,
			ClassApiMethodsStep = 2,
			ClassApiCountMethods = 0x9C,
			ClassApiMethodsLink = 0x3C,
			ClassApiFieldsLink = 0x30,
			ClassApiFieldsStep = 0x18,
			ClassApiCountFields = 0xA0,
			ClassApiParentOffset = 0x24,
			ClassApiNameSpaceOffset = 0xC,
			ClassApiStaticFieldDataOffset = 0x50,
			ClassApiEnumType = 0xB0,
			ClassApiEnumRsh = 2,
			ClassApiTypeMetadataHandle = 0x2C,
			ClassApiInstanceSize = 0x78,
			ClassApiToken = 0x98,
			MethodsApiClassOffset = 0xC,
			MethodsApiNameOffset = 0x8,
			MethodsApiParamCount = 0x2E,
			MethodsApiReturnType = 0x10,
			MethodsApiFlags = 0x28,
			typeDefinitionsSize = 0x70,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x38,
			MetadataRegistrationApitypes = 0x1C,
		},
		[21] = {
			FieldApiOffset = 0xC,
			FieldApiType = 0x4,
			FieldApiClassOffset = 0x8,
			ClassApiNameOffset = 0x8,
			ClassApiMethodsStep = 2,
			ClassApiCountMethods = 0x9C,
			ClassApiMethodsLink = 0x3C,
			ClassApiFieldsLink = 0x30,
			ClassApiFieldsStep = 0x18,
			ClassApiCountFields = 0xA0,
			ClassApiParentOffset = 0x24,
			ClassApiNameSpaceOffset = 0xC,
			ClassApiStaticFieldDataOffset = 0x50,
			ClassApiEnumType = 0xB0,
			ClassApiEnumRsh = 2,
			ClassApiTypeMetadataHandle = 0x2C,
			ClassApiInstanceSize = 0x78,
			ClassApiToken = 0x98,
			MethodsApiClassOffset = 0xC,
			MethodsApiNameOffset = 0x8,
			MethodsApiParamCount = 0x2E,
			MethodsApiReturnType = 0x10,
			MethodsApiFlags = 0x28,
			typeDefinitionsSize = 0x78,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x40,
			MetadataRegistrationApitypes = 0x1C,
		},
		[22] = {
			FieldApiOffset = 0xC,
			FieldApiType = 0x4,
			FieldApiClassOffset = 0x8,
			ClassApiNameOffset = 0x8,
			ClassApiMethodsStep = 2,
			ClassApiCountMethods = 0x94,
			ClassApiMethodsLink = 0x3C,
			ClassApiFieldsLink = 0x30,
			ClassApiFieldsStep = 0x18,
			ClassApiCountFields = 0x98,
			ClassApiParentOffset = 0x24,
			ClassApiNameSpaceOffset = 0xC,
			ClassApiStaticFieldDataOffset = 0x4C,
			ClassApiEnumType = 0xA9,
			ClassApiEnumRsh = 2,
			ClassApiTypeMetadataHandle = 0x2C,
			ClassApiInstanceSize = 0x70,
			ClassApiToken = 0x90,
			MethodsApiClassOffset = 0xC,
			MethodsApiNameOffset = 0x8,
			MethodsApiParamCount = 0x2E,
			MethodsApiReturnType = 0x10,
			MethodsApiFlags = 0x28,
			typeDefinitionsSize = 0x78,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x40,
			MetadataRegistrationApitypes = 0x1C,
		},
		[23] = {
			FieldApiOffset = 0xC,
			FieldApiType = 0x4,
			FieldApiClassOffset = 0x8,
			ClassApiNameOffset = 0x8,
			ClassApiMethodsStep = 2,
			ClassApiCountMethods = 0x9C,
			ClassApiMethodsLink = 0x40,
			ClassApiFieldsLink = 0x34,
			ClassApiFieldsStep = 0x18,
			ClassApiCountFields = 0xA0,
			ClassApiParentOffset = 0x24,
			ClassApiNameSpaceOffset = 0xC,
			ClassApiStaticFieldDataOffset = 0x50,
			ClassApiEnumType = 0xB1,
			ClassApiEnumRsh = 2,
			ClassApiTypeMetadataHandle = 0x2C,
			ClassApiInstanceSize = 0x78,
			ClassApiToken = 0x98,
			MethodsApiClassOffset = 0xC,
			MethodsApiNameOffset = 0x8,
			MethodsApiParamCount = 0x2E,
			MethodsApiReturnType = 0x10,
			MethodsApiFlags = 0x28,
			typeDefinitionsSize = 104,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x30,
			MetadataRegistrationApitypes = 0x1C,
		},
		[24.1] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x110 or 0xA8,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14,
			ClassApiCountFields = AndroidInfo.platform and 0x114 or 0xAC,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x126 or 0xBE,
			ClassApiEnumRsh = 3,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xEC or 0x84,
			ClassApiToken = AndroidInfo.platform and 0x10c or 0xa4,
			MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A,
			MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
			typeDefinitionsSize = 100,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x2C,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		},
		[24] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x114 or 0xAC,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x28 or 0x18,
			ClassApiCountFields = AndroidInfo.platform and 0x118 or 0xB0,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x129 or 0xC1,
			ClassApiEnumRsh = 2,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xF0 or 0x88,
			ClassApiToken = AndroidInfo.platform and 0x110 or 0xa8,
			MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			MethodsApiParamCount = AndroidInfo.platform and 0x4E or 0x2E,
			MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiFlags = AndroidInfo.platform and 0x48 or 0x28,
			typeDefinitionsSize = 104,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x30,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		},
		[24.2] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x118 or 0xA4,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14,
			ClassApiCountFields = AndroidInfo.platform and 0x11c or 0xA8,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x12e or 0xBA,
			ClassApiEnumRsh = 3,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xF4 or 0x80,
			ClassApiToken = AndroidInfo.platform and 0x114 or 0xa0,
			MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A,
			MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
			typeDefinitionsSize = 92,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x24,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		},
		[24.3] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x118 or 0xA4,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14,
			ClassApiCountFields = AndroidInfo.platform and 0x11c or 0xA8,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x12e or 0xBA,
			ClassApiEnumRsh = 3,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xF4 or 0x80,
			ClassApiToken = AndroidInfo.platform and 0x114 or 0xa0,
			MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A,
			MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
			typeDefinitionsSize = 92,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x24,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		},
		[24.4] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x118 or 0xA4,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14,
			ClassApiCountFields = AndroidInfo.platform and 0x11c or 0xA8,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x12e or 0xBA,
			ClassApiEnumRsh = 3,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xF4 or 0x80,
			ClassApiToken = AndroidInfo.platform and 0x114 or 0xa0,
			MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A,
			MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
			typeDefinitionsSize = 92,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x24,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		},
		[24.5] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x118 or 0xA4,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14,
			ClassApiCountFields = AndroidInfo.platform and 0x11c or 0xA8,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x12e or 0xBA,
			ClassApiEnumRsh = 3,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xF4 or 0x80,
			ClassApiToken = AndroidInfo.platform and 0x114 or 0xa0,
			MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A,
			MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
			typeDefinitionsSize = 92,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x24,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		},
		[27] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x11C or 0xA4,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14,
			ClassApiCountFields = AndroidInfo.platform and 0x120 or 0xA8,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x132 or 0xBA,
			ClassApiEnumRsh = 3,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xF8 or 0x80,
			ClassApiToken = AndroidInfo.platform and 0x118 or 0xa0,
			MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A,
			MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
			typeDefinitionsSize = 88,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x20,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		},
		[27.1] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x11C or 0xA4,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14,
			ClassApiCountFields = AndroidInfo.platform and 0x120 or 0xA8,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x132 or 0xBA,
			ClassApiEnumRsh = 3,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xF8 or 0x80,
			ClassApiToken = AndroidInfo.platform and 0x118 or 0xa0,
			MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A,
			MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
			typeDefinitionsSize = 88,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x20,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		},
		[27.2] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x11C or 0xA4,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14,
			ClassApiCountFields = AndroidInfo.platform and 0x120 or 0xA8,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x132 or 0xBA,
			ClassApiEnumRsh = 2,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xF8 or 0x80,
			ClassApiToken = AndroidInfo.platform and 0x118 or 0xa0,
			MethodsApiClassOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			MethodsApiParamCount = AndroidInfo.platform and 0x4A or 0x2A,
			MethodsApiReturnType = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiFlags = AndroidInfo.platform and 0x44 or 0x24,
			typeDefinitionsSize = 88,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x20,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		},
		[29] = {
			FieldApiOffset = AndroidInfo.platform and 0x18 or 0xC,
			FieldApiType = AndroidInfo.platform and 0x8 or 0x4,
			FieldApiClassOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiNameOffset = AndroidInfo.platform and 0x10 or 0x8,
			ClassApiMethodsStep = AndroidInfo.platform and 3 or 2,
			ClassApiCountMethods = AndroidInfo.platform and 0x11C or 0xA4,
			ClassApiMethodsLink = AndroidInfo.platform and 0x98 or 0x4C,
			ClassApiFieldsLink = AndroidInfo.platform and 0x80 or 0x40,
			ClassApiFieldsStep = AndroidInfo.platform and 0x20 or 0x14,
			ClassApiCountFields = AndroidInfo.platform and 0x120 or 0xA8,
			ClassApiParentOffset = AndroidInfo.platform and 0x58 or 0x2C,
			ClassApiNameSpaceOffset = AndroidInfo.platform and 0x18 or 0xC,
			ClassApiStaticFieldDataOffset = AndroidInfo.platform and 0xB8 or 0x5C,
			ClassApiEnumType = AndroidInfo.platform and 0x132 or 0xBA,
			ClassApiEnumRsh = 2,
			ClassApiTypeMetadataHandle = AndroidInfo.platform and 0x68 or 0x34,
			ClassApiInstanceSize = AndroidInfo.platform and 0xF8 or 0x80,
			ClassApiToken = AndroidInfo.platform and 0x118 or 0xa0,
			MethodsApiClassOffset = AndroidInfo.platform and 0x20 or 0x10,
			MethodsApiNameOffset = AndroidInfo.platform and 0x18 or 0xC,
			MethodsApiParamCount = AndroidInfo.platform and 0x52 or 0x2E,
			MethodsApiReturnType = AndroidInfo.platform and 0x28 or 0x14,
			MethodsApiFlags = AndroidInfo.platform and 0x4C or 0x28,
			typeDefinitionsSize = 88,
			typeDefinitionsOffset = 0xA0,
			stringOffset = 0x18,
			fieldDefaultValuesOffset = 0x40,
			fieldDefaultValuesSize = 0x44,
			fieldAndParameterDefaultValueDataOffset = 0x48,
			TypeApiType = AndroidInfo.platform and 0xA or 0x6,
			Il2CppTypeDefinitionApifieldStart = 0x20,
			MetadataRegistrationApitypes = AndroidInfo.platform and 0x38 or 0x1C,
		}
	}

	---@class Il2CppFlags
	---@field Method MethodFlags
	---@field Field FieldFlags
	Il2CppFlags = {
		Method = {
			METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK = 0x0007,
			Access = {
				"private", -- METHOD_ATTRIBUTE_PRIVATE
				"internal", -- METHOD_ATTRIBUTE_FAM_AND_ASSEM
				"internal", -- METHOD_ATTRIBUTE_ASSEM
				"protected", -- METHOD_ATTRIBUTE_FAMILY
				"protected internal", -- METHOD_ATTRIBUTE_FAM_OR_ASSEM
				"public", -- METHOD_ATTRIBUTE_PUBLIC
			},
			METHOD_ATTRIBUTE_STATIC = 0x0010,
			METHOD_ATTRIBUTE_ABSTRACT = 0x0400,
		},
		Field = {
			FIELD_ATTRIBUTE_FIELD_ACCESS_MASK = 0x0007,
			Access = {
				"private", -- FIELD_ATTRIBUTE_PRIVATE
				"internal", -- FIELD_ATTRIBUTE_FAM_AND_ASSEM
				"internal", -- FIELD_ATTRIBUTE_ASSEMBLY
				"protected", -- FIELD_ATTRIBUTE_FAMILY
				"protected internal", -- FIELD_ATTRIBUTE_FAM_OR_ASSEM
				"public", -- FIELD_ATTRIBUTE_PUBLIC
			},
			FIELD_ATTRIBUTE_STATIC = 0x0010,
			FIELD_ATTRIBUTE_LITERAL = 0x0040,
		}
	}
end)

__bundle_register("utils.androidinfo", function(require, _LOADED, __bundle_register, __bundle_modules)
	local AndroidInfo = {
		platform = gg.getTargetInfo().x64, -- true if x64, false if x32
		sdk = gg.getTargetInfo().targetSdkVersion
	}
	return AndroidInfo
end)

__bundle_register("utils.il2cppmemory", function(require, _LOADED, __bundle_register, __bundle_modules)
	-- Memorizing Il2cpp Search Result
	---@class Il2cppMemory
	---@field Methods table<number | string, MethodMemory>
	---@field Classes table<string | number, ClassMemory>
	---@field Fields table<number | string, FieldInfo[] | ErrorSearch>
	---@field Results table
	---@field Types table<number, string>
	---@field DefaultValues table<number, string | number>
	---@field GetInformaionOfMethod fun(self : Il2cppMemory, searchParam : number | string) : MethodMemory | nil
	---@field SetInformaionOfMethod fun(self : Il2cppMemory, searchParam : string | number, searchResult : MethodMemory) : void
	---@field GetInformationOfClass fun(self : Il2cppMemory, searchParam : string | number) : ClassMemory | nil
	---@field SetInformationOfClass fun(self : Il2cppMemory, searchParam : string | number, searchResult : ClassMemory) : void
	---@field GetInformationOfField fun(self : Il2cppMemory, searchParam : number | string) : FieldInfo[] | nil | ErrorSearch
	---@field SetInformationOfField fun(self : Il2cppMemory, searchParam : string | number, searchResult : FieldInfo[] | ErrorSearch) : void
	---@field GetInformationOfType fun(self : Il2cppMemory, index : number) : string | nil
	---@field SetInformationOfType fun(self : Il2cppMemory, index : number, typeName : string)
	---@field SaveResults fun(self : Il2cppMemory) : void
	---@field ClearSavedResults fun(self : Il2cppMemory) : void
	local Il2cppMemory = {
		Methods = {},
		Classes = {},
		Fields = {},
		DefaultValues = {},
		Results = {},
		Types = {},

		GetInformationOfType = function(self, index)
			return self.Types[index]
		end,

		SetInformationOfType = function(self, index, typeName)
			self.Types[index] = typeName
		end,

		SaveResults = function(self)
			if gg.getResultsCount() > 0 then
				self.Results = gg.getResults(gg.getResultsCount())
			end
		end,

		ClearSavedResults = function(self)
			self.Results = {}
		end,

		GetDefaultValue = function(self, fieldIndex)
			return self.DefaultValues[fieldIndex]
		end,

		SetDefaultValue = function(self, fieldIndex, defaultValue)
			self.DefaultValues[fieldIndex] = defaultValue or "nil"
		end,

		GetInformationOfField = function(self, searchParam)
			return self.Fields[searchParam]
		end,

		SetInformationOfField = function(self, searchParam, searchResult)
			if not searchResult.Error then
				self.Fields[searchParam] = searchResult
			end
		end,

		GetInformaionOfMethod = function(self, searchParam)
			return self.Methods[searchParam]
		end,

		SetInformaionOfMethod = function(self, searchParam, searchResult)
			if not searchResult.Error then
				self.Methods[searchParam] = searchResult
			end
		end,

		GetInformationOfClass = function(self, searchParam)
			return self.Classes[searchParam]
		end,

		SetInformationOfClass = function(self, searchParam, searchResult)
			self.Classes[searchParam] = searchResult
		end,

		ClearMemorize = function(self)
			self.Methods = {}
			self.Classes = {}
			self.Fields = {}
			self.DefaultValues = {}
			self.Results = {}
			self.Types = {}
		end
	}
	return Il2cppMemory
end)

__bundle_register("utils.malloc", function(require, _LOADED, __bundle_register, __bundle_modules)
	local MemoryManager = {
		availableMemory = 0,
		lastAddress = 0,

		NewAlloc = function(self)
			self.lastAddress = gg.allocatePage(gg.PROT_READ | gg.PROT_WRITE)
			self.availableMemory = 4096
		end,
	}

	local M = {
		---@param size number
		MAlloc = function(size)
			local manager = MemoryManager
			if size > manager.availableMemory then
				manager:NewAlloc()
			end
			local address = manager.lastAddress
			manager.availableMemory = manager.availableMemory - size
			manager.lastAddress = manager.lastAddress + size
			return address
		end,
	}
	return M
end)

__bundle_register("utils.patchapi", function(require, _LOADED, __bundle_register, __bundle_modules)
	---@class Patch
	---@field oldBytes table
	---@field newBytes table
	---@field Create fun(self : Patch, patchCode : table) : Patch
	---@field Patch fun(self : Patch) : void
	---@field Undo fun(self : Patch) : void
	local PatchApi = {
		Create = function(self, patchCode)
			return setmetatable({
				newBytes = patchCode,
				oldBytes = gg.getValues(patchCode)
			},
			{
				__index = self,
			})
		end,
		
		Patch = function(self)
			if self.newBytes then
				gg.setValues(self.newBytes)
			end 
		end,

		Undo = function(self)
			if self.oldBytes then
				gg.setValues(self.oldBytes)
			end
		end,
	}
	return PatchApi
end)

__bundle_register("utils.protect", function(require, _LOADED, __bundle_register, __bundle_modules)
	local Protect = {
		ErrorHandler = function(err)
			return {Error = err}
		end,
		Call = function(self, fun, ...) 
			return ({xpcall(fun, self.ErrorHandler, ...)})[2]
		end
	}
	return Protect
end)

__bundle_register("utils.stringutils", function(require, _LOADED, __bundle_register, __bundle_modules)
	---@class StringUtils
	local StringUtils = {
		---@param classInfo ClassInfo
		ClassInfoToDumpCS = function(classInfo)
			local dumpClass = {
				"// ", classInfo.ImageName, "\n",
				"// Namespace: ", classInfo.ClassNameSpace, "\n";

				"class ", classInfo.ClassName, classInfo.Parent and " : " .. classInfo.Parent.ClassName or "", "\n", 
				"{\n"
			}

			if classInfo.Fields and #classInfo.Fields > 0 then
				dumpClass[#dumpClass + 1] = "\n\t// Fields\n"
				for i, v in ipairs(classInfo.Fields) do
					local dumpField = {
						"\t", v.Access, " ", v.IsStatic and "static " or "", v.IsConst and "const " or "", v.Type, " ", v.FieldName, "; // 0x", v.Offset, "\n"
					}
					table.move(dumpField, 1, #dumpField, #dumpClass + 1, dumpClass)
				end
			end

			if classInfo.Methods and #classInfo.Methods > 0 then
				dumpClass[#dumpClass + 1] = "\n\t// Methods\n"
				for i, v in ipairs(classInfo.Methods) do
					local dumpMethod = {
						i == 1 and "" or "\n",
						"\t// Offset: 0x", v.Offset, " VA: 0x", v.AddressInMemory, " ParamCount: ", v.ParamCount, "\n",
						"\t", v.Access, " ",  v.IsStatic and "static " or "", v.IsAbstract and "abstract " or "", v.ReturnType, " ", v.MethodName, "() { } \n"
					}
					table.move(dumpMethod, 1, #dumpMethod, #dumpClass + 1, dumpClass)
				end
			end
			
			table.insert(dumpClass, "\n}\n")
			return table.concat(dumpClass)
		end
	}
	return StringUtils
end)

__bundle_register("utils.universalsearcher", function(require, _LOADED, __bundle_register, __bundle_modules)
	local AndroidInfo = require("utils.androidinfo")
    local Il2cppRef -- Forward declaration for Il2cppCombined instance

	---@class Searcher
	local Searcher = {
		searchWord = ":EnsureCapacity",
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,

		FindGlobalMetaData = function(self)
			gg.clearResults()
			gg.setRanges(gg.REGION_C_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_C_BSS | gg.REGION_C_DATA |
							 gg.REGION_OTHER)
			local globalMetadata = gg.getRangesList('global-metadata.dat')
			if not self:IsValidData(globalMetadata) then
				globalMetadata = {}
				gg.clearResults()
				gg.searchNumber(self.searchWord, gg.TYPE_BYTE)
				gg.refineNumber(self.searchWord:sub(1, 2), gg.TYPE_BYTE)
				local EnsureCapacity = gg.getResults(gg.getResultsCount())
				gg.clearResults()
				for k, v in ipairs(gg.getRangesList()) do
					if (v.state == 'Ca' or v.state == 'A' or v.state == 'Cd' or v.state == 'Cb' or v.state == 'Ch' or
						v.state == 'O') then
						for key, val in ipairs(EnsureCapacity) do
							globalMetadata[#globalMetadata + 1] =
								(Il2cppRef:FixValue(v.start) <= Il2cppRef:FixValue(val.address) and Il2cppRef:FixValue(val.address) <
									Il2cppRef:FixValue(v['end'])) and v or nil
						end
					end
				end
			end
            if globalMetadata[1] and globalMetadata[#globalMetadata] then
			    return globalMetadata[1].start, globalMetadata[#globalMetadata]['end']
            end
            return 0,0
		end,

		IsValidData = function(self, globalMetadata)
			if #globalMetadata ~= 0 then
				gg.searchNumber(self.searchWord, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, globalMetadata[1].start,
					globalMetadata[#globalMetadata]['end'])
				if gg.getResultsCount() > 0 then
					gg.clearResults()
					return true
				end
			end
			return false
		end,

		FindIl2cpp = function()
			local il2cpp = gg.getRangesList('libil2cpp.so')
			if #il2cpp == 0 then
				il2cpp = gg.getRangesList('split_config.')
				local _il2cpp = {}
				gg.setRanges(gg.REGION_CODE_APP)
				for k, v in ipairs(il2cpp) do
					if (v.state == 'Xa') then
						gg.searchNumber(':il2cpp', gg.TYPE_BYTE, false, gg.SIGN_EQUAL, v.start, v['end'])
						if (gg.getResultsCount() > 0) then
							_il2cpp[#_il2cpp + 1] = v
							gg.clearResults()
						end
					end
				end
				il2cpp = _il2cpp
			else
				local _il2cpp = {}
				for k,v in ipairs(il2cpp) do
					if (string.find(v.type, "..x.") or v.state == "Xa") then
						_il2cpp[#_il2cpp + 1] = v
					end
				end
				il2cpp = _il2cpp
			end       
            if il2cpp[1] and il2cpp[#il2cpp] then
			    return il2cpp[1].start, il2cpp[#il2cpp]['end']
            end
            return 0,0
		end,

		Il2CppMetadataRegistration = function(self)
			gg.clearResults()
			gg.setRanges(gg.REGION_C_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_C_BSS | gg.REGION_C_DATA |
							 gg.REGION_OTHER)
			gg.loadResults({{
				address = Il2cppRef.globalMetadataStart,
				flags = Il2cppRef.MainType
			}})
			gg.searchPointer(0)
			if gg.getResultsCount() == 0 and AndroidInfo.platform and AndroidInfo.sdk >= 30 then
				gg.searchNumber(tostring(Il2cppRef.globalMetadataStart | 0xB400000000000000), Il2cppRef.MainType)
			end
			if gg.getResultsCount() > 0 then
				local GlobalMetadataPointers, s_GlobalMetadata = gg.getResults(gg.getResultsCount()), 0
				for i = 1, #GlobalMetadataPointers do
					if i ~= 1 then
						local difference = GlobalMetadataPointers[i].address - GlobalMetadataPointers[i - 1].address
						if (difference == Il2cppRef.pointSize) then
							s_GlobalMetadata = Il2cppRef:FixValue(gg.getValues({{
								address = GlobalMetadataPointers[i].address - (AndroidInfo.platform and 0x10 or 0x8),
								flags = Il2cppRef.MainType
							}})[1].value)
						end
					end
				end
				return s_GlobalMetadata
			end
			return 0
		end
	}
	return Searcher
end)

__bundle_register("semver.semver", function(require, _LOADED, __bundle_register, __bundle_modules)
	local semver = {
	  _VERSION     = '1.2.1',
	  _DESCRIPTION = 'semver for Lua',
	  _URL         = 'https://github.com/kikito/semver.lua',
	  _LICENSE     = [[
		MIT LICENSE
		Copyright (c) 2015 Enrique García Cota
		Permission is hereby granted, free of charge, to any person obtaining a
		copy of tother software and associated documentation files (the
		"Software"), to deal in the Software without restriction, including
		without limitation the rights to use, copy, modify, merge, publish,
		distribute, sublicense, and/or sell copies of the Software, and to
		permit persons to whom the Software is furnished to do so, subject to
		the following conditions:
		The above copyright notice and tother permission notice shall be included
		in all copies or substantial portions of the Software.
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
		IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
		CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
		TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	  ]]
	}
	local function checkPositiveInteger(number, name)
	  assert(number >= 0, name .. ' must be a valid positive number')
	  assert(math.floor(number) == number, name .. ' must be an integer')
	end
	local function present(value)
	  return value and value ~= ''
	end
	local function splitByDot(str)
	  str = str or ""
	  local t, count = {}, 0
	  str:gsub("([^%.]+)", function(c)
		count = count + 1
		t[count] = c
	  end)
	  return t
	end
	local function parsePrereleaseAndBuildWithSign(str)
	  local prereleaseWithSign, buildWithSign = str:match("^(-[^+]+)(+.+)$")
	  if not (prereleaseWithSign and buildWithSign) then
		prereleaseWithSign = str:match("^(-.+)$")
		buildWithSign      = str:match("^(+.+)$")
	  end
	  assert(prereleaseWithSign or buildWithSign, ("The parameter %q must begin with + or - to denote a prerelease or a build"):format(str))
	  return prereleaseWithSign, buildWithSign
	end
	local function parsePrerelease(prereleaseWithSign)
	  if prereleaseWithSign then
		local prerelease = prereleaseWithSign:match("^-(%w[%.%w-]*)$")
		assert(prerelease, ("The prerelease %q is not a slash followed by alphanumerics, dots and slashes"):format(prereleaseWithSign))
		return prerelease
	  end
	end
	local function parseBuild(buildWithSign)
	  if buildWithSign then
		local build = buildWithSign:match("^%+(%w[%.%w-]*)$")
		assert(build, ("The build %q is not a + sign followed by alphanumerics, dots and slashes"):format(buildWithSign))
		return build
	  end
	end
	local function parsePrereleaseAndBuild(str)
	  if not present(str) then return nil, nil end
	  local prereleaseWithSign, buildWithSign = parsePrereleaseAndBuildWithSign(str)
	  local prerelease = parsePrerelease(prereleaseWithSign)
	  local build = parseBuild(buildWithSign)
	  return prerelease, build
	end
	local function parseVersion(str)
	  local sMajor, sMinor, sPatch, sPrereleaseAndBuild = str:match("^(%d+)%.?(%d*)%.?(%d*)(.-)$")
	  assert(type(sMajor) == 'string', ("Could not extract version number(s) from %q"):format(str))
	  local major, minor, patch = tonumber(sMajor), tonumber(sMinor), tonumber(sPatch)
	  local prerelease, build = parsePrereleaseAndBuild(sPrereleaseAndBuild)
	  return major, minor, patch, prerelease, build
	end
	local function compare(a,b)
	  return a == b and 0 or a < b and -1 or 1
	end
	local function compareIds(myId, otherId)
	  if myId == otherId then return  0
	  elseif not myId    then return -1
	  elseif not otherId then return  1
	  end
	  local selfNumber, otherNumber = tonumber(myId), tonumber(otherId)
	  if selfNumber and otherNumber then 
		return compare(selfNumber, otherNumber)
	  elseif selfNumber then
		return -1
	  elseif otherNumber then
		return 1
	  else
		return compare(myId, otherId) 
	  end
	end
	local function smallerIdList(myIds, otherIds)
	  local myLength = #myIds
	  local comparison
	  for i=1, myLength do
		comparison = compareIds(myIds[i], otherIds[i])
		if comparison ~= 0 then
		  return comparison == -1
		end
	  end
	  return myLength < #otherIds
	end
	local function smallerPrerelease(mine, other)
	  if mine == other or not mine then return false
	  elseif not other then return true
	  end
	  return smallerIdList(splitByDot(mine), splitByDot(other))
	end
	local methods = {}
	function methods:nextMajor()
	  return semver(self.major + 1, 0, 0)
	end
	function methods:nextMinor()
	  return semver(self.major, self.minor + 1, 0)
	end
	function methods:nextPatch()
	  return semver(self.major, self.minor, self.patch + 1)
	end
	local mt = { __index = methods }
	function mt:__eq(other)
	  return self.major == other.major and
			 self.minor == other.minor and
			 self.patch == other.patch and
			 self.prerelease == other.prerelease
	end
	function mt:__lt(other)
	  if self.major ~= other.major then return self.major < other.major end
	  if self.minor ~= other.minor then return self.minor < other.minor end
	  if self.patch ~= other.patch then return self.patch < other.patch end
	  return smallerPrerelease(self.prerelease, other.prerelease)
	end
	function mt:__pow(other)
	  if self.major == 0 then
		return self == other
	  end
	  return self.major == other.major and
			 self.minor <= other.minor
	end
	function mt:__tostring()
	  local buffer = { ("%d.%d.%d"):format(self.major, self.minor, self.patch) }
	  if self.prerelease then table.insert(buffer, "-" .. self.prerelease) end
	  if self.build      then table.insert(buffer, "+" .. self.build) end
	  return table.concat(buffer)
	end
	local function new(major, minor, patch, prerelease, build)
	  assert(major, "At least one parameter is needed")
	  if type(major) == 'string' then
		major,minor,patch,prerelease,build = parseVersion(major)
	  end
	  patch = patch or 0
	  minor = minor or 0
	  checkPositiveInteger(major, "major")
	  checkPositiveInteger(minor, "minor")
	  checkPositiveInteger(patch, "patch")
	  local result = {major=major, minor=minor, patch=patch, prerelease=prerelease, build=build}
	  return setmetatable(result, mt)
	end
	setmetatable(semver, { __call = function(_, ...) return new(...) end })
	semver._VERSION= semver(semver._VERSION)
	return semver
end)

__bundle_register("utils.version", function(require, _LOADED, __bundle_register, __bundle_modules)
	local semver = require("semver.semver")
    local Il2cppRef -- Forward declaration

	---@class VersionEngine
	local VersionEngine = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		ConstSemVer = {
			['2018_3'] = semver(2018, 3),
			['2019_4_21'] = semver(2019, 4, 21),
			['2019_4_15'] = semver(2019, 4, 15),
			['2019_3_7'] = semver(2019, 3, 7),
			['2020_2_4'] = semver(2020, 2, 4),
			['2020_2'] = semver(2020, 2),
			['2020_1_11'] = semver(2020, 1, 11),
			['2021_2'] = semver(2021, 2)   
		},
		Year = {
			[2017] = function(self, unityVersion)
				return 24
			end,
			[2018] = function(self, unityVersion)
				return (not (unityVersion < self.ConstSemVer['2018_3'])) and 24.1 or 24
			end,
			[2019] = function(self, unityVersion)
				local version = 24.2
				if not (unityVersion < self.ConstSemVer['2019_4_21']) then
					version = 24.5
				elseif not (unityVersion < self.ConstSemVer['2019_4_15']) then
					version = 24.4
				elseif not (unityVersion < self.ConstSemVer['2019_3_7']) then
					version = 24.3
				end
				return version
			end,
			[2020] = function(self, unityVersion)
				local version = 24.3
				if not (unityVersion < self.ConstSemVer['2020_2_4']) then
					version = 27.1
				elseif not (unityVersion < self.ConstSemVer['2020_2']) then
					version = 27
				elseif not (unityVersion < self.ConstSemVer['2020_1_11']) then
					version = 24.4
				end
				return version
			end,
			[2021] = function(self, unityVersion)
				return (not (unityVersion < self.ConstSemVer['2021_2'])) and 29 or 27.2 
			end,
			[2022] = function(self, unityVersion)
				return 29 -- Assuming 2022+ uses 29 or newer
			end,
            [2023] = function(self, unityVersion) return 29 end, -- Placeholder for future versions
            [2024] = function(self, unityVersion) return 29 end, -- Placeholder
            [2025] = function(self, unityVersion) return 29 end, -- Placeholder
		},
		GetUnityVersion = function()
			gg.setRanges(gg.REGION_ANONYMOUS)
			gg.clearResults()
			gg.searchNumber("00h;32h;30h;0~~0;0~~0;2Eh;0~~0;2Eh::9", gg.TYPE_BYTE, false, gg.SIGN_EQUAL, nil, nil, 1)
			local result = gg.getResultsCount() > 0 and gg.getResults(3)[3].address or 0
			gg.clearResults()
			return result
		end,
		ReadUnityVersion = function(versionAddress)
			local verisonName = Il2cppRef:Utf8ToString(versionAddress) -- Use Il2cppRef
			return string.gmatch(verisonName, "(%d+)%p(%d+)%p(%d+)")()
		end,
		ChooseVersion = function(self, version, globalMetadataHeader)
			if not version then
				local unityVersionAddress = self.GetUnityVersion()
				if unityVersionAddress == 0 then
					version = gg.getValues({{address = globalMetadataHeader + 0x4, flags = gg.TYPE_DWORD}})[1].value
				else
					local p1, p2, p3 = self.ReadUnityVersion(unityVersionAddress)
                    if p1 and p2 and p3 then
					    local unityVersion = semver(tonumber(p1), tonumber(p2), tonumber(p3))
					    version = self.Year[unityVersion.major] or 29
					    if type(version) == 'function' then
						    version = version(self, unityVersion)
					    end
                    else
                        -- Could not parse Unity version string, fallback
                        Il2cppRef:DebugPrint("⚠️ Could not parse Unity version string, falling back to default Il2Cpp version.")
                        version = gg.getValues({{address = globalMetadataHeader + 0x4, flags = gg.TYPE_DWORD}})[1].value
                    end
				end
			end
            Il2cppRef:DebugPrint("ℹ️ Determined Il2Cpp Version: " .. version)
			local api = assert(Il2CppConst[version], 'Not support this il2cpp version: ' .. tostring(version))
			
            -- Apply API offsets to Il2cppRef (the main API object)
			Il2cppRef.FieldApi.Offset = api.FieldApiOffset
			Il2cppRef.FieldApi.Type = api.FieldApiType
			Il2cppRef.FieldApi.ClassOffset = api.FieldApiClassOffset

			Il2cppRef.ClassApi.NameOffset = api.ClassApiNameOffset
			Il2cppRef.ClassApi.MethodsStep = api.ClassApiMethodsStep
			Il2cppRef.ClassApi.CountMethods = api.ClassApiCountMethods
			Il2cppRef.ClassApi.MethodsLink = api.ClassApiMethodsLink
			Il2cppRef.ClassApi.FieldsLink = api.ClassApiFieldsLink
			Il2cppRef.ClassApi.FieldsStep = api.ClassApiFieldsStep
			Il2cppRef.ClassApi.CountFields = api.ClassApiCountFields
			Il2cppRef.ClassApi.ParentOffset = api.ClassApiParentOffset
			Il2cppRef.ClassApi.NameSpaceOffset = api.ClassApiNameSpaceOffset
			Il2cppRef.ClassApi.StaticFieldDataOffset = api.ClassApiStaticFieldDataOffset
			Il2cppRef.ClassApi.EnumType = api.ClassApiEnumType
			Il2cppRef.ClassApi.EnumRsh = api.ClassApiEnumRsh
			Il2cppRef.ClassApi.TypeMetadataHandle = api.ClassApiTypeMetadataHandle
			Il2cppRef.ClassApi.InstanceSize = api.ClassApiInstanceSize
			Il2cppRef.ClassApi.Token = api.ClassApiToken

			Il2cppRef.MethodsApi.ClassOffset = api.MethodsApiClassOffset
			Il2cppRef.MethodsApi.NameOffset = api.MethodsApiNameOffset
			Il2cppRef.MethodsApi.ParamCount = api.MethodsApiParamCount
			Il2cppRef.MethodsApi.ReturnType = api.MethodsApiReturnType
			Il2cppRef.MethodsApi.Flags = api.MethodsApiFlags

			Il2cppRef.GlobalMetadataApi.typeDefinitionsSize = api.typeDefinitionsSize
			Il2cppRef.GlobalMetadataApi.version = version

			local consts = gg.getValues({
				{address = Il2cppRef.globalMetadataHeader + api.typeDefinitionsOffset, flags = gg.TYPE_DWORD},
				{address = Il2cppRef.globalMetadataHeader + api.stringOffset, flags = gg.TYPE_DWORD},
				{address = Il2cppRef.globalMetadataHeader + api.fieldDefaultValuesOffset, flags = gg.TYPE_DWORD},
				{address = Il2cppRef.globalMetadataHeader + api.fieldDefaultValuesSize, flags = gg.TYPE_DWORD},
				{address = Il2cppRef.globalMetadataHeader + api.fieldAndParameterDefaultValueDataOffset, flags = gg.TYPE_DWORD}
			})
			Il2cppRef.GlobalMetadataApi.typeDefinitionsOffset = consts[1].value
			Il2cppRef.GlobalMetadataApi.stringOffset = consts[2].value
			Il2cppRef.GlobalMetadataApi.fieldDefaultValuesOffset = consts[3].value
			Il2cppRef.GlobalMetadataApi.fieldDefaultValuesSize = consts[4].value
			Il2cppRef.GlobalMetadataApi.fieldAndParameterDefaultValueDataOffset = consts[5].value

			Il2cppRef.TypeApi.Type = api.TypeApiType
			Il2cppRef.Il2CppTypeDefinitionApi.fieldStart = api.Il2CppTypeDefinitionApifieldStart
			Il2cppRef.MetadataRegistrationApi.types = api.MetadataRegistrationApitypes
		end,
	}
	return VersionEngine
end)

-- Il2cppStruct modules
__bundle_register("il2cppstruct.api.classinfo", function(require, _LOADED, __bundle_register, __bundle_modules)
    local Il2cppRef -- Forward declaration
	local ClassInfoApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		GetFieldWithName = function(self, name)
			local FieldsInfo = self.Fields
			if FieldsInfo then
				for fieldIndex = 1, #FieldsInfo do
					if FieldsInfo[fieldIndex].FieldName == name then
						return FieldsInfo[fieldIndex]
					end
				end
			else
				local ClassAddress = tonumber(self.ClassAddress, 16)
				local _ClassInfo = gg.getValues({
					{address = ClassAddress + Il2cppRef.ClassApi.FieldsLink, flags = Il2cppRef.MainType},
					{address = ClassAddress + Il2cppRef.ClassApi.CountFields, flags = gg.TYPE_WORD}
				})
				self.Fields = Il2cppRef.ClassApi:GetClassFields(Il2cppRef:FixValue(_ClassInfo[1].value), _ClassInfo[2].value, {
					ClassName = self.ClassName,
					IsEnum = self.IsEnum,
					TypeMetadataHandle = self.TypeMetadataHandle
				})
				return self:GetFieldWithName(name)
			end
			return nil
		end,
		GetMethodsWithName = function(self, name)
			local MethodsInfo, MethodsInfoResult = self.Methods, {}
			if MethodsInfo then
				for methodIndex = 1, #MethodsInfo do
					if MethodsInfo[methodIndex].MethodName == name then
						MethodsInfoResult[#MethodsInfoResult + 1] = MethodsInfo[methodIndex]
					end
				end
				return MethodsInfoResult
			else
				local ClassAddress = tonumber(self.ClassAddress, 16)
				local _ClassInfo = gg.getValues({
					{address = ClassAddress + Il2cppRef.ClassApi.MethodsLink, flags = Il2cppRef.MainType},
					{address = ClassAddress + Il2cppRef.ClassApi.CountMethods, flags = gg.TYPE_WORD}
				})
				self.Methods = Il2cppRef.ClassApi:GetClassMethods(Il2cppRef:FixValue(_ClassInfo[1].value), _ClassInfo[2].value,
					self.ClassName)
				return self:GetMethodsWithName(name)
			end
		end,
		GetFieldWithOffset = function(self, fieldOffset)
			if not self.Fields then
				local ClassAddress = tonumber(self.ClassAddress, 16)
				local _ClassInfo = gg.getValues({
					{address = ClassAddress + Il2cppRef.ClassApi.FieldsLink, flags = Il2cppRef.MainType},
					{address = ClassAddress + Il2cppRef.ClassApi.CountFields, flags = gg.TYPE_WORD}
				})
				self.Fields = Il2cppRef.ClassApi:GetClassFields(Il2cppRef:FixValue(_ClassInfo[1].value), _ClassInfo[2].value, {
					ClassName = self.ClassName,
					IsEnum = self.IsEnum,
					TypeMetadataHandle = self.TypeMetadataHandle
				})
			end
			if self.Fields and #self.Fields > 0 then -- Ensure self.Fields is not nil
				local klass = self
				while klass ~= nil do
					if klass.Fields and klass.InstanceSize >= fieldOffset then
						local lastField
						for indexField, field in ipairs(klass.Fields) do
							if not (field.IsStatic or field.IsConst) then
								local offset = tonumber(field.Offset, 16)
								if offset > 0 then 
									local maybeStruct = fieldOffset < offset
									if indexField == 1 and maybeStruct then
										break
									elseif offset == fieldOffset or indexField == #klass.Fields then
										return field
									elseif maybeStruct then
										return lastField
									else
										lastField = field
									end
								end
							end
						end
					end
					klass = klass.Parent ~= nil 
						and Il2cppRef:FindClass({{Class = tonumber(klass.Parent.ClassAddress, 16), FieldsDump = true}})[1][1] 
						or nil
				end
			end
			return nil
		end
	}
	return ClassInfoApi
end)

__bundle_register("il2cppstruct.api.fieldinfo", function(require, _LOADED, __bundle_register, __bundle_modules)
	local Il2cppMemory = require("utils.il2cppmemory")
    local Il2cppRef -- Forward declaration
	---@type FieldInfo
	local FieldInfoApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		GetConstValue = function(self)
			if self.IsConst then
				local fieldIndex = getmetatable(self).fieldIndex
				local defaultValue = Il2cppMemory:GetDefaultValue(fieldIndex)
				if not defaultValue then
					defaultValue = Il2cppRef.GlobalMetadataApi:GetDefaultFieldValue(fieldIndex)
					Il2cppMemory:SetDefaultValue(fieldIndex, defaultValue)
				elseif defaultValue == "nil" then
					return nil
				end
				return defaultValue
			end
			return nil
		end
	}
	return FieldInfoApi
end)

__bundle_register("il2cppstruct.class", function(require, _LOADED, __bundle_register, __bundle_modules)
	local Protect = require("utils.protect")
	local StringUtils = require("utils.stringutils")
	local Il2cppMemory = require("utils.il2cppmemory")
    local Il2cppRef -- Forward declaration

	---@class ClassApi
	local ClassApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		GetClassName = function(self, ClassAddress)
			return Il2cppRef:Utf8ToString(Il2cppRef:FixValue(gg.getValues({{
				address = Il2cppRef:FixValue(ClassAddress) + self.NameOffset,
				flags = Il2cppRef.MainType
			}})[1].value))
		end,
		GetClassMethods = function(self, MethodsLink, Count, ClassName)
			local MethodsInfo, _MethodsInfo = {}, {}
			for i = 0, Count - 1 do
				_MethodsInfo[#_MethodsInfo + 1] = {
					address = MethodsLink + (i << self.MethodsStep),
					flags = Il2cppRef.MainType
				}
			end
			_MethodsInfo = gg.getValues(_MethodsInfo)
			for i = 1, #_MethodsInfo do
				local MethodInfo
				MethodInfo, _MethodsInfo[i] = Il2cppRef.MethodsApi:UnpackMethodInfo({
					MethodInfoAddress = Il2cppRef:FixValue(_MethodsInfo[i].value),
					ClassName = ClassName
				})
				table.move(MethodInfo, 1, #MethodInfo, #MethodsInfo + 1, MethodsInfo)
			end
			MethodsInfo = gg.getValues(MethodsInfo)
			Il2cppRef.MethodsApi:DecodeMethodsInfo(_MethodsInfo, MethodsInfo)
			return _MethodsInfo
		end,
		GetClassFields = function(self, FieldsLink, Count, ClassCharacteristic)
			local FieldsInfo, _FieldsInfo = {}, {}
			for i = 0, Count - 1 do
				_FieldsInfo[#_FieldsInfo + 1] = {
					address = FieldsLink + (i * self.FieldsStep),
					flags = Il2cppRef.MainType
				}
			end
			_FieldsInfo = gg.getValues(_FieldsInfo)
			for i = 1, #_FieldsInfo do
				local FieldInfo
				FieldInfo = Il2cppRef.FieldApi:UnpackFieldInfo(Il2cppRef:FixValue(_FieldsInfo[i].address))
				table.move(FieldInfo, 1, #FieldInfo, #FieldsInfo + 1, FieldsInfo)
			end
			FieldsInfo = gg.getValues(FieldsInfo)
			_FieldsInfo = Il2cppRef.FieldApi:DecodeFieldsInfo(FieldsInfo, ClassCharacteristic)
			return _FieldsInfo
		end,
		UnpackClassInfo = function(self, ClassInfo, Config)
			local _ClassInfo = gg.getValues({
				{address = ClassInfo.ClassInfoAddress + self.NameOffset, flags = Il2cppRef.MainType},
				{address = ClassInfo.ClassInfoAddress + self.CountMethods, flags = gg.TYPE_WORD},
				{address = ClassInfo.ClassInfoAddress + self.CountFields, flags = gg.TYPE_WORD},
				{address = ClassInfo.ClassInfoAddress + self.MethodsLink, flags = Il2cppRef.MainType},
				{address = ClassInfo.ClassInfoAddress + self.FieldsLink, flags = Il2cppRef.MainType},
				{address = ClassInfo.ClassInfoAddress + self.ParentOffset, flags = Il2cppRef.MainType},
				{address = ClassInfo.ClassInfoAddress + self.NameSpaceOffset, flags = Il2cppRef.MainType},
				{address = ClassInfo.ClassInfoAddress + self.StaticFieldDataOffset, flags = Il2cppRef.MainType},
				{address = ClassInfo.ClassInfoAddress + self.EnumType, flags = gg.TYPE_BYTE},
				{address = ClassInfo.ClassInfoAddress + self.TypeMetadataHandle, flags = Il2cppRef.MainType},
				{address = ClassInfo.ClassInfoAddress + self.InstanceSize, flags = gg.TYPE_DWORD},
				{address = ClassInfo.ClassInfoAddress + self.Token, flags = gg.TYPE_DWORD}
			})
			local ClassName = ClassInfo.ClassName or Il2cppRef:Utf8ToString(Il2cppRef:FixValue(_ClassInfo[1].value))
			local ClassCharacteristic = {
				ClassName = ClassName,
				IsEnum = ((_ClassInfo[9].value >> self.EnumRsh) & 1) == 1,
				TypeMetadataHandle = Il2cppRef:FixValue(_ClassInfo[10].value)
			}
			return setmetatable({
				ClassName = ClassName,
				ClassAddress = string.format('%X', Il2cppRef:FixValue(ClassInfo.ClassInfoAddress)),
				Methods = (_ClassInfo[2].value > 0 and Config.MethodsDump) and
					self:GetClassMethods(Il2cppRef:FixValue(_ClassInfo[4].value), _ClassInfo[2].value, ClassName) or nil,
				Fields = (_ClassInfo[3].value > 0 and Config.FieldsDump) and
					self:GetClassFields(Il2cppRef:FixValue(_ClassInfo[5].value), _ClassInfo[3].value, ClassCharacteristic) or nil,
				Parent = _ClassInfo[6].value ~= 0 and {
					ClassAddress = string.format('%X', Il2cppRef:FixValue(_ClassInfo[6].value)),
					ClassName = self:GetClassName(_ClassInfo[6].value)
				} or nil,
				ClassNameSpace = Il2cppRef:Utf8ToString(Il2cppRef:FixValue(_ClassInfo[7].value)),
				StaticFieldData = _ClassInfo[8].value ~= 0 and Il2cppRef:FixValue(_ClassInfo[8].value) or nil,
				IsEnum = ClassCharacteristic.IsEnum,
				TypeMetadataHandle = ClassCharacteristic.TypeMetadataHandle,
				InstanceSize = _ClassInfo[11].value,
				Token = string.format("0x%X", _ClassInfo[12].value),
				ImageName = ClassInfo.ImageName
			}, {
				__index = Il2cppRef.ClassInfoApi,
				__tostring = StringUtils.ClassInfoToDumpCS
			})
		end,
		IsClassInfo = function(self, Address) -- Added self
			local imageAddress = Il2cppRef:FixValue(gg.getValues({{address = Il2cppRef:FixValue(Address), flags = Il2cppRef.MainType}})[1].value)
			local imageStr = Il2cppRef:Utf8ToString(Il2cppRef:FixValue(gg.getValues({{address = imageAddress, flags = Il2cppRef.MainType}})[1].value))
			local check = string.find(imageStr, ".-%.dll") or string.find(imageStr, "__Generated")
			return check and imageStr or nil
		end,
		FindClassWithName = function(self, ClassName, searchResult)
			local ClassNamePoint = Il2cppRef.GlobalMetadataApi:GetPointersToString(ClassName)
			local ResultTable = {}
			if #ClassNamePoint > searchResult.len then
				for classPointIndex, classPoint in ipairs(ClassNamePoint) do
					local classAddress = classPoint.address - self.NameOffset
					local imageName = self:IsClassInfo(classAddress) -- Use self
					if (imageName) then
						ResultTable[#ResultTable + 1] = {
							ClassInfoAddress = Il2cppRef:FixValue(classAddress),
							ClassName = ClassName,
							ImageName = imageName
						}
					end
				end
				searchResult.len = #ClassNamePoint
			else
				searchResult.isNew = false
			end
			assert(#ResultTable > 0, string.format("The '%s' class is not initialized", ClassName))
			return ResultTable
		end,
		FindClassWithAddressInMemory = function(self, ClassAddress, searchResult)
			local ResultTable = {}
			if searchResult.len < 1 then
				local imageName = self:IsClassInfo(ClassAddress) -- Use self
				if imageName then
					ResultTable[#ResultTable + 1] = {
						ClassInfoAddress = ClassAddress,
						ImageName = imageName
					}
				end
				searchResult.len = 1
			else
				searchResult.isNew = false
			end
			assert(#ResultTable > 0, string.format("nothing was found for this address 0x%X", ClassAddress))
			return ResultTable
		end,
		FindParamsCheck = {
			['number'] = function(self, _class, searchResult)
				return Protect:Call(self.FindClassWithAddressInMemory, self, _class, searchResult)
			end,
			['string'] = function(self, _class, searchResult)
				return Protect:Call(self.FindClassWithName, self, _class, searchResult)
			end,
			['default'] = function() return {Error = 'Invalid search criteria'} end
		},
		Find = function(self, class)
			local searchResult = Il2cppMemory:GetInformationOfClass(class.Class)
			if (not searchResult) 
				or ((class.FieldsDump or class.MethodsDump)
					and (searchResult.config.FieldsDump ~= class.FieldsDump or searchResult.config.MethodsDump ~= class.MethodsDump))  
				then
				searchResult = {len = 0}
			end
			searchResult.isNew = true
			local ClassInfo = (self.FindParamsCheck[type(class.Class)] or self.FindParamsCheck['default'])(self, class.Class, searchResult)
			if searchResult.isNew then
                if ClassInfo and not ClassInfo.Error then -- Check for errors before iterating
				    for k = 1, #ClassInfo do
					    ClassInfo[k] = self:UnpackClassInfo(ClassInfo[k], {
						    FieldsDump = class.FieldsDump,
						    MethodsDump = class.MethodsDump
					    })
				    end
                end
				searchResult.config = {
					Class = class.Class, FieldsDump = class.FieldsDump, MethodsDump = class.MethodsDump
				}
				searchResult.result = ClassInfo
				Il2cppMemory:SetInformationOfClass(class.Class, searchResult)
			else
				ClassInfo = searchResult.result
			end
			return ClassInfo
		end
	}
	return ClassApi
end)

__bundle_register("il2cppstruct.field", function(require, _LOADED, __bundle_register, __bundle_modules)
	local Protect = require("utils.protect")
    local Il2cppRef -- Forward declaration

	---@class FieldApi
	local FieldApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		UnpackFieldInfo = function(self, FieldInfoAddress)
			return {
				{address = FieldInfoAddress, flags = Il2cppRef.MainType}, 
				{address = FieldInfoAddress + self.Offset, flags = gg.TYPE_WORD}, 
				{address = FieldInfoAddress + self.Type, flags = Il2cppRef.MainType}, 
				{address = FieldInfoAddress + self.ClassOffset, flags = Il2cppRef.MainType}
			}
		end,
		DecodeFieldsInfo = function(self, FieldsInfo, ClassCharacteristic)
			local index, _FieldsInfo = 0, {}
			local fieldStart = gg.getValues({{
				address = ClassCharacteristic.TypeMetadataHandle + Il2cppRef.Il2CppTypeDefinitionApi.fieldStart,
				flags = gg.TYPE_DWORD
			}})[1].value
			for i = 1, #FieldsInfo, 4 do
				index = index + 1
				local TypeInfo = Il2cppRef:FixValue(FieldsInfo[i + 2].value)
				local _TypeInfo = gg.getValues({
					{address = TypeInfo + self.Type, flags = gg.TYPE_WORD}, 
					{address = TypeInfo + Il2cppRef.TypeApi.Type, flags = gg.TYPE_BYTE}, 
					{address = TypeInfo, flags = Il2cppRef.MainType}
				})
				local attrs = _TypeInfo[1].value
				local IsConst = (attrs & Il2CppFlags.Field.FIELD_ATTRIBUTE_LITERAL) ~= 0
				_FieldsInfo[index] = setmetatable({
					ClassName = ClassCharacteristic.ClassName or Il2cppRef.ClassApi:GetClassName(FieldsInfo[i + 3].value),
					ClassAddress = string.format('%X', Il2cppRef:FixValue(FieldsInfo[i + 3].value)),
					FieldName = Il2cppRef:Utf8ToString(Il2cppRef:FixValue(FieldsInfo[i].value)),
					Offset = string.format('%X', FieldsInfo[i + 1].value),
					IsStatic = (not IsConst) and ((attrs & Il2CppFlags.Field.FIELD_ATTRIBUTE_STATIC) ~= 0),
					Type = Il2cppRef.TypeApi:GetTypeName(_TypeInfo[2].value, _TypeInfo[3].value),
					IsConst = IsConst,
					Access = Il2CppFlags.Field.Access[attrs & Il2CppFlags.Field.FIELD_ATTRIBUTE_FIELD_ACCESS_MASK] or "",
				}, {
					__index = Il2cppRef.FieldInfoApi,
					fieldIndex = fieldStart + index - 1
				})
			end
			return _FieldsInfo
		end,
		FindFieldWithName = function(self, fieldName)
			local fieldNamePoint = Il2cppRef.GlobalMetadataApi:GetPointersToString(fieldName)
			local ResultTable = {}
			for k, v in ipairs(fieldNamePoint) do
				local classAddress = gg.getValues({{
					address = v.address + self.ClassOffset,
					flags = Il2cppRef.MainType
				}})[1].value
				if Il2cppRef.ClassApi:IsClassInfo(classAddress) then -- Pass self if needed, or ensure ClassApi has Il2cppRef
					local result = self:FindFieldInClass(fieldName, classAddress)
					table.move(result, 1, #result, #ResultTable + 1, ResultTable)
				end
			end
			assert(type(ResultTable) == "table" and #ResultTable > 0, string.format("The '%s' field is not initialized", fieldName))
			return ResultTable
		end,
		FindFieldWithAddress = function(self, fieldAddress)
			local ObjectHead = Il2cppRef.ObjectApi:FindHead(fieldAddress)
			local fieldOffset = fieldAddress - ObjectHead.address
			local classAddress = Il2cppRef:FixValue(ObjectHead.value)
			local ResultTable = self:FindFieldInClass(fieldOffset, classAddress)
			assert(#ResultTable > 0, string.format("nothing was found for this address 0x%X", fieldAddress))
			return ResultTable
		end,
		FindFieldInClass = function(self, fieldSearchCondition, classAddress) -- Added self
			local ResultTable = {}
			local Il2cppClass = Il2cppRef:FindClass({{Class = classAddress, FieldsDump = true}})[1]
            if Il2cppClass and not Il2cppClass.Error then -- Check for errors
			    for i, v in ipairs(Il2cppClass) do
				    local fieldResult = type(fieldSearchCondition) == "number" 
					    and v:GetFieldWithOffset(fieldSearchCondition)
					    or v:GetFieldWithName(fieldSearchCondition)
                    if fieldResult then ResultTable[#ResultTable + 1] = fieldResult end
			    end
            end
			return ResultTable
		end,
		FindTypeCheck = {
			['string'] = function(self, fieldName) return Protect:Call(self.FindFieldWithName, self, fieldName) end,
			['number'] = function(self, fieldAddress) return Protect:Call(self.FindFieldWithAddress, self, fieldAddress) end,
			['default'] = function() return {Error = 'Invalid search criteria'} end
		},
		Find = function(self, fieldSearchCondition)
			return (self.FindTypeCheck[type(fieldSearchCondition)] or self.FindTypeCheck['default'])(self, fieldSearchCondition)
		end
	}
	return FieldApi
end)

__bundle_register("il2cppstruct.globalmetadata", function(require, _LOADED, __bundle_register, __bundle_modules)
    local Il2cppRef -- Forward declaration
	---@class GlobalMetadataApi
	local GlobalMetadataApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		behaviorForTypes = {
			[2] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_BYTE) end,
			[3] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_BYTE) end,
			[4] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_BYTE) end,
			[5] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_BYTE) end,
			[6] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_WORD) end,
			[7] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_WORD) end,
			[8] = function(blob)
				local selfApi = Il2cppRef.GlobalMetadataApi
				return selfApi.version < 29 and selfApi.ReadNumberConst(blob, gg.TYPE_DWORD) or selfApi.ReadCompressedInt32(blob)
			end,
			[9] = function(blob)
				local selfApi = Il2cppRef.GlobalMetadataApi
				return selfApi.version < 29 and Il2cppRef:FixValue(selfApi.ReadNumberConst(blob, gg.TYPE_DWORD)) or selfApi.ReadCompressedUInt32(blob)
			end,
			[10] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_QWORD) end,
			[11] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_QWORD) end,
			[12] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_FLOAT) end,
			[13] = function(blob) return Il2cppRef.GlobalMetadataApi.ReadNumberConst(blob, gg.TYPE_DOUBLE) end,
			[14] = function(blob)
				local selfApi = Il2cppRef.GlobalMetadataApi
				local length, offset = 0, 0
				if selfApi.version >= 29 then
					length, offset = selfApi.ReadCompressedInt32(blob)
				else
					length = selfApi.ReadNumberConst(blob, gg.TYPE_DWORD) 
					offset = 4
				end
				if length ~= -1 then return Il2cppRef:Utf8ToString(blob + offset, length) end
				return ""
			end
		},
		GetStringFromIndex = function(self, index)
			local stringDefinitions = Il2cppRef.globalMetadataStart + self.stringOffset
			return Il2cppRef:Utf8ToString(stringDefinitions + index)
		end,
		GetClassNameFromIndex = function(self, index)
			if (self.version < 27) then
				local typeDefinitions = Il2cppRef.globalMetadataStart + self.typeDefinitionsOffset
				index = (self.typeDefinitionsSize * index) + typeDefinitions
			else
				index = Il2cppRef:FixValue(index)
			end
			local typeDefinition = gg.getValues({{address = index, flags = gg.TYPE_DWORD}})[1].value
			return self:GetStringFromIndex(typeDefinition)
		end,
		GetFieldOrParameterDefalutValue = function(self, dataIndex)
			return self.fieldAndParameterDefaultValueDataOffset + Il2cppRef.globalMetadataStart + dataIndex
		end,
		GetIl2CppFieldDefaultValue = function(self, index)
			gg.clearResults()
			gg.setRanges(0)
			gg.setRanges(gg.REGION_C_HEAP | gg.REGION_C_HEAP | gg.REGION_ANONYMOUS | gg.REGION_C_BSS | gg.REGION_C_DATA |
							 gg.REGION_OTHER | gg.REGION_C_ALLOC)
			gg.searchNumber(index, gg.TYPE_DWORD, false, gg.SIGN_EQUAL,
				Il2cppRef.globalMetadataStart + self.fieldDefaultValuesOffset,
				Il2cppRef.globalMetadataStart + self.fieldDefaultValuesOffset + self.fieldDefaultValuesSize)
			if gg.getResultsCount() > 0 then
				local Il2CppFieldDefaultValue = gg.getResults(1)
				gg.clearResults()
				return Il2CppFieldDefaultValue
			end
			return {}
		end,
		ReadCompressedUInt32 = function(Address) -- Static-like, doesn't need self
			local val, offset = 0, 0
			local read = gg.getValues({
				{address = Address, flags = gg.TYPE_BYTE}, {address = Address + 1, flags = gg.TYPE_BYTE},
				{address = Address + 2, flags = gg.TYPE_BYTE}, {address = Address + 3, flags = gg.TYPE_BYTE}
			})
			local read1 = read[1].value & 0xFF; offset = 1
			if (read1 & 0x80) == 0 then val = read1
			elseif (read1 & 0xC0) == 0x80 then val = (read1 & ~0x80) << 8; val = val | (read[2].value & 0xFF); offset = offset + 1
			elseif (read1 & 0xE0) == 0xC0 then val = (read1 & ~0xC0) << 24; val = val | ((read[2].value & 0xFF) << 16); val = val | ((read[3].value & 0xFF) << 8); val = val | (read[4].value & 0xFF); offset = offset + 3
			elseif read1 == 0xF0 then val = gg.getValues({{address = Address + 1, flags = gg.TYPE_DWORD}})[1].value; offset = offset + 4
			elseif read1 == 0xFE then val = 0xffffffff - 1
			elseif read1 == 0xFF then val = 0xffffffff end
			return val, offset
		end,
		ReadCompressedInt32 = function(Address) -- Static-like
			local encoded, offset = Il2cppRef.GlobalMetadataApi.ReadCompressedUInt32(Address) -- Call via Il2cppRef
			if encoded == 0xffffffff then return -2147483647 - 1 end
			local isNegative = (encoded & 1) == 1; encoded = encoded >> 1
			if isNegative then return -(encoded + 1) end
			return encoded, offset
		end,
		ReadNumberConst = function(Address, ggType) -- Static-like
			return gg.getValues({{address = Address, flags = ggType}})[1].value
		end,
		GetDefaultFieldValue = function(self, index)
			local Il2CppFieldDefaultValue = self:GetIl2CppFieldDefaultValue(tostring(index))
			if #Il2CppFieldDefaultValue > 0 then
				local _Il2CppFieldDefaultValue = gg.getValues({
					{address = Il2CppFieldDefaultValue[1].address + 4, flags = gg.TYPE_DWORD},
					{address = Il2CppFieldDefaultValue[1].address + 8, flags = gg.TYPE_DWORD}
				})
				local blob = self:GetFieldOrParameterDefalutValue(_Il2CppFieldDefaultValue[2].value)
				local Il2CppType = Il2cppRef.MetadataRegistrationApi:GetIl2CppTypeFromIndex(_Il2CppFieldDefaultValue[1].value)
				local typeEnum = Il2cppRef.TypeApi:GetTypeEnum(Il2CppType)
				local behavior = self.behaviorForTypes[typeEnum] or "Not support type"
				if type(behavior) == "function" then return behavior(blob) end
				return behavior
			end
			return nil
		end,
		GetPointersToString = function(self, name) -- Added self
			local pointers = {}
			gg.clearResults()
			gg.setRanges(0)
			gg.setRanges(gg.REGION_C_HEAP | gg.REGION_C_HEAP | gg.REGION_ANONYMOUS | gg.REGION_C_BSS | gg.REGION_C_DATA |
							 gg.REGION_OTHER | gg.REGION_C_ALLOC)
			gg.searchNumber(string.format("Q 00 '%s' 00", name), gg.TYPE_BYTE, false, gg.SIGN_EQUAL,
				Il2cppRef.globalMetadataStart, Il2cppRef.globalMetadataEnd)
			gg.searchPointer(0)
			pointers = gg.getResults(gg.getResultsCount())
			assert(type(pointers) == 'table' and #pointers > 0, string.format("this '%s' is not in the global-metadata", name))
			gg.clearResults()
			return pointers
		end
	}
	return GlobalMetadataApi
end)

__bundle_register("il2cppstruct.il2cppstring", function(require, _LOADED, __bundle_register, __bundle_modules)
    local Il2cppRef -- Forward declaration
	---@class StringApi
	local StringApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		EditString = function(self, newStr)
			local _stringLength = gg.getValues{{address = self.address + self.Fields._stringLength, flags = gg.TYPE_DWORD}}[1].value
			_stringLength = _stringLength * 2
			local bytes = gg.bytes(newStr, "UTF-16LE")
			if _stringLength == #bytes then
				local strStart = self.address + self.Fields._firstChar
				for i, v in ipairs(bytes) do bytes[i] = {address = strStart + (i - 1), flags = gg.TYPE_BYTE, value = v} end
				gg.setValues(bytes)
			elseif _stringLength > #bytes then
				local strStart = self.address + self.Fields._firstChar; local _bytes = {}
				for i = 1, _stringLength do _bytes[#_bytes + 1] = {address = strStart + (i - 1), flags = gg.TYPE_BYTE, value = bytes[i] or 0} end
				gg.setValues(_bytes)
			elseif _stringLength < #bytes then
				self.address = Il2cppRef.MemoryManager.MAlloc(self.Fields._firstChar + #bytes + 8)
				local length = #bytes % 2 == 1 and #bytes + 1 or #bytes
				local _bytes = {
					{address = self.address, flags = Il2cppRef.MainType, value = self.ClassAddress},
					{address = self.address + self.Fields._stringLength, flags = gg.TYPE_DWORD, value = length / 2}
				}
				local strStart = self.address + self.Fields._firstChar
				for i = 1, length do _bytes[#_bytes + 1] = {address = strStart + (i - 1), flags = gg.TYPE_BYTE, value = bytes[i] or 0} end
				_bytes[#_bytes + 1] = {address = self.pointToStr, flags = Il2cppRef.MainType, value = self.address}
				gg.setValues(_bytes)
			end
		end,
		ReadString = function(self)
			local _stringLength = gg.getValues{{address = self.address + self.Fields._stringLength, flags = gg.TYPE_DWORD}}[1].value
			local bytes = {}
			if _stringLength > 0 and _stringLength < 200 then -- Max length check
				local strStart = self.address + self.Fields._firstChar
				for i = 0, _stringLength -1 do -- Iterate up to length-1 for characters
					bytes[#bytes + 1] = {address = strStart + (i << 1), flags = gg.TYPE_WORD}
				end
                if #bytes > 0 then -- only getValues if there are bytes to read
				    bytes = gg.getValues(bytes)
				    local code = {[[return "]]}
				    for i, v in ipairs(bytes) do code[#code + 1] = string.format([[\u{%x}]], v.value & 0xFFFF) end
				    code[#code + 1] = '"'
				    local read, err = load(table.concat(code))
				    if read then return read() else Il2cppRef:DebugPrint("⚠️ Error loading UTF-16 string: " .. tostring(err)) end
                end
			elseif _stringLength >= 200 then
                 Il2cppRef:DebugPrint("⚠️ String too long to read via Il2cppString:ReadString (length: " .. _stringLength .. ")")
            end
			return ""
		end
	}
	---@class MyString
	local String = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		From = function(address)
			local pointToStr = gg.getValues({{address = Il2cppRef:FixValue(address), flags = Il2cppRef.MainType}})[1]
            if not pointToStr or pointToStr.value == 0 then return nil end -- Check for invalid pointer
			local str = setmetatable({
				address = Il2cppRef:FixValue(pointToStr.value), Fields = {}, pointToStr = Il2cppRef:FixValue(address)
			}, {__index = StringApi})
            StringApi:SetIl2cppRef(Il2cppRef) -- Pass Il2cppRef to StringApi instance
			local pointClassAddress = gg.getValues({{address = str.address, flags = Il2cppRef.MainType}})[1].value
			local stringInfoResults = Il2cppRef:FindClass({{Class = Il2cppRef:FixValue(pointClassAddress), FieldsDump = true}})[1]
            if stringInfoResults and not stringInfoResults.Error then
			    for i, v in ipairs(stringInfoResults) do
				    if v.ClassNameSpace == "System" then
					    str.ClassAddress = tonumber(v.ClassAddress, 16)
                        if v.Fields then -- Ensure Fields were dumped
					        for indexField, FieldInfo in ipairs(v.Fields) do
						        str.Fields[FieldInfo.FieldName] = tonumber(FieldInfo.Offset, 16)
					        end
                        end
					    return str
				    end
			    end
            end
			return nil
		end,
	}
	return String
end)

__bundle_register("il2cppstruct.metadataRegistration", function(require, _LOADED, __bundle_register, __bundle_modules)
	local Searcher = require("utils.universalsearcher")
    local Il2cppRef -- Forward declaration

	---@class MetadataRegistrationApi
	local MetadataRegistrationApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		GetIl2CppTypeFromIndex = function(self, index)
			if not self.metadataRegistration or self.metadataRegistration == 0 then
				self:FindMetadataRegistration()
			end
            if not self.metadataRegistration or self.metadataRegistration == 0 then
                Il2cppRef:DebugPrint("🔴 MetadataRegistration not found. Cannot get Il2CppType from index.")
                return 0 -- Or handle error appropriately
            end
			local types = gg.getValues({{address = self.metadataRegistration + self.types, flags = Il2cppRef.MainType}})[1].value
			return Il2cppRef:FixValue(gg.getValues({{address = types + (Il2cppRef.pointSize * index), flags = Il2cppRef.MainType}})[1].value)
		end,
		FindMetadataRegistration = function(self)
			self.metadataRegistration = Searcher:Il2CppMetadataRegistration()
            if not self.metadataRegistration or self.metadataRegistration == 0 then
                Il2cppRef:DebugPrint("🔴 Failed to find Il2CppMetadataRegistration.")
            else
                Il2cppRef:DebugPrint("🟢 Il2CppMetadataRegistration found at: 0x" .. string.format("%X", self.metadataRegistration))
            end
		end
	}
	return MetadataRegistrationApi
end)

__bundle_register("il2cppstruct.method", function(require, _LOADED, __bundle_register, __bundle_modules)
	local AndroidInfo = require("utils.androidinfo")
	local Protect = require("utils.protect")
	local Il2cppMemory = require("utils.il2cppmemory")
    local Il2cppRef -- Forward declaration

	---@class MethodsApi
	local MethodsApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		FindMethodWithName = function(self, MethodName, searchResult)
			local FinalMethods = {}
			local MethodNamePointers = Il2cppRef.GlobalMetadataApi:GetPointersToString(MethodName)
			if searchResult.len < #MethodNamePointers then
				for methodPointIndex, methodPoint in ipairs(MethodNamePointers) do
					methodPoint.address = methodPoint.address - self.NameOffset
					local MethodAddress = Il2cppRef:FixValue(gg.getValues({methodPoint})[1].value)
					if MethodAddress > Il2cppRef.il2cppStart and MethodAddress < Il2cppRef.il2cppEnd then
						FinalMethods[#FinalMethods + 1] = {
							MethodName = MethodName, MethodAddress = MethodAddress, MethodInfoAddress = methodPoint.address
						}
					end
				end
			else
				searchResult.isNew = false
			end
			assert(#FinalMethods > 0, string.format("The '%s' method is not initialized", MethodName))
			return FinalMethods
		end,
		FindMethodWithOffset = function(self, MethodOffset, searchResult)
			return self:FindMethodWithAddressInMemory(Il2cppRef.il2cppStart + MethodOffset, searchResult, MethodOffset)
		end,
		FindMethodWithAddressInMemory = function(self, MethodAddress, searchResult, MethodOffset)
			local RawMethodsInfo = {} 
			gg.clearResults()
			gg.setRanges(gg.REGION_C_HEAP | gg.REGION_C_ALLOC | gg.REGION_ANONYMOUS | gg.REGION_C_BSS | gg.REGION_C_DATA |
							 gg.REGION_OTHER)
			if gg.BUILD < 16126 then
				gg.searchNumber(string.format("%Xh", MethodAddress), Il2cppRef.MainType)
			else
				gg.loadResults({{address = MethodAddress, flags = Il2cppRef.MainType}})
				gg.searchPointer(0)
			end
			local r_count = gg.getResultsCount()
			if r_count > searchResult.len then
				local r = gg.getResults(r_count)
				for j = 1, #r do
					RawMethodsInfo[#RawMethodsInfo + 1] = {
						MethodAddress = MethodAddress, MethodInfoAddress = r[j].address, Offset = MethodOffset
					}
				end
			else
				searchResult.isNew = false
			end 
			gg.clearResults()
			assert(#RawMethodsInfo > 0, string.format("nothing was found for this address 0x%X", MethodAddress))
			return RawMethodsInfo
		end,
		DecodeMethodsInfo = function(self, _MethodsInfo, MethodsInfo)
			for i = 1, #_MethodsInfo do
				local index = (i - 1) * 6
				local TypeInfo = Il2cppRef:FixValue(MethodsInfo[index + 5].value)
				local _TypeInfo = gg.getValues({
                    {address = TypeInfo + Il2cppRef.TypeApi.Type, flags = gg.TYPE_BYTE},
                    {address = TypeInfo, flags = Il2cppRef.MainType}
                })
				local MethodAddress = Il2cppRef:FixValue(MethodsInfo[index + 1].value)
				local MethodFlags = MethodsInfo[index + 6].value
				_MethodsInfo[i] = {
					MethodName = _MethodsInfo[i].MethodName or Il2cppRef:Utf8ToString(Il2cppRef:FixValue(MethodsInfo[index + 2].value)),
					Offset = string.format("%X", _MethodsInfo[i].Offset or (MethodAddress == 0 and MethodAddress or MethodAddress - Il2cppRef.il2cppStart)),
					AddressInMemory = string.format("%X", MethodAddress),
					MethodInfoAddress = _MethodsInfo[i].MethodInfoAddress,
					ClassName = _MethodsInfo[i].ClassName or Il2cppRef.ClassApi:GetClassName(MethodsInfo[index + 3].value),
					ClassAddress = string.format('%X', Il2cppRef:FixValue(MethodsInfo[index + 3].value)),
					ParamCount = MethodsInfo[index + 4].value,
					ReturnType = Il2cppRef.TypeApi:GetTypeName(_TypeInfo[1].value, _TypeInfo[2].value),
					IsStatic = (MethodFlags & Il2CppFlags.Method.METHOD_ATTRIBUTE_STATIC) ~= 0,
					Access = Il2CppFlags.Method.Access[MethodFlags & Il2CppFlags.Method.METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK] or "",
					IsAbstract = (MethodFlags & Il2CppFlags.Method.METHOD_ATTRIBUTE_ABSTRACT) ~= 0,
				}
			end
		end,
		UnpackMethodInfo = function(self, MethodInfo)
			return {
				{address = MethodInfo.MethodInfoAddress, flags = Il2cppRef.MainType},
				{address = MethodInfo.MethodInfoAddress + self.NameOffset, flags = Il2cppRef.MainType},
				{address = MethodInfo.MethodInfoAddress + self.ClassOffset, flags = Il2cppRef.MainType},
				{address = MethodInfo.MethodInfoAddress + self.ParamCount, flags = gg.TYPE_BYTE},
				{address = MethodInfo.MethodInfoAddress + self.ReturnType, flags = Il2cppRef.MainType},
				{address = MethodInfo.MethodInfoAddress + self.Flags, flags = gg.TYPE_WORD}
			}, 
			{
				MethodName = MethodInfo.MethodName or nil, Offset = MethodInfo.Offset or nil,
				MethodInfoAddress = MethodInfo.MethodInfoAddress, ClassName = MethodInfo.ClassName
			}
		end,
		FindParamsCheck = {
			['number'] = function(self, method, searchResult)
				if (method > Il2cppRef.il2cppStart and method < Il2cppRef.il2cppEnd) then
					return Protect:Call(self.FindMethodWithAddressInMemory, self, method, searchResult)
				else
					return Protect:Call(self.FindMethodWithOffset, self, method, searchResult)
				end
			end,
			['string'] = function(self, method, searchResult)
				return Protect:Call(self.FindMethodWithName, self, method, searchResult)
			end,
			['default'] = function() return {Error = 'Invalid search criteria'} end
		},
		Find = function(self, method)
			local searchResult = Il2cppMemory:GetInformaionOfMethod(method)
			if not searchResult then searchResult = {len = 0} end
			searchResult.isNew = true
			local _MethodsInfo = (self.FindParamsCheck[type(method)] or self.FindParamsCheck['default'])(self, method, searchResult)
			if searchResult.isNew and _MethodsInfo and not _MethodsInfo.Error then
				local MethodsInfo = {}
				for i = 1, #_MethodsInfo do
					local MethodInfo; MethodInfo, _MethodsInfo[i] = self:UnpackMethodInfo(_MethodsInfo[i])
					table.move(MethodInfo, 1, #MethodInfo, #MethodsInfo + 1, MethodsInfo)
				end
				MethodsInfo = gg.getValues(MethodsInfo)
				self:DecodeMethodsInfo(_MethodsInfo, MethodsInfo)
				searchResult.len = #_MethodsInfo; searchResult.result = _MethodsInfo
				Il2cppMemory:SetInformaionOfMethod(method, searchResult)
            elseif _MethodsInfo and _MethodsInfo.Error then
                return _MethodsInfo -- Propagate error
			else
				_MethodsInfo = searchResult.result
			end
			return _MethodsInfo
		end
	}
	return MethodsApi
end)

__bundle_register("il2cppstruct.object", function(require, _LOADED, __bundle_register, __bundle_modules)
	local AndroidInfo = require("utils.androidinfo")
    local Il2cppRef -- Forward declaration

	---@class ObjectApi
	local ObjectApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		FilterObjects = function(self, Objects)
			local FilterObjects = {}; for k, v in ipairs(gg.getValuesRange(Objects)) do if v == 'A' then FilterObjects[#FilterObjects + 1] = Objects[k] end end
			Objects = FilterObjects; gg.loadResults(Objects); gg.searchPointer(0)
			if gg.getResultsCount() <= 0 and AndroidInfo.platform and AndroidInfo.sdk >= 30 then
				local FixRefToObjects = {}; for k, v in ipairs(Objects) do
					gg.searchNumber(tostring(v.address | 0xB400000000000000), gg.TYPE_QWORD)
					local RefToObject = gg.getResults(gg.getResultsCount())
					table.move(RefToObject, 1, #RefToObject, #FixRefToObjects + 1, FixRefToObjects); gg.clearResults()
				end; gg.loadResults(FixRefToObjects)
			end
			local RefToObjects, FilteredAgain = gg.getResults(gg.getResultsCount()), {}; gg.clearResults()
			for k, v in ipairs(gg.getValuesRange(RefToObjects)) do
				if v == 'A' then FilteredAgain[#FilteredAgain + 1] = {address = Il2cppRef:FixValue(RefToObjects[k].value), flags = RefToObjects[k].flags} end
			end
			gg.loadResults(FilteredAgain); local _FilteredObjects = gg.getResults(gg.getResultsCount()); gg.clearResults()
			return _FilteredObjects
		end,
		FindObjects = function(self, ClassAddress)
			gg.clearResults(); gg.setRanges(0)
			gg.setRanges(gg.REGION_C_HEAP | gg.REGION_C_HEAP | gg.REGION_ANONYMOUS | gg.REGION_C_BSS | gg.REGION_C_DATA | gg.REGION_C_ALLOC)
			gg.loadResults({{address = tonumber(ClassAddress, 16), flags = Il2cppRef.MainType}}); gg.searchPointer(0)
			if gg.getResultsCount() <= 0 and AndroidInfo.platform and AndroidInfo.sdk >= 30 then
				gg.searchNumber(tostring(tonumber(ClassAddress, 16) | 0xB400000000000000), gg.TYPE_QWORD)
			end
			local FindsResult = gg.getResults(gg.getResultsCount()); gg.clearResults()
			return self:FilterObjects(FindsResult)
		end,
		Find = function(self, ClassesInfoResults) -- Expects results from FindClass
            local Objects = {}
            if ClassesInfoResults and not ClassesInfoResults.Error then
                local ClassesInfo = ClassesInfoResults -- If it's already the array
                if type(ClassesInfoResults[1]) == "table" and ClassesInfoResults[1].ClassAddress then -- Check if it's nested
                     -- This case might occur if FindClass returns { [1] = { classInfo1, classInfo2 } }
                     -- We need to iterate through the inner table if it's the actual array of class infos
                else 
                    -- If FindClass returns { classInfo1, classInfo2 } directly
                    -- This branch might not be hit if FindClass always wraps in an outer table
                end

                -- Assuming ClassesInfo is the direct array of class info objects
			    for j = 1, #ClassesInfo do
                    if ClassesInfo[j] and ClassesInfo[j].ClassAddress then -- Ensure valid class info
				        local FindResult = self:FindObjects(ClassesInfo[j].ClassAddress)
				        table.move(FindResult, 1, #FindResult, #Objects + 1, Objects)
                    end
			    end
            else
                Il2cppRef:DebugPrint("🔴 FindObject received invalid or error in ClassesInfo.")
                if ClassesInfoResults and ClassesInfoResults.Error then return ClassesInfoResults end
            end
			return Objects
		end,
		FindHead = function(self, Address) -- Added self
			local validAddress = Il2cppRef:GetValidAddress(Address)
			local mayBeHead = {}; for i = 1, 1000 do mayBeHead[i] = {address = validAddress - (4 * (i - 1)), flags = Il2cppRef.MainType} end
			mayBeHead = gg.getValues(mayBeHead)
			for i = 1, #mayBeHead do
				local mayBeClass = Il2cppRef:FixValue(mayBeHead[i].value)
				if Il2cppRef.ClassApi:IsClassInfo(mayBeClass) then return mayBeHead[i] end -- Pass self if needed
			end
			return {value = 0, address = 0}
		end,
	}
	return ObjectApi
end)

__bundle_register("il2cppstruct.type", function(require, _LOADED, __bundle_register, __bundle_modules)
	local Il2cppMemory = require("utils.il2cppmemory")
    local Il2cppRef -- Forward declaration

	---@class TypeApi
	local TypeApi = {
        SetIl2cppRef = function(self, ref) Il2cppRef = ref end,
		tableTypes = {
			[1] = "void", [2] = "bool", [3] = "char", [4] = "sbyte", [5] = "byte", [6] = "short", [7] = "ushort",
			[8] = "int", [9] = "uint", [10] = "long", [11] = "ulong", [12] = "float", [13] = "double", [14] = "string",
			[22] = "TypedReference", [24] = "IntPtr", [25] = "UIntPtr", [28] = "object",
			[17] = function(index) return Il2cppRef.GlobalMetadataApi:GetClassNameFromIndex(index) end,
			[18] = function(index) return Il2cppRef.GlobalMetadataApi:GetClassNameFromIndex(index) end,
			[29] = function(index)
				local typeMassiv = gg.getValues({
					{address = Il2cppRef:FixValue(index), flags = Il2cppRef.MainType},
					{address = Il2cppRef:FixValue(index) + Il2cppRef.TypeApi.Type, flags = gg.TYPE_BYTE}
				})
				return Il2cppRef.TypeApi:GetTypeName(typeMassiv[2].value, typeMassiv[1].value) .. "[]"
			end,
			[21] = function(index)
				if not (Il2cppRef.GlobalMetadataApi.version < 27) then
					index = gg.getValues({{address = Il2cppRef:FixValue(index), flags = Il2cppRef.MainType}})[1].value
				end
				index = gg.getValues({{address = Il2cppRef:FixValue(index), flags = Il2cppRef.MainType}})[1].value
				return Il2cppRef.GlobalMetadataApi:GetClassNameFromIndex(index)
			end
		},
		GetTypeName = function(self, typeIndex, index)
			local typeName = self.tableTypes[typeIndex] or string.format('(not support type -> 0x%X)', typeIndex)
			if (type(typeName) == 'function') then
				local resultType = Il2cppMemory:GetInformationOfType(index)
				if not resultType then resultType = typeName(index); Il2cppMemory:SetInformationOfType(index, resultType) end
				typeName = resultType
			end
			return typeName
		end,
		GetTypeEnum = function(self, Il2CppType)
			return gg.getValues({{address = Il2CppType + self.Type, flags = gg.TYPE_BYTE}})[1].value
		end
	}
	return TypeApi
end)


-- Main Combined API Module
__bundle_register("Il2cppCombined", function(require, _LOADED, __bundle_register, __bundle_modules)
	local Il2cppMemory = require("utils.il2cppmemory")
	local VersionEngineModule = require("utils.version")
	local AndroidInfo = require("utils.androidinfo") -- Already loaded, just getting the table
	local SearcherModule = require("utils.universalsearcher")
	local PatchApiModule = require("utils.patchapi")
	local Protect = require("utils.protect")
	local StringUtils = require("utils.stringutils")
    
    -- Forward declare Il2cppBase for mutual recursion if any method in Il2cppBase needs to call a method on the instance `self`
    -- which is only fully formed after setmetatable. Usually not an issue with __index.
    local Il2cppBase

	Il2cppBase = {
		-- Properties from Il2cppApi.lua (will be initialized in __call)
		il2cppStart = 0,
		il2cppEnd = 0,
		globalMetadataStart = 0,
		globalMetadataEnd = 0,
		globalMetadataHeader = 0,
		MainType = AndroidInfo.platform and gg.TYPE_QWORD or gg.TYPE_DWORD,
		platform = AndroidInfo.platform, -- Added for direct access
		pointSize = AndroidInfo.platform and 8 or 4,
		
        -- Modules that will be part of the Il2cppCombined instance
		Il2CppTypeDefinitionApi = {}, -- Populated by VersionEngine
		MetadataRegistrationApi = require("il2cppstruct.metadataRegistration"),
		TypeApi = require("il2cppstruct.type"),
		MethodsApi = require("il2cppstruct.method"),
		GlobalMetadataApi = require("il2cppstruct.globalmetadata"),
		FieldApi = require("il2cppstruct.field"),
		ClassApi = require("il2cppstruct.class"),
		ObjectApi = require("il2cppstruct.object"),
		ClassInfoApi = require("il2cppstruct.api.classinfo"),
		FieldInfoApi = require("il2cppstruct.api.fieldinfo"),
		StringApi = require("il2cppstruct.il2cppstring"), -- Renamed from 'String' to avoid conflict
		MemoryManager = require("utils.malloc"), -- MAlloc from Il2cppApi

		-- New properties from Il2CppExplorer (defaults)
		debug = false,
		exitOnNotUnityGame = true,
		maxStringLength = 1000,
		_alphabet = {}, -- For ReadStringExplorer

		-- PatchesAddress from Il2cppApi.lua
		PatchesAddress = function(self, add, Bytescodes) -- Added self
			local patchCode = {}
			for code in string.gmatch(Bytescodes, '.') do
				patchCode[#patchCode + 1] = {address = add + #patchCode, value = string.byte(code), flags = gg.TYPE_BYTE}
			end
			local patch = PatchApiModule:Create(patchCode) -- Use PatchApiModule
			patch:Patch()
			return patch
		end,

		-- FindMethods, FindClass, FindObject, FindFields from Il2cppApi.lua
		FindMethods = function(self, searchParams) -- Added self
			Il2cppMemory:SaveResults()
			for i = 1, #searchParams do
				searchParams[i] = self.MethodsApi:Find(searchParams[i])
			end
			Il2cppMemory:ClearSavedResults()
			return searchParams
		end,
		FindClass = function(self, searchParams) -- Added self
			Il2cppMemory:SaveResults()
			for i = 1, #searchParams do
				searchParams[i] = self.ClassApi:Find(searchParams[i])
			end
			Il2cppMemory:ClearSavedResults()
			return searchParams
		end,
		FindObject = function(self, searchParams) -- Added self
            Il2cppMemory:SaveResults()
            local results = {}
            for i = 1, #searchParams do
                local classInfoResult = self.ClassApi:Find({Class = searchParams[i]})
                if classInfoResult and not classInfoResult.Error then
                    local objectResult = self.ObjectApi:Find(classInfoResult)
                    results[i] = objectResult
                else
                    results[i] = classInfoResult -- Propagate error or empty result
                end
            end
            Il2cppMemory:ClearSavedResults()
            return results
        end,
		FindFields = function(self, searchParams) -- Added self
			Il2cppMemory:SaveResults()
			for i = 1, #searchParams do
				local searchParam = searchParams[i]
				local searchResult = Il2cppMemory:GetInformationOfField(searchParam)
				if not searchResult then
					searchResult = self.FieldApi:Find(searchParam)
					Il2cppMemory:SetInformationOfField(searchParam, searchResult)
				end
				searchParams[i] = searchResult
			end
			Il2cppMemory:ClearSavedResults()
			return searchParams
		end,

		-- Utf8ToString, ChangeBytesOrder, FixValue, GetValidAddress, SearchPointer from Il2cppApi.lua
		Utf8ToString = function(self, Address, length) -- Added self
			local chars, char = {}, {address = Address, flags = gg.TYPE_BYTE}
			if not length then
				repeat
					local valNode = gg.getValues({char})[1]
                    if not valNode then break end -- Safety break
					_char = string.char(valNode.value & 0xFF)
					chars[#chars + 1] = _char
					char.address = char.address + 0x1
				until string.find(_char, "[%z%s]") or #chars > (self.maxStringLength * 2) -- Safety for very long unterm. strings
				return table.concat(chars, "", 1, #chars - 1)
			else
				for i = 1, length do
                    local valNode = gg.getValues({char})[1]
                    if not valNode then break end
					local _char_val = valNode.value
					chars[i] = string.char(_char_val & 0xFF)
					char.address = char.address + 0x1
				end
				return table.concat(chars)
			end
		end,
		ChangeBytesOrder = function(self, bytes) -- Added self
			local newBytes, index, lenBytes = {}, 0, #bytes / 2
			for byte in string.gmatch(bytes, "..") do
				newBytes[lenBytes - index] = byte; index = index + 1
			end
			return table.concat(newBytes)
		end,
		FixValue = function(self, val) -- Added self
			return self.platform and (val & 0x00FFFFFFFFFFFFFF) or (val & 0xFFFFFFFF)
		end,
		GetValidAddress = function(self, Address) -- Added self
			local lastByte = Address & 0x000000000000000F; local delta = 0
			local checkTable = {[12] = true, [4] = true, [8] = true, [0] = true}
			while not checkTable[lastByte - delta] do delta = delta + 1 end
			return Address - delta
		end,
		SearchPointer = function(self, address)
			address = self:ChangeBytesOrder(type(address) == 'number' and string.format('%X', address) or address)
			gg.searchNumber('h ' .. address)
			gg.refineNumber('h ' .. address:sub(1, 6))
			gg.refineNumber('h ' .. address:sub(1, 2))
			local FindsResult = gg.getResults(gg.getResultsCount()); gg.clearResults()
			return FindsResult
		end,

		-- Functions from Il2CppExplorer, adapted
		DebugPrint = function(self, str)
			if self.debug then print(str) end
		end,
		SetAllRanges = function(self)
			gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_HEAP | gg.REGION_C_ALLOC | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_PPSSPP |
						 gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_VIDEO | gg.REGION_OTHER |
						 gg.REGION_BAD | gg.REGION_CODE_APP | gg.REGION_CODE_SYS)
		end,
		ReadValue = function(self, addr, valueType)
			if type(addr) ~= 'number' then self:DebugPrint('🔴 ReadValue: expected number for addr, got ' .. type(addr)); return end
			if type(valueType) ~= 'number' then self:DebugPrint('🔴 ReadValue: expected number for valueType, got ' .. type(valueType)); return end
			local t = {{address = addr, flags = valueType}}; t = gg.getValues(t)
			return t[1].value
		end,
		ReadByte = function(self, addr) return self:ReadValue(addr, gg.TYPE_BYTE) end,
		ReadWord = function(self, addr) return self:ReadValue(addr, gg.TYPE_WORD) end, -- Renamed from ReadShort
		ReadDword = function(self, addr) return self:ReadValue(addr, gg.TYPE_DWORD) end,
		ReadQword = function(self, addr) return self:ReadValue(addr, gg.TYPE_QWORD) end, -- Added for completeness
		ReadPointer = function(self, addr) return self:ReadValue(addr, self.MainType) end,
		
        ReadStringExplorer = function(self, addr) -- Renamed from readString to avoid conflict
			if type(addr) ~= 'number' then self:DebugPrint('🔴 ReadStringExplorer: wrong argument, expected number, got ' .. type(addr)); return '' end
			local len = self:ReadDword(addr + (self.platform and 0x10 or 0x8))
			if len <= 0 or len > self.maxStringLength then return '' end -- Added len <= 0 check
			local strTable = {}
			for i = 1, len do
				strTable[i] = {address = addr + (self.platform and 0x14 or 0xC) + (2 * (i - 1)), flags = gg.TYPE_WORD}
			end
			strTable = gg.getValues(strTable)
			local str = ''
			for k, v in ipairs(strTable) do
				local c = v.value
				if (c > -1 and c < 129) then str = str .. string.char(c)
				else
					if (self._alphabet[c] ~= nil) then str = str .. self._alphabet[c]
					else self:DebugPrint('🟡 ReadStringExplorer: unrecognised character ' .. c .. '. Consider adding it to the alphabet.') end
				end
			end
			return str
		end,
		SetAlphabet = function(self, str)
			if type(str) ~= 'string' then self:DebugPrint('🔴 SetAlphabet: expected string, got ' .. type(str)); return end
			self._alphabet = {}
			str:gsub('[%z\1-\127\194-\244][\128-\191]*', function(c)
				local bytes = gg.bytes(c, 'UTF-16LE'); local utf8Chars = ''
				for k_b, v_b in pairs(bytes) do utf8Chars = utf8Chars .. string.char(v_b) end
                if #utf8Chars >= 2 then -- Ensure there are enough bytes for unpack
				    local short = string.unpack('<i2', utf8Chars)
				    self._alphabet[short] = c
                end
			end)
		end,

		IsClassPointer = function(self, address)
			local t = {{}}; t[1].address = address - (self.platform and 0x10 or 0x8); t[1].flags = self.MainType
			gg.clearResults(); gg.loadResults(t)
			t = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_WRITABLE)
			if t[1] == nil then return false end

			t[1].address = address - (self.platform and 0x8 or 0x4); t[1].flags = self.MainType
			gg.clearResults(); gg.loadResults(t)
			t = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_NO)
			if t[1] == nil then return false end

			t[1].address = address + (self.platform and 0x8 or 0x4); t[1].flags = self.MainType
			gg.clearResults(); gg.loadResults(t)
			t = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_READ_ONLY)
			if t[1] == nil then return false end
			return true
		end,
		GetClassMetadataPtr = function(self, classname)
			if type(classname) ~= 'string' then self:DebugPrint('🔴 GetClassMetadataPtr: expected string, got ' .. type(classname)); return {} end
			self:SetAllRanges(); gg.clearResults()
			local stringBytes = gg.bytes(classname, 'UTF-8'); local searchStr = '0'
			for k, v in ipairs(stringBytes) do searchStr = searchStr .. '; ' .. v end
			searchStr = searchStr .. '; 0::' .. (2 + #stringBytes)
			gg.searchNumber(searchStr, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, self.globalMetadataStart, self.globalMetadataEnd, 2)
			if gg.getResultsCount() < 2 then
				self:DebugPrint('🔴 GetClassMetadataPtr: cant find ' .. classname .. ' in metadata')
				return 0
			end
			return gg.getResults(2)[2].address
		end,
		GetAllocatedClassPtr = function(self, metadataPtr)
			local addr = 0x0
			for k, v in pairs(gg.getRangesList('libc_malloc')) do
				gg.clearResults()
				gg.searchNumber(string.format('%X', metadataPtr) .. 'h', self.MainType, false, gg.SIGN_EQUAL, v.start, v['end'], 0)
				local results = gg.getResults(100000); gg.clearResults()
				for i, res in ipairs(results) do
					if self:IsClassPointer(res.address) then
						addr = res.address - (self.platform and 0x10 or 0x8); break
					end
				end
				if addr > 0 then break end
			end
			if (addr == 0) then self:DebugPrint('🔴 GetAllocatedClassPtr: no valid pointer for ' .. string.format('%X', metadataPtr)) end
			return addr
		end,
		GetInstances = function(self, className)
			local mPtr = self:GetClassMetadataPtr(className)
			if ((mPtr == 0) or (mPtr == nil)) then return {} end
			local allocPtr = self:GetAllocatedClassPtr(mPtr)
			if (allocPtr == 0) then return {} end
			gg.setRanges(gg.REGION_ANONYMOUS); gg.clearResults()
			local r = {{}}; r[1].address = allocPtr; r[1].flags = self.MainType
			gg.loadResults(r); gg.searchPointer(0)
			r = gg.getResults(100000)
			if ((#r == 0)) then self:DebugPrint('🔴 GetInstances: no instances for ' .. className .. ', try loading class first') end
			gg.clearResults(); return r
		end,
		GetField = function(self, instance, offset, offsetX32, valueType)
			if type(instance) ~= 'table' then self:DebugPrint('🔴 GetField: expected table for instance, got ' .. type(instance)); return nil end
			if type(instance.address) ~= 'number' then self:DebugPrint('🔴 GetField: expected number for instance.address, got ' .. type(instance.address)); return nil end
			if type(valueType) ~= 'number' then self:DebugPrint('🔴 GetField: expected number for valueType, got ' .. type(valueType)); return nil end
			local currentOffset = self.platform and offset or offsetX32
			if currentOffset == nil then self:DebugPrint('🔴 GetField: offset for this architecture is not specified'); return nil end
			return self:ReadValue(instance.address + currentOffset, valueType)
		end,
		EditField = function(self, instance, offset, offsetX32, valueType, value)
			if type(instance) ~= 'table' then self:DebugPrint('🔴 EditField: expected table for instance, got ' .. type(instance)); return end
			if type(instance.address) ~= 'number' then self:DebugPrint('🔴 EditField: expected number for instance.address, got ' .. type(instance.address)); return end
			if type(valueType) ~= 'number' then self:DebugPrint('🔴 EditField: expected number for valueType, got ' .. type(valueType)); return end
            -- Value can be string for hex, or number.
			-- if type(value) ~= 'number' then self:DebugPrint('🔴 EditField: expected number for value, got ' .. type(value)); return end
			local currentOffset = self.platform and offset or offsetX32
			if currentOffset == nil then self:DebugPrint('🔴 EditField: offset for this architecture is not specified'); return end
			local t = {{}}; t[1].address = instance.address + currentOffset; t[1].flags = valueType; t[1].value = value
			gg.setValues(t)
		end,
		GetLibStart = function(self) return self.il2cppStart end,
		PatchLib = function(self, offset, offsetX32, patchedBytes, patchedBytesX32)
			gg.clearResults()
			if self.il2cppStart == 0 then self:DebugPrint("🔴 PatchLib: il2cppStart is 0. Call Init first."); return end
			
			local currentPatchedBytes = self.platform and patchedBytes or patchedBytesX32
			local currentOffset = self.platform and offset or offsetX32

			if (currentPatchedBytes == nil or currentOffset == nil) then
				self:DebugPrint('🔴 PatchLib: no valid patch for current architecture'); return
			end
			local currAddress = self.il2cppStart + currentOffset
			for k, v in ipairs(currentPatchedBytes) do
				local t = {{}}; t[1].address = currAddress; t[1].flags = gg.TYPE_DWORD -- Assuming DWORD patches
				if type(v) == 'number' then t[1].value = v; gg.setValues(t)
				elseif type(v) == 'string' then
					if v:startsWith('h') then t[1].value = v; gg.setValues(t)
					else t[1].value = (self.platform and '~A8 ' or '~A ') .. v; gg.setValues(t) end
				end
				currAddress = currAddress + 4 -- Assuming 4-byte patches
			end
		end,
		GetFunctionOffset = function(self, className, functionName)
			if type(functionName) ~= 'string' then self:DebugPrint('🔴 GetFunctionOffset: expected string for functionName, got '..type(functionName)); return nil end
			if ((type(className) ~= 'nil') and (type(className) ~= 'string')) then self:DebugPrint('🔴 GetFunctionOffset: expected string/nil for className, got '..type(className)); return nil end
			
            self:SetAllRanges(); gg.clearResults()
			local stringBytes = gg.bytes(functionName, 'UTF-8'); local searchStr = '0'
			for k, v in ipairs(stringBytes) do searchStr = searchStr .. '; ' .. v end
			searchStr = searchStr .. '; 0::' .. (2 + #stringBytes)
			
            gg.searchNumber(searchStr, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, self.globalMetadataStart, self.globalMetadataEnd, (className == nil) and 2 or nil)
			gg.refineNumber('0; ' .. stringBytes[1], gg.TYPE_BYTE)
			gg.refineNumber(stringBytes[1], gg.TYPE_BYTE)

			if gg.getResultsCount() == 0 then
				self:DebugPrint('Can\'t find ' .. functionName .. ' in metadata'); return nil
			end

			local addr = 0x0
			for index, result in pairs(gg.getResults(100000)) do
				for k, v_range in pairs(gg.getRangesList('libc_malloc')) do -- Ensure v_range is used
					gg.clearResults()
					gg.searchNumber(string.format('%X', result.address) .. 'h', self.MainType, false, gg.SIGN_EQUAL, v_range.start, v_range['end'], 0)
					local results_ptr = gg.getResults(100); gg.clearResults()
					for i, res in ipairs(results_ptr) do
						if self:IsFunctionPointer(res.address, className) then
							addr = self:ReadPointer(res.address - (self.platform and 0x10 or 0x8)); break
						end
					end
					if addr > 0 then break end
				end
                if addr > 0 then break end -- Break outer loop too
			end

			if addr == 0 then
				self:DebugPrint('🔴 GetFunctionOffset: no valid pointer for ' .. functionName .. ((className == nil) and '' or (' in ' .. className))); return nil
			end
			if self.il2cppStart == 0 then self:DebugPrint("🔴 GetFunctionOffset: il2cppStart is 0."); return nil end
			
            addr = addr - self.il2cppStart
			self:DebugPrint('🟢 GetFunctionOffset: offset for ' .. functionName .. ': ' .. string.format('%X', addr))
			return addr
		end,
		EditFunction = function(self, className, functionName, patchedBytes, patchedBytesX32)
			local offs = self:GetFunctionOffset(className, functionName)
			if (offs == nil) then return end
			self:PatchLib(offs, offs, patchedBytes, patchedBytesX32) -- offsetX32 is same as offset here as it's already resolved
		end,
		IsFunctionPointer = function(self, address, className)
			local t = {{}}; t[1].address = address - (self.platform and 0x10 or 0x8); t[1].flags = self.MainType
			gg.clearResults(); gg.loadResults(t)
			t = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_EXECUTABLE)
			if t[1] == nil then return false end

			t[1].address = address - (self.platform and 0x8 or 0x4); t[1].flags = self.MainType
			gg.clearResults(); gg.loadResults(t)
			t = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_EXECUTABLE)
			if t[1] == nil then return false end

			t[1].address = address + (self.platform and 0x8 or 0x4); t[1].flags = self.MainType
			gg.clearResults(); gg.loadResults(t)
			t = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_WRITABLE)
			if t[1] == nil then return false end

			if className ~= nil then
				local classPtrAddr = self:ReadPointer(address + (self.platform and 0x8 or 0x4))
                if classPtrAddr == 0 then return false end -- Check for nil pointer
                local nameAddr = self:ReadPointer(classPtrAddr + (self.platform and 0x10 or 0x8))
                if nameAddr == 0 then return false end -- Check for nil pointer

				local currAddr = nameAddr
				local classBytes = gg.bytes(className, 'UTF-8')
				for k_byte, v_byte in pairs(classBytes) do
					if (v_byte ~= self:ReadByte(currAddr)) then return false end
					currAddr = currAddr + 0x1
				end
			end
			return true
		end,

		-- PageMemoryManager from explorer.memory
		PageMemoryManager = {
			currentAddress = nil, freeSpace = 0, pages = {}, pageIndex = 0, _owner = nil,
			Init = function(pm_self, owner) pm_self._owner = owner; pm_self:Alloc() end, -- Initial alloc on init
			Alloc = function(pm_self)
				if (pm_self.pageIndex < #pm_self.pages) then
					pm_self.pageIndex = pm_self.pageIndex + 1; pm_self.freeSpace = 4096
					pm_self.currentAddress = pm_self.pages[pm_self.pageIndex]
					pm_self._owner:DebugPrint('🟢 PageMemory.Alloc: reused page ' .. string.format('%X', pm_self.currentAddress))
					return pm_self.pages[pm_self.pageIndex]
				end
				local ptr = gg.allocatePage(gg.PROT_READ | gg.PROT_WRITE | gg.PROT_EXEC)
				pm_self.currentAddress = ptr; pm_self.freeSpace = 4096
				pm_self.pageIndex = pm_self.pageIndex + 1; pm_self.pages[pm_self.pageIndex] = ptr
				pm_self._owner:DebugPrint('🟢 PageMemory.Alloc: allocated page ' .. string.format('%X', ptr))
				return ptr
			end,
			Write = function(pm_self, t_write)
				if type(t_write) ~= 'table' then pm_self._owner:DebugPrint('🔴 PageMemory.Write: expected table, got '..type(t_write)); return false end
				if #t_write == 0 then pm_self._owner:DebugPrint('🔴 PageMemory.Write: table is empty'); return false end
                
                -- Calculate space needed
				local spaceNeeded = 0
				for k, v in pairs(t_write) do
                    local valFlags = v.flags
                    if type(v.value) == "string" and v.value:startsWith("h") then -- Hex string
                        valFlags = math.floor((#v.value -1) / 2) -- e.g. hAABBCC is 3 bytes
                    elseif type(v.value) == "string" and (v.value:startsWith("~A") or v.value:startsWith("~N")) then -- Assembly
                        -- This is tricky, gg.setValues handles assembly size. Assume 4 bytes for now for planning.
                        valFlags = v.flags or 4 -- Default to 4 if flags not specified for asm
                    elseif valFlags == nil then
					    valFlags = (math.type(v.value) == 'float') and gg.TYPE_FLOAT or gg.TYPE_DWORD
                    end
                    if type(valFlags) ~= "number" or valFlags <= 0 then valFlags = gg.TYPE_DWORD end -- Default if invalid
                    t_write[k].flags = valFlags -- Ensure flags are set in the table
					spaceNeeded = spaceNeeded + valFlags
				end

				if spaceNeeded > 4096 then pm_self._owner:DebugPrint('🔴 PageMemory.Write: total size '..spaceNeeded..' exceeds page (4096)'); return false end
				if (spaceNeeded > pm_self.freeSpace) then pm_self:Alloc() end
                if (spaceNeeded > pm_self.freeSpace) then pm_self._owner:DebugPrint('🔴 PageMemory.Write: not enough free space even after alloc attempt'); return false end


				local tempTableForSetValues = {}
                local startAddressOfWrite = pm_self.currentAddress
				for k, v_item in ipairs(t_write) do
                    local itemCopy = { flags = v_item.flags, value = v_item.value } -- Create a copy for gg.setValues
					itemCopy.address = pm_self.currentAddress
					tempTableForSetValues[#tempTableForSetValues+1] = itemCopy
					pm_self.currentAddress = pm_self.currentAddress + v_item.flags
					pm_self.freeSpace = pm_self.freeSpace - v_item.flags
				end
				local res = gg.setValues(tempTableForSetValues)
				if type(res) ~= 'boolean' or not res then
					pm_self._owner:DebugPrint('🔴 PageMemory.Write: error while writing'); pm_self._owner:DebugPrint(res)
					return false, 0
				end
				pm_self._owner:DebugPrint('🟢 PageMemory.Write: free space left ' .. pm_self.freeSpace)
				return true, startAddressOfWrite -- Return success and start address
			end,
			Free = function(pm_self) -- Resets to the first allocated page for reuse
				if (#pm_self.pages == 0) then return end
				pm_self.pageIndex = 1
                pm_self.currentAddress = pm_self.pages[pm_self.pageIndex]
                pm_self.freeSpace = 4096
                pm_self._owner:DebugPrint('🟢 PageMemory.Free: reset to first page ' .. string.format('%X', pm_self.currentAddress))
			end
		},
	}

	local Il2cppCombined = {} -- Forward declare for metatable
	setmetatable(Il2cppCombined, {
		__call = function(self_mt, config) -- self_mt is Il2cppCombined table itself
            local instance = {} -- Create the actual instance object
			setmetatable(instance, {__index = Il2cppBase}) -- All methods from Il2cppBase

			config = config or {}
			
            -- Initialize properties from config or defaults
			instance.debug = config.debug ~= nil and config.debug or Il2cppBase.debug
			instance.exitOnNotUnityGame = config.exitOnNotUnityGame ~= nil and config.exitOnNotUnityGame or Il2cppBase.exitOnNotUnityGame
			instance.maxStringLength = config.maxStringLength ~= nil and config.maxStringLength or Il2cppBase.maxStringLength
			instance._alphabet = {} -- Initialize alphabet for this instance

            -- Pass the instance (self) to modules that need it
            SearcherModule:SetIl2cppRef(instance)
            VersionEngineModule:SetIl2cppRef(instance)
            instance.MetadataRegistrationApi:SetIl2cppRef(instance)
            instance.TypeApi:SetIl2cppRef(instance)
            instance.MethodsApi:SetIl2cppRef(instance)
            instance.GlobalMetadataApi:SetIl2cppRef(instance)
            instance.FieldApi:SetIl2cppRef(instance)
            instance.ClassApi:SetIl2cppRef(instance)
            instance.ObjectApi:SetIl2cppRef(instance)
            instance.ClassInfoApi:SetIl2cppRef(instance)
            instance.FieldInfoApi:SetIl2cppRef(instance)
            instance.StringApi:SetIl2cppRef(instance)


			if instance.exitOnNotUnityGame and #gg.getRangesList('global-metadata.dat') < 1 then
				print('🔴 Please, select a Unity game process.')
				if os and os.exit then os.exit() else return nil end -- Exit if possible
			end

			if config.libilcpp then
				instance.il2cppStart, instance.il2cppEnd = config.libil2cpp.start, config.libil2cpp['end']
			else
				instance.il2cppStart, instance.il2cppEnd = SearcherModule:FindIl2cpp()
			end
			if not instance.il2cppStart or instance.il2cppStart == 0 then
				 instance:DebugPrint('🔴 Il2cppCombined Init: Failed to get libil2cpp.so address. Many features will not work.')
                 -- Do not exit, allow partial functionality if user wishes
			else
                 instance:DebugPrint('🟢 Il2cppCombined Init: libil2cpp.so found at 0x'..string.format("%X", instance.il2cppStart)..' - 0x'..string.format("%X", instance.il2cppEnd))
            end

			if config.globalMetadata then
				instance.globalMetadataStart, instance.globalMetadataEnd = config.globalMetadata.start, config.globalMetadata['end']
			else
				instance.globalMetadataStart, instance.globalMetadataEnd = SearcherModule:FindGlobalMetaData()
			end
            if not instance.globalMetadataStart or instance.globalMetadataStart == 0 then
                instance:DebugPrint('🔴 Il2cppCombined Init: Failed to get global-metadata.dat address.')
            else
                instance:DebugPrint('🟢 Il2cppCombined Init: global-metadata.dat found at 0x'..string.format("%X", instance.globalMetadataStart)..' - 0x'..string.format("%X", instance.globalMetadataEnd))
            end


			if config.globalMetadataHeader then instance.globalMetadataHeader = config.globalMetadataHeader
			else instance.globalMetadataHeader = instance.globalMetadataStart end
			
			instance.MetadataRegistrationApi.metadataRegistration = config.metadataRegistration -- Can be nil, FindMetadataRegistration will be called if needed

			VersionEngineModule:ChooseVersion(config.il2cppVersion, instance.globalMetadataHeader)
			Il2cppMemory:ClearMemorize()

			instance.PageMemoryManager:Init(instance) -- Init after instance is mostly set up

            instance:DebugPrint("🟢 Il2cppCombined API Initialized.")
			return instance 
		end,
        -- __index is not strictly needed here if __call always returns a new instance with Il2cppBase as its metatable's __index.
        -- However, to allow calling methods on the table returned by `require` *before* `()` is used for initialization,
        -- we can provide a fallback.
		__index = function(tbl, key)
            -- This allows calling static-like utility functions if any were defined directly on Il2cppBase
            -- and not intended to be instance methods.
            local baseVal = Il2cppBase[key]
            if baseVal ~= nil then return baseVal end

			-- If trying to access methods before initialization via `()`
			if key == "FindMethods" or key == "PatchesAddress" -- Add other key methods
                -- Check if it's a function from Il2cppBase to give a more specific error
                or (type(Il2cppBase[key]) == "function")
            then
				error("API not initialized. Call Il2cppCombined() first. Attempted to access: " .. tostring(key))
			end
			return nil
		end
	})
	return Il2cppCombined
end)

-- Final export of the combined API
return __bundle_require("Il2cppCombined")

