-- https://github.com/HTCheater/Il2CppExplorer truonggiangsualai
if (explorer == nil or type(explorer) ~= 'table') then
	explorer = {}
end
-- Output debug messages
if explorer.debug == nil then
	explorer.debug = false -- M·∫∑c ƒë·ªãnh l√† false, b·∫°n c√≥ th·ªÉ ƒë·ªïi th√†nh true ƒë·ªÉ xem th√™m log
end
-- Let people know you are using my framework :D
if (explorer.printAdvert == nil) then
	explorer.printAdvert = true
end
-- Exit if selected process isn't Unity game
if (explorer.exitOnNotUnityGame == nil) then
	explorer.exitOnNotUnityGame = true
end

local libStart = 0x0 -- ƒê·ªãa ch·ªâ b·∫Øt ƒë·∫ßu c·ªßa libil2cpp.so
explorer.maxStringLength = 1000 -- Gi·ªõi h·∫°n ƒë·ªô d√†i chu·ªói khi ƒë·ªçc
local alphabet = {} -- B·∫£ng ch·ªØ c√°i cho vi·ªác ƒë·ªçc chu·ªói Unicode

if explorer.printAdvert then
	print('‚ú® Made with Il2CppExplorer by HTCheater (truonggiangsualai version)')
end

if (explorer.exitOnNotUnityGame and #gg.getRangesList('global-metadata.dat') < 1) then
	print('üî¥ Vui l√≤ng ch·ªçn game Unity.')
	os.exit()
end

-- String utils
string.startsWith = function(self, str)
	return self:find('^' .. str) ~= nil
end

string.endsWith = function(str, ending)
	return ending == '' or str:sub(-(#ending)) == ending
end

string.toUpper = function(str)
	local res, c = str:gsub('^%l', string.upper)
	return res
end

string.removeEnd = function(str, rem)
	return (str:gsub('^(.-)' .. rem .. '$', '%1'))
end

string.removeStart = function(str, rem)
	return (str:gsub('^' .. rem .. '(.-)$', '%1'))
end

local isx64 = gg.getTargetInfo().x64
local metadata_ranges = gg.getRangesList('global-metadata.dat') -- ƒê·ªïi t√™n ƒë·ªÉ tr√°nh xung ƒë·ªôt v·ªõi bi·∫øn metadata c·ª•c b·ªô
local TYPE_PTR = isx64 and gg.TYPE_QWORD or gg.TYPE_DWORD
local METADATA_INFO -- S·∫Ω ƒë∆∞·ª£c g√°n trong initMetadataIfNeeded

local function initMetadataIfNeeded()
    if METADATA_INFO then return end
    if #metadata_ranges > 0 then
        METADATA_INFO = metadata_ranges[1] -- Ch·ªâ l·∫•y range ƒë·∫ßu ti√™n t√¨m th·∫•y
        if explorer.debug then
            explorer.print("‚ÑπÔ∏è Metadata Range: start=0x" .. string.format("%X", METADATA_INFO.start) .. ", end=0x" .. string.format("%X", METADATA_INFO['end']))
        end
    else
        explorer.print("üî¥ Kh√¥ng t√¨m th·∫•y 'global-metadata.dat'. C√°c h√†m ph·ª• thu·ªôc metadata s·∫Ω kh√¥ng ho·∫°t ƒë·ªông.")
        METADATA_INFO = {start = 0, ['end'] = 0} -- ƒê·ªÉ tr√°nh l·ªói nil, nh∆∞ng c√°c h√†m s·∫Ω th·∫•t b·∫°i
    end
end


function explorer.setAllRanges()
	gg.setRanges(gg.REGION_JAVA_HEAP | gg.REGION_C_HEAP | gg.REGION_C_ALLOC | gg.REGION_C_DATA | gg.REGION_C_BSS | gg.REGION_PPSSPP |
					             gg.REGION_ANONYMOUS | gg.REGION_JAVA | gg.REGION_STACK | gg.REGION_ASHMEM | gg.REGION_VIDEO | gg.REGION_OTHER |
					             gg.REGION_BAD | gg.REGION_CODE_APP | gg.REGION_CODE_SYS)
end

function explorer.isClassPointer(address)
	local t = {}
	t[1] = {}
	t[1].address = address - (isx64 and 0x10 or 0x8)
	t[1].flags = TYPE_PTR
	gg.clearResults()
	gg.loadResults(t)
	t = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_WRITABLE)
	if t[1] == nil then return false end

	t[1].address = address - (isx64 and 0x8 or 0x4)
	t[1].flags = TYPE_PTR
	gg.clearResults()
	gg.loadResults(t)
	t = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_NO)
	if t[1] == nil then return false end

	t[1].address = address + (isx64 and 0x8 or 0x4)
	t[1].flags = TYPE_PTR
	gg.clearResults()
	gg.loadResults(t)
	t = gg.getResults(1, nil, nil, nil, nil, nil, nil, nil, gg.POINTER_READ_ONLY)
	if t[1] == nil then return false end
	return true
end

function explorer.getClassMetadataPtr(classname)
	initMetadataIfNeeded()
	if type(classname) ~= 'string' then
		explorer.print('üî¥ explorer.getClassMetadataPtr: classname ph·∫£i l√† string, nh·∫≠n ƒë∆∞·ª£c ' .. type(classname))
		return 0 -- Tr·∫£ v·ªÅ 0 thay v√¨ table r·ªóng ƒë·ªÉ nh·∫•t qu√°n
	end
	if METADATA_INFO.start == 0 then return 0 end -- Kh√¥ng c√≥ metadata

	explorer.setAllRanges()
	gg.clearResults()
	local stringBytes = gg.bytes(classname, 'UTF-8')
	if #stringBytes == 0 then return 0 end
	local searchStr = '0'
	for k, v in ipairs(stringBytes) do
		searchStr = searchStr .. '; ' .. v
	end
	searchStr = searchStr .. '; 0::' .. (2 + #stringBytes)

	gg.searchNumber(searchStr, gg.TYPE_BYTE, false, gg.SIGN_EQUAL, METADATA_INFO.start, METADATA_INFO['end'], 2)

	if gg.getResultsCount() < 2 then
		if explorer.debug then
			explorer.print('üî¥ explorer.getClassMetadataPtr: kh√¥ng t√¨m th·∫•y ' .. classname .. ' trong metadata')
		end
		return 0
	end
	return gg.getResults(2)[2].address
end

function explorer.getAllocatedClassPtr(metadataPtr)
    if metadataPtr == 0 or metadataPtr == nil then return 0 end
	local addr = 0x0
    -- N√™n t√¨m ki·∫øm trong c√°c v√πng nh·ªõ ph√π h·ª£p h∆°n thay v√¨ ch·ªâ libc_malloc
    -- V√≠ d·ª•: REGION_C_HEAP, REGION_ANONYMOUS
    local search_ranges = {"REGION_C_HEAP", "REGION_ANONYMOUS", "libc_malloc", "linker_alloc"}
	for _, range_name_part in ipairs(search_ranges) do
	    for k, v in pairs(gg.getRangesList(range_name_part)) do
		    gg.clearResults()
		    gg.searchNumber(string.format('%X', metadataPtr) .. 'h', TYPE_PTR, false, gg.SIGN_EQUAL, v.start, v['end'], 0)
		    local results = gg.getResults(100000) -- Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng ƒë·ªÉ tr√°nh qu√° t·∫£i
		    gg.clearResults()
		    for i, res in ipairs(results) do
			    if explorer.isClassPointer(res.address) then
				    addr = res.address - (isx64 and 0x10 or 0x8)
				    goto found_allocated_ptr -- Nh·∫£y ra kh·ªèi c√°c v√≤ng l·∫∑p
			    end
		    end
	    end
	end
    ::found_allocated_ptr::
	if (explorer.debug and (addr == 0)) then
		explorer.print('üî¥ explorer.getAllocatedClassPtr: kh√¥ng c√≥ con tr·ªè h·ª£p l·ªá cho metadataPtr 0x' .. string.format('%X', metadataPtr))
	end
	return addr
end

function explorer.getInstances(className, namespace)
	if namespace and explorer.debug then
		explorer.print("‚ÑπÔ∏è explorer.getInstances: namespace '"..tostring(namespace).."' ƒë∆∞·ª£c cung c·∫•p. Logic t√¨m ki·∫øm hi·ªán t·∫°i ch·ªß y·∫øu d·ª±a v√†o className.")
	end
	local mPtr = explorer.getClassMetadataPtr(className)
	if mPtr == 0 then return {} end
	local allocPtr = explorer.getAllocatedClassPtr(mPtr)
	if allocPtr == 0 then return {} end
	
	gg.setRanges(gg.REGION_ANONYMOUS) -- C√≥ th·ªÉ c·∫ßn m·ªü r·ªông v√πng n√†y
	gg.clearResults()
	local r = {{address = allocPtr, flags = TYPE_PTR}}
	gg.loadResults(r)
	gg.searchPointer(0) -- T√¨m c√°c con tr·ªè tr·ªè ƒë·∫øn allocPtr (th∆∞·ªùng l√† c√°c instance)
	r = gg.getResults(10000) -- Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng instance tr·∫£ v·ªÅ
	if (#r == 0 and explorer.debug) then
		explorer.print('üî¥ explorer.getInstances: kh√¥ng c√≥ instance cho ' .. className)
	end
	gg.clearResults()
	return r
end

function explorer.getLib()
    if libStart ~= 0x0 then return end -- ƒê√£ l·∫•y tr∆∞·ªõc ƒë√≥

	explorer.setAllRanges()
	local libRanges = gg.getRangesList('libil2cpp.so')
	if #libRanges > 0 then
	    for _, rangeEntry in ipairs(libRanges) do
	        if rangeEntry.isExecutable then -- Ch·ªâ l·∫•y v√πng th·ª±c thi ƒë·∫ßu ti√™n
	            libStart = rangeEntry.start
	            explorer.print("üü¢ explorer.getLib: libil2cpp.so found at 0x"..string.format("%X", libStart))
	            return
	        end
	    end
	end

	explorer.print("‚ö†Ô∏è explorer.getLib: 'libil2cpp.so' not found directly. Attempting fallback.")
	-- Fallback (√≠t ƒë√°ng tin c·∫≠y h∆°n)
	local allRanges = gg.getRangesList()
	for _, rangeEntry in ipairs(allRanges) do
		if rangeEntry.isExecutable and rangeEntry.name and string.find(rangeEntry.name, "libil2cpp.so") then
			libStart = rangeEntry.start
			explorer.print("üü¢ explorer.getLib: libil2cpp.so (fallback) found at 0x"..string.format("%X", libStart))
			return
		end
	end
	if libStart == 0x0 then
		explorer.print('üî¥ explorer.getLib: kh√¥ng th·ªÉ l·∫•y ƒë·ªãa ch·ªâ libil2cpp.so.')
	end
end

function explorer.getField(instance, offset, fieldName, valueType, offsetX32)
	local instanceAddress
	if type(instance) == 'table' and type(instance.address) == 'number' then
		instanceAddress = instance.address
	elseif type(instance) == 'number' then
		instanceAddress = instance
	else
		explorer.print('üî¥ explorer.getField: instance ph·∫£i l√† table c√≥ address ho·∫∑c number, nh·∫≠n ƒë∆∞·ª£c ' .. type(instance))
		return nil
	end
	if type(valueType) ~= 'number' then
		explorer.print('üî¥ explorer.getField: valueType ph·∫£i l√† number, nh·∫≠n ƒë∆∞·ª£c ' .. type(valueType))
		return nil
	end
	local currentOffset = isx64 and offset or (offsetX32 or offset) -- ∆Øu ti√™n offsetX32 n·∫øu l√† 32bit v√† ƒë∆∞·ª£c cung c·∫•p
	if currentOffset == nil then
		explorer.print('üî¥ explorer.getField: offset kh√¥ng ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh cho ki·∫øn tr√∫c n√†y.')
		return nil
	end
	if type(currentOffset) ~= 'number' then
	    explorer.print('üî¥ explorer.getField: offset ph·∫£i l√† number, nh·∫≠n ƒë∆∞·ª£c '.. type(currentOffset))
	    return nil
	end
	return explorer.readValue(instanceAddress + currentOffset, valueType)
end

function explorer.getStaticField(className, fieldName, namespace, valueType, staticFieldDataPointerOffset, fieldOffsetInStaticData)
    if not explorer.debug then 
        -- T·∫Øt t·∫°m c√°c print kh√¥ng c·∫ßn thi·∫øt n·∫øu kh√¥ng ·ªü debug mode
        local oldPrint = explorer.print
        explorer.print = function() end 
    end

    if type(className) ~= 'string' then explorer.print('üî¥ getStaticField: className ph·∫£i l√† string.'); return nil end
    if type(fieldName) ~= 'string' then explorer.print('üî¥ getStaticField: fieldName ph·∫£i l√† string.'); return nil end
    if namespace and type(namespace) ~= 'string' then explorer.print('üî¥ getStaticField: namespace ph·∫£i l√† string ho·∫∑c nil.'); return nil end
    if type(valueType) ~= 'number' then explorer.print('üî¥ getStaticField: valueType ph·∫£i l√† number.'); return nil end

    local mPtr = explorer.getClassMetadataPtr(className)
    if mPtr == 0 then explorer.print("üî¥ getStaticField: Kh√¥ng t√¨m th·∫•y metadata ptr cho class: " .. className); if oldPrint then explorer.print = oldPrint end; return nil end

    -- L·∫•y Il2CppClass object. ƒê√¢y l√† b∆∞·ªõc quan tr·ªçng v√† c√≥ th·ªÉ kh√°c nhau t√πy theo c√°ch Il2CppExplorer t√¨m th·∫•y n√≥.
    -- getAllocatedClassPtr tr·∫£ v·ªÅ con tr·ªè t·ªõi instance c·ªßa class n·∫øu n√≥ l√† MonoBehaviour, ho·∫∑c c·∫•u tr√∫c class n·∫øu n√≥ ƒë∆∞·ª£c c·∫•p ph√°t.
    -- ƒê·ªëi v·ªõi static fields, ch√∫ng ta c·∫ßn con tr·ªè ƒë·∫øn Il2CppClass object th·ª±c s·ª±.
    -- Th√¥ng th∆∞·ªùng, static_fields n·∫±m trong Il2CppClass.
    -- Gi·∫£ s·ª≠ getAllocatedClassPtr tr·∫£ v·ªÅ m·ªôt con tr·ªè c√≥ th·ªÉ d√πng ƒë·ªÉ truy c·∫≠p static_fields_offset
    local classObjectRuntimePtr = explorer.getAllocatedClassPtr(mPtr) 
    if classObjectRuntimePtr == 0 then 
        explorer.print("üî¥ getStaticField: Kh√¥ng t√¨m th·∫•y allocated class object cho: " .. className .. ". Th·ª≠ t√¨m tr·ª±c ti·∫øp t·ª´ metadata image (c·∫ßn code ph·ª©c t·∫°p h∆°n)."); 
        if oldPrint then explorer.print = oldPrint end; 
        return nil 
    end

    if not staticFieldDataPointerOffset or not fieldOffsetInStaticData then
        explorer.print("üî¥ getStaticField: C·∫ßn `staticFieldDataPointerOffset` v√† `fieldOffsetInStaticData` cho " .. className .. "." .. fieldName)
        explorer.print("   ƒê√¢y l√† c√°c offset ƒë·∫∑c th√π c·ªßa game, c·∫ßn t√¨m t·ª´ dump.cs ho·∫∑c reverse engineering.")
        explorer.print("   V√≠ d·ª•: staticFieldDataPointerOffset l√† offset t·ª´ ƒë·∫ßu Il2CppClass* ƒë·∫øn con tr·ªè static_fields.")
        explorer.print("   fieldOffsetInStaticData l√† offset c·ªßa tr∆∞·ªùng tƒ©nh b√™n trong kh·ªëi static_fields ƒë√≥.")
        if oldPrint then explorer.print = oldPrint end
        return nil
    end

    local staticFieldsBlockPtr = explorer.readPointer(classObjectRuntimePtr + staticFieldDataPointerOffset)
    if not staticFieldsBlockPtr or staticFieldsBlockPtr == 0 then
        explorer.print("üî¥ getStaticField: Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c con tr·ªè kh·ªëi static data cho " .. className .. " t·∫°i classObjectPtr + 0x" .. string.format("%X", staticFieldDataPointerOffset))
        if oldPrint then explorer.print = oldPrint end
        return nil
    end
    
    local fieldValue = explorer.readValue(staticFieldsBlockPtr + fieldOffsetInStaticData, valueType)

    if fieldValue ~= nil and valueType == TYPE_PTR and fieldValue ~= 0 then
        -- N·∫øu l√† Singleton Instance, tr·∫£ v·ªÅ d·∫°ng table instance
        if fieldName == "Instance" or fieldName == "instance" then
             if oldPrint then explorer.print = oldPrint end
            return { address = fieldValue, __className = className }
        end
    end
    
    if oldPrint then explorer.print = oldPrint end -- Kh√¥i ph·ª•c h√†m print
    return fieldValue
end


-- C√°c h√†m kh√°c gi·ªØ nguy√™n nh∆∞ file b·∫°n cung c·∫•p
-- ... (readValue, readByte, readShort, readInt, readPointer, print, readString, setAlphabet)
-- ... (memory.alloc, memory.write, memory.resetAllocator)
-- ... (ph·∫ßn getFunction, editFunction, patchLib, isFunctionPointer n·∫øu b·∫°n c√≥ gi·ªØ l·∫°i)

-- ƒê·∫£m b·∫£o c√°c h√†m ƒë·ªçc c∆° b·∫£n ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ƒë√∫ng
function explorer.readValue(addr, valueType)
	if type(addr) ~= 'number' or addr == 0 then
		explorer.print('üî¥ explorer.readValue: ƒë·ªãa ch·ªâ kh√¥ng h·ª£p l·ªá ' .. tostring(addr))
		return nil
	end
	if type(valueType) ~= 'number' then
		explorer.print('üî¥ explorer.readValue: valueType kh√¥ng h·ª£p l·ªá ' .. type(valueType))
		return nil
	end
	local t = {{address = addr, flags = valueType}}
	t = gg.getValues(t)
    if t and t[1] then return t[1].value end
    explorer.print('üî¥ explorer.readValue: gg.getValues th·∫•t b·∫°i cho ƒë·ªãa ch·ªâ ' .. string.format('%X', addr))
    return nil
end

function explorer.readByte(addr) return explorer.readValue(addr, gg.TYPE_BYTE) end
function explorer.readShort(addr) return explorer.readValue(addr, gg.TYPE_WORD) end
function explorer.readInt(addr) return explorer.readValue(addr, gg.TYPE_DWORD) end
function explorer.readPointer(addr) return explorer.readValue(addr, TYPE_PTR) end

function explorer.print(str)
	if explorer.debug then print(str) end
end

function explorer.readString(addr)
	if type(addr) ~= 'number' or addr == 0 then
		explorer.print('üî¥ explorer.readString: ƒë·ªãa ch·ªâ kh√¥ng h·ª£p l·ªá: ' .. tostring(addr))
		return ''
	end
	local len_offset = isx64 and 0x10 or 0x8 
	local first_char_offset = isx64 and 0x14 or 0xC
	local len = explorer.readInt(addr + len_offset)

	if len == nil or len <= 0 or len > explorer.maxStringLength then
	    if len and len > explorer.maxStringLength then explorer.print("üü° readString: ƒê·ªô d√†i chu·ªói " .. len .. " > max " .. explorer.maxStringLength)
	    elseif len == nil then explorer.print("üî¥ readString: Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c ƒë·ªô d√†i chu·ªói t·∫°i 0x" .. string.format('%X', addr + len_offset)) end
		return ''
	end

	local strTable = {}
	for i = 0, len - 1 do
		strTable[i+1] = {address = addr + first_char_offset + (i * 2), flags = gg.TYPE_WORD}
	end
	if #strTable == 0 then return "" end
	strTable = gg.getValues(strTable)
	if not strTable then explorer.print("üî¥ readString: gg.getValues th·∫•t b·∫°i khi ƒë·ªçc k√Ω t·ª±."); return "" end

	local chars = {}
	for _, v_entry in ipairs(strTable) do
	    if v_entry and v_entry.value then
		    local char_code = v_entry.value
		    if char_code >= 0 and char_code < 0xD800 then -- Non-surrogate
		        table.insert(chars, utf8.char(char_code)) -- S·ª≠ d·ª•ng utf8.char ƒë·ªÉ x·ª≠ l√Ω Unicode t·ªët h∆°n
		    else
		        table.insert(chars, "?") -- Thay th·∫ø c√°c k√Ω t·ª± ph·ª©c t·∫°p ho·∫∑c surrogate
		    end
		else
		    explorer.print("üî¥ readString: M·ª•c nil trong strTable.")
		end
	end
	return table.concat(chars)
end

function explorer.setAlphabet(str)
    -- H√†m n√†y c√≥ th·ªÉ kh√¥ng c√≤n c·∫ßn thi·∫øt n·∫øu readString d√πng utf8.char
    -- Ho·∫∑c c√≥ th·ªÉ gi·ªØ l·∫°i ƒë·ªÉ t√πy ch·ªânh n·∫øu c·∫ßn
	if type(str) ~= 'string' then
		explorer.print('üî¥ explorer.setAlphabet: tham s·ªë ph·∫£i l√† string, nh·∫≠n ƒë∆∞·ª£c ' .. type(str))
		return
	end
	alphabet = {} -- Reset
	-- Logic c≈© c√≥ th·ªÉ kh√¥ng hi·ªáu qu·∫£ v·ªõi utf8.char, xem x√©t l·∫°i n·∫øu d√πng
end


-- Memory allocation (gi·ªØ nguy√™n t·ª´ b·∫£n c·ªßa b·∫°n)
memory = {}
local currentAllocAddress = nil
local freeAllocSpace = nil
local allocatedPages = {}
local currentPageIndex = 0

function memory.getcurrentAddress() return currentAllocAddress end
function memory.getFreeSpace() return freeAllocSpace end
function memory.getPages() return allocatedPages end

function memory.alloc(size_needed)
¬† ¬† size_needed = size_needed or 4096 
¬† ¬† if currentPageIndex > 0 and allocatedPages[currentPageIndex] and freeAllocSpace >= size_needed then
¬† ¬† ¬† ¬† local alloc_ptr = currentAllocAddress
¬† ¬† ¬† ¬† currentAllocAddress = currentAllocAddress + size_needed
¬† ¬† ¬† ¬† freeAllocSpace = freeAllocSpace - size_needed
        if allocatedPages[currentPageIndex] then allocatedPages[currentPageIndex].used = allocatedPages[currentPageIndex].used + size_needed end
¬† ¬† ¬† ¬† explorer.print('üü¢ memory.alloc: c·∫•p '..size_needed..' bytes t·ª´ trang hi·ªán t·∫°i. ƒê·ªãa ch·ªâ m·ªõi: ' .. string.format('%X', currentAllocAddress))
¬† ¬† ¬† ¬† return alloc_ptr
¬† ¬† end
¬† ¬† local num_pages_to_alloc = math.ceil(size_needed / 4096)
¬† ¬† local total_allocated_size = num_pages_to_alloc * 4096
¬† ¬† local ptr = gg.allocatePage(gg.PROT_READ | gg.PROT_WRITE | gg.PROT_EXEC, total_allocated_size)
¬† ¬† if not ptr or ptr == 0 then
¬† ¬† ¬† ¬† explorer.print('üî¥ memory.alloc: gg.allocatePage th·∫•t b·∫°i khi c·∫•p '..total_allocated_size..' bytes.')
¬† ¬† ¬† ¬† return nil
¬† ¬† end
¬† ¬† currentAllocAddress = ptr
¬† ¬† freeAllocSpace = total_allocated_size
¬† ¬† currentPageIndex = currentPageIndex + 1
¬† ¬† allocatedPages[currentPageIndex] = {start = ptr, size = total_allocated_size, used = 0}
¬† ¬† explorer.print('üü¢ memory.alloc: c·∫•p trang m·ªõi '..total_allocated_size..' bytes t·∫°i ' .. string.format('%X', currentAllocAddress))
¬† ¬† local alloc_ptr = currentAllocAddress
¬† ¬† currentAllocAddress = currentAllocAddress + size_needed
¬† ¬† freeAllocSpace = freeAllocSpace - size_needed
¬† ¬† allocatedPages[currentPageIndex].used = size_needed
¬† ¬† explorer.print('üü¢ memory.alloc: ƒë√£ c·∫•p '..size_needed..' bytes. ƒê·ªãa ch·ªâ m·ªõi: ' .. string.format('%X', currentAllocAddress))
¬† ¬† return alloc_ptr
end

function memory.write(data_table)
	if type(data_table) ~= 'table' then explorer.print('üî¥ memory.write: data_table ph·∫£i l√† table.'); return false, nil end
	local spaceNeeded = 0
	for k, v_entry in ipairs(data_table) do
		if type(v_entry) ~= 'table' or v_entry.value == nil then explorer.print('üî¥ memory.write: entry l·ªói t·∫°i index ' .. k); return false, nil end
		if (v_entry.flags == nil) then
			if math.type(v_entry.value) == 'float' then v_entry.flags = gg.TYPE_FLOAT
			elseif type(v_entry.value) == 'string' and v_entry.value:sub(1,1) == 'h' then v_entry.flags = gg.TYPE_DWORD 
			else v_entry.flags = gg.TYPE_DWORD end
			data_table[k] = v_entry
		end
		spaceNeeded = spaceNeeded + (v_entry.flags == gg.TYPE_STRING and (utf8.len(v_entry.value) * 2 + 2) or v_entry.flags) -- ∆Ø·ªõc t√≠nh cho UTF-16
	end
	local startAddress = memory.alloc(spaceNeeded)
	if not startAddress then explorer.print('üî¥ memory.write: kh√¥ng c·∫•p ph√°t ƒë∆∞·ª£c b·ªô nh·ªõ.'); return false, nil end
	local tempWriteTable = {}
	local currentWriteAddr = startAddress
	for k, v_entry in ipairs(data_table) do
		table.insert(tempWriteTable, {address = currentWriteAddr, flags = v_entry.flags, value = v_entry.value})
		currentWriteAddr = currentWriteAddr + (v_entry.flags == gg.TYPE_STRING and (utf8.len(v_entry.value) * 2 + 2) or v_entry.flags)
	end
	if not gg.setValues(tempWriteTable) then explorer.print('üî¥ memory.write: gg.setValues th·∫•t b·∫°i.'); return false, nil end
	explorer.print('üü¢ memory.write: ƒë√£ ghi ' .. #data_table .. ' items t·∫°i ' .. string.format('%X', startAddress))
	return true, startAddress
end

function memory.resetAllocator()
	currentAllocAddress = nil
	freeAllocSpace = 0
	currentPageIndex = 0
	explorer.print('üü¢ memory.resetAllocator: B·ªô c·∫•p ph√°t ƒë√£ ƒë∆∞·ª£c reset.')
end

if next(alphabet) == nil then
    -- Kh√¥ng c·∫ßn setAlphabet n·∫øu readString ƒë√£ x·ª≠ l√Ω Unicode t·ªët
    -- explorer.setAlphabet("...") 
end

memory.resetAllocator()
initMetadataIfNeeded() -- G·ªçi ƒë·ªÉ kh·ªüi t·∫°o METADATA_INFO s·ªõm

return explorer
